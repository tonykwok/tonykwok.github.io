

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>High-performance image processing &mdash; FCam for Tegra 1.3 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="FCam for Tegra 1.3 documentation" href="index.html" />
    <link rel="next" title="The FCameraPro application" href="fcamerapro.html" />
    <link rel="prev" title="Camera Control using the FCam API" href="fcam.html" /> 
  </head>
  <body>

<div style="background-color: black; text-align: left; padding: 10px 10px 15px 15px">
<a href="index.html"><img src="_static/nvidia_logo.png" border="0" alt="NVIDIA logo"/></a>
</div>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="fcamerapro.html" title="The FCameraPro application"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="fcam.html" title="Camera Control using the FCam API"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">home</a>|&nbsp;</li>
        <li><a href="search.html">search</a>|&nbsp;</li>
 
      </ul>
    </div>

      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">High-performance image processing</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#prerequisites">Prerequisites</a></li>
<li><a class="reference internal" href="#test-application">Test application</a></li>
<li><a class="reference internal" href="#example-1-adding-images">Example 1: Adding images</a><ul>
<li><a class="reference internal" href="#vectorizing-the-computation-with-neon-intrinsics">Vectorizing the computation with NEON intrinsics</a></li>
<li><a class="reference internal" href="#adding-multi-threading">Adding multi-threading</a></li>
<li><a class="reference internal" href="#combining-multi-threading-and-neon-code">Combining multi-threading and NEON code</a></li>
</ul>
</li>
<li><a class="reference internal" href="#example-2-gaussian-blur">Example 2: Gaussian blur</a><ul>
<li><a class="reference internal" href="#id1">Vectorizing the computation with NEON intrinsics</a></li>
<li><a class="reference internal" href="#id2">Adding multi-threading</a></li>
<li><a class="reference internal" href="#id3">Combining multi-threading and NEON code</a></li>
<li><a class="reference internal" href="#going-further-cache-blocking">Going further: cache blocking</a></li>
<li><a class="reference internal" href="#going-further-data-prefetching">Going further: data prefetching</a></li>
</ul>
</li>
<li><a class="reference internal" href="#performance-analysis">Performance analysis</a><ul>
<li><a class="reference internal" href="#speed-up-comparison">Speed-up comparison</a></li>
<li><a class="reference internal" href="#is-my-algorithm-compute-or-memory-bound">Is my algorithm compute or memory bound?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#example-3-computing-a-measure-of-similarity-between-images">Example 3: Computing a measure of similarity between images</a><ul>
<li><a class="reference internal" href="#id4">Test application</a></li>
<li><a class="reference internal" href="#accelerating-image-processing-with-opengl-es-2-0">Accelerating image processing with OpenGL ES 2.0</a></li>
<li><a class="reference internal" href="#d-perspective-warp-on-the-gpu">2D perspective warp on the GPU</a></li>
<li><a class="reference internal" href="#computing-a-sum-of-pixel-values-on-the-gpu">Computing a sum of pixel values on the GPU</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="fcam.html"
                        title="previous chapter">Camera Control using the FCam API</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="fcamerapro.html"
                        title="next chapter">The FCameraPro application</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/imageprocessing.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="high-performance-image-processing">
<h1>High-performance image processing<a class="headerlink" href="#high-performance-image-processing" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The objective of this tutorial is to demonstrate various optimization
strategies for image processing algorithms on NVIDIA Tegra devices.
Many computer graphics and vision methods are computationally demanding, but their
computation and data access patterns are characterized by high data locality and
relatively independent calculation. This, so called, <em>data-parallel</em> paradigm means
that a typical image processing algorithm can be decomposed into a series of independent
operations applied to a large array of elements (e.g., image pixels).
We can significantly increase the speed of such calculations with Tegra&#8217;s powerful
computation engines, namely multi-core ARM CPU with SIMD unit and a GPU.
In this section, we will demonstrate on various examples how to use this hardware to
speed up your image processing code.</p>
<div class="admonition-note admonition">
<p class="first admonition-title">Note</p>
<p class="last">Throughout this tutorial you will see many source code fragments. All the code segments,
except those in <cite>Implementation Note</cite> sections, should be copied to the test bed application.
<cite>Implementation Notes</cite> contain short discussions of technical details, and their
corresponding source already exists in the project source base.</p>
</div>
</div>
<div class="section" id="prerequisites">
<h2>Prerequisites<a class="headerlink" href="#prerequisites" title="Permalink to this headline">¶</a></h2>
<p>This tutorial is by no means a complete introduction to parallel programming or
general optimization techniques. Specifically, we assume that you are familiar
with general C++ programming and basic graphics pipeline/OpenGL API. Below we
include a list of resources that will be helpful in both understanding the
contents of this tutorial and developing your own code on top of it.</p>
<ol class="arabic simple">
<li><a class="reference external" href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0406b/index.html">ARM Architecture Reference Manual</a>
&#8212; contains a complete description of ARM architecture and machine language, including
detailed description of the ARM NEON instruction set.</li>
<li><a class="reference external" href="http://www.agner.org/optimize/">Optimizing software in C++</a>
&#8212; a comprehensive presentation on general code optimization techniques. Some sections are specific
to <em>x86</em> architecture, but the majority of presented methodology also applies to Tegra SOCs.</li>
<li><a class="reference external" href="http://www.ethernut.de/en/documents/arm-inline-asm.html">ARM inline assembly tutorial</a>
&#8212; an introduction to GNU Assembler (gas). Contains a basic introduction to writing inline
ARM assembly for GNU C compiler. In this tutorial we use NEON intrinsics and let
the compiler to deal with low-level tasks, such as register allocation or instruction
scheduling.</li>
<li><a class="reference external" href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0204j/Bcfjicfj.html">ARM NEON assembly guide</a>
&#8212; ARM NEON instruction set reference web page.</li>
<li><a class="reference external" href="http://blogs.arm.com/software-enablement/161-coding-for-neon-part-1-load-and-stores/">ARM NEON image processing tutorial</a>
&#8212; an image processing tutorial from ARM.</li>
<li><a class="reference external" href="http://code.google.com/p/math-neon/">ARM NEON math library</a>
&#8212; an open source library that implements many useful math functions with ARM NEON code.</li>
<li><a class="reference external" href="https://computing.llnl.gov/tutorials/pthreads/">POSIX Threads programming tutorial</a>
&#8212; a detailed introduction to the API and basic concepts of threaded program design.</li>
<li><a class="reference external" href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf">OpenGL ES Specification Version 2.0.25</a>
&#8212; a full specification of <em>OpenGL ES 2.0</em> API.</li>
<li><a class="reference external" href="http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf">OpenGL ES Shading Language Version 1.00</a>
&#8212; a specification of OpenGL ES shading language.</li>
</ol>
</div>
<div class="section" id="test-application">
<h2>Test application<a class="headerlink" href="#test-application" title="Permalink to this headline">¶</a></h2>
<p>The performance of the examples we cover here is evaluated inside a test-bed application.
Before explaining how it works, let&#8217;s try to build and run it.
Import it to Eclipse as an existing project.
Open Eclipse, select <em>File &gt; Import &gt; Android &gt; Existing Android Code into
Workspace</em>, and browse into the <em>Root Directory</em> of the test app (<tt class="docutils literal"><span class="pre">/tutorials/ImageProcessingNeonMT</span></tt>).
If you choose to copy the files into workspace, you may have to also copy the folder <tt class="docutils literal"><span class="pre">SharedCode</span></tt> under
the <tt class="docutils literal"><span class="pre">tutorials</span></tt> folder into the workspace.
Then hit <strong>Finish</strong>.</p>
<p>As this is a native project, select the C/C++ perspective.</p>
<a class="reference internal image-reference" href="_images/c_cpp_perspective.png"><img alt="_images/c_cpp_perspective.png" src="_images/c_cpp_perspective.png" style="width: 142.0px; height: 34.0px;" /></a>
<p>By default all Android projects are Java projects, so let&#8217;s convert ours to native
by right-clicking on the project in <em>Package Explorer</em> and selecting <em>Android Tools &gt; Add Native Support</em>.</p>
<a class="reference internal image-reference" href="_images/image_proc_native_support.png"><img alt="_images/image_proc_native_support.png" src="_images/image_proc_native_support.png" style="width: 648.0px; height: 197.0px;" /></a>
<p>Then we have to select a name for the library storing the native code. Please use <em>ImageProcessingNeonMT</em>
as the name.</p>
<a class="reference internal image-reference" href="_images/image_proc_native_support_lib_name.png"><img alt="_images/image_proc_native_support_lib_name.png" src="_images/image_proc_native_support_lib_name.png" style="width: 551.0px; height: 457.0px;" /></a>
<p>Build the project (right-click <em>ImageProcessingNeonMT &gt; Build Project</em>) and run it on
device (right-click <em>ImageProcessingNeonMT &gt; Run As &gt; Android Application</em>). Every time
we run the activity, the code reads two bitmap images from <tt class="docutils literal"><span class="pre">assets</span></tt> directory
(<tt class="docutils literal"><span class="pre">checker_board.bmp</span></tt> and <tt class="docutils literal"><span class="pre">nvidia_logo.bmp</span></tt>), measures the execution speed of multiple
image processing methods, prints out aggregated timing values to the Android log, and
writes the output images to the SD card.  Check out the log messages in LogCat by typing
<em>tag:tutorial</em> in the log search line. Running the unmodified project file should print out:</p>
<div class="highlight-python"><pre>D/tutorial( 5684): 1/10
D/tutorial( 5684): 2/10
D/tutorial( 5684): 3/10
D/tutorial( 5684): 4/10
D/tutorial( 5684): 5/10
D/tutorial( 5684): 6/10
D/tutorial( 5684): 7/10
D/tutorial( 5684): 8/10
D/tutorial( 5684): 9/10
D/tutorial( 5684): 10/10
D/tutorial( 5684): AddImage8(): 0.000ms
D/tutorial( 5684): AddImage8AlignedNEON(): 0.000ms
D/tutorial( 5684): AddImage8UnalignedNEON(): 0.000ms
D/tutorial( 5684): AddImage8MT(): 0.000ms
D/tutorial( 5684): AddImage8NEON_MT(): 0.000ms
D/tutorial( 5684): VBlurImage8(): 0.000ms
D/tutorial( 5684): VBlurImage8AlignedNEON(): 0.000ms
D/tutorial( 5684): VBlurImage8MT(): 0.000ms
D/tutorial( 5684): VBlurImage8NEON_MT(): 0.000ms
D/tutorial( 5684): VBlurImage8NEON_MT_TILED(): 0.000ms</pre>
</div>
<p>At this stage the output files are black as the processing functions are empty stubs.</p>
<div class="admonition-implementation-note admonition">
<p class="first admonition-title">Implementation note</p>
<p>The test application is a simple function timing routine. The main timing loop in
<tt class="docutils literal"><span class="pre">SimpleNativeAndroid.cpp</span></tt> is defined as follows:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Timer</span> <span class="n">t</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">timings</span><span class="p">(</span> <span class="mi">10</span> <span class="p">);</span>
<span class="kt">int</span> <span class="k">const</span> <span class="n">measurementCount</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

<span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">measurementCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// we pass 4 times bigger width because each pixel has 4 color channel (argb)</span>
    <span class="n">t</span><span class="p">.</span><span class="n">tic</span><span class="p">();</span>
    <span class="n">AddImage8</span><span class="p">(</span> <span class="n">dest</span><span class="p">,</span> <span class="n">sourcePtr1</span><span class="p">,</span> <span class="n">sourcePtr2</span><span class="p">,</span> <span class="n">w</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">h</span> <span class="p">);</span>
    <span class="n">timings</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span> <span class="n">t</span><span class="p">.</span><span class="n">toc</span><span class="p">()</span> <span class="p">);</span>

    <span class="n">t</span><span class="p">.</span><span class="n">tic</span><span class="p">();</span>
    <span class="n">AddImage8AlignedNEON</span><span class="p">(</span> <span class="n">aDest</span><span class="p">,</span> <span class="n">alignedSourcePtr1</span><span class="p">,</span> <span class="n">alignedSourcePtr2</span><span class="p">,</span> <span class="n">wAligned</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">h</span> <span class="p">);</span>
    <span class="n">timings</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span> <span class="n">t</span><span class="p">.</span><span class="n">toc</span><span class="p">()</span> <span class="p">);</span>

    <span class="n">t</span><span class="p">.</span><span class="n">tic</span><span class="p">();</span>
    <span class="n">AddImage8UnalignedNEON</span><span class="p">(</span> <span class="n">dest</span><span class="p">,</span> <span class="n">sourcePtr1</span><span class="p">,</span> <span class="n">sourcePtr2</span><span class="p">,</span> <span class="n">w</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">h</span> <span class="p">);</span>
    <span class="n">timings</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span> <span class="n">t</span><span class="p">.</span><span class="n">toc</span><span class="p">()</span> <span class="p">);</span>

    <span class="n">t</span><span class="p">.</span><span class="n">tic</span><span class="p">();</span>
    <span class="n">AddImage8MT</span><span class="p">(</span> <span class="n">dest</span><span class="p">,</span> <span class="n">sourcePtr1</span><span class="p">,</span> <span class="n">sourcePtr2</span><span class="p">,</span> <span class="n">w</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">h</span> <span class="p">);</span>
    <span class="n">timings</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span> <span class="n">t</span><span class="p">.</span><span class="n">toc</span><span class="p">()</span> <span class="p">);</span>

    <span class="n">t</span><span class="p">.</span><span class="n">tic</span><span class="p">();</span>
    <span class="n">AddImage8NEON_MT</span><span class="p">(</span> <span class="n">dest</span><span class="p">,</span> <span class="n">sourcePtr1</span><span class="p">,</span> <span class="n">sourcePtr2</span><span class="p">,</span> <span class="n">w</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">h</span> <span class="p">);</span>
    <span class="n">timings</span><span class="p">[</span><span class="mi">4</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span> <span class="n">t</span><span class="p">.</span><span class="n">toc</span><span class="p">()</span> <span class="p">);</span>

    <span class="n">result</span><span class="p">.</span><span class="n">copyTo</span><span class="p">(</span> <span class="n">aimage1</span> <span class="p">);</span>

    <span class="n">t</span><span class="p">.</span><span class="n">tic</span><span class="p">();</span>
    <span class="n">VBlurImage8</span><span class="p">(</span> <span class="n">aDest</span><span class="p">,</span> <span class="n">alignedSourcePtr1</span><span class="p">,</span> <span class="n">wAligned</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">wAligned</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">h</span> <span class="p">);</span>
    <span class="n">timings</span><span class="p">[</span><span class="mi">5</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span> <span class="n">t</span><span class="p">.</span><span class="n">toc</span><span class="p">()</span> <span class="p">);</span>

    <span class="n">t</span><span class="p">.</span><span class="n">tic</span><span class="p">();</span>
    <span class="n">VBlurImage8AlignedNEON</span><span class="p">(</span> <span class="n">aDest</span><span class="p">,</span> <span class="n">alignedSourcePtr1</span><span class="p">,</span> <span class="n">wAligned</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">wAligned</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">h</span> <span class="p">);</span>
    <span class="n">timings</span><span class="p">[</span><span class="mi">6</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span> <span class="n">t</span><span class="p">.</span><span class="n">toc</span><span class="p">()</span> <span class="p">);</span>

    <span class="n">t</span><span class="p">.</span><span class="n">tic</span><span class="p">();</span>
    <span class="n">VBlurImage8MT</span><span class="p">(</span> <span class="n">aDest</span><span class="p">,</span> <span class="n">alignedSourcePtr1</span><span class="p">,</span> <span class="n">wAligned</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">h</span> <span class="p">);</span>
    <span class="n">timings</span><span class="p">[</span><span class="mi">7</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span> <span class="n">t</span><span class="p">.</span><span class="n">toc</span><span class="p">()</span> <span class="p">);</span>

    <span class="n">t</span><span class="p">.</span><span class="n">tic</span><span class="p">();</span>
    <span class="n">VBlurImage8NEON_MT</span><span class="p">(</span> <span class="n">aDest</span><span class="p">,</span> <span class="n">alignedSourcePtr1</span><span class="p">,</span> <span class="n">wAligned</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">h</span> <span class="p">);</span>
    <span class="n">timings</span><span class="p">[</span><span class="mi">8</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span> <span class="n">t</span><span class="p">.</span><span class="n">toc</span><span class="p">()</span> <span class="p">);</span>

    <span class="n">t</span><span class="p">.</span><span class="n">tic</span><span class="p">();</span>
    <span class="n">VBlurImage8NEON_MT_TILED</span><span class="p">(</span> <span class="n">aDest</span><span class="p">,</span> <span class="n">alignedSourcePtr1</span><span class="p">,</span> <span class="n">wAligned</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">h</span> <span class="p">);</span>
    <span class="n">timings</span><span class="p">[</span><span class="mi">9</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span> <span class="n">t</span><span class="p">.</span><span class="n">toc</span><span class="p">()</span> <span class="p">);</span>

    <span class="n">LOG</span><span class="p">(</span> <span class="s">&quot;%i/%i&quot;</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">measurementCount</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In order to improve the stability of timings (or reduce the impact of outliers to the estimated timing),
we repeat the measurement 10 times for each method and use median as the final timing estimator.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">procNames</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="s">&quot;AddImage8&quot;</span><span class="p">,</span> <span class="s">&quot;AddImage8AlignedNEON&quot;</span><span class="p">,</span> <span class="s">&quot;AddImage8UnalignedNEON&quot;</span><span class="p">,</span> <span class="s">&quot;AddImage8MT&quot;</span><span class="p">,</span> <span class="s">&quot;AddImage8NEON_MT&quot;</span><span class="p">,</span> <span class="s">&quot;VBlurImage8&quot;</span><span class="p">,</span>
    <span class="s">&quot;VBlurImage8AlignedNEON&quot;</span><span class="p">,</span> <span class="s">&quot;VBlurImage8MT&quot;</span><span class="p">,</span> <span class="s">&quot;VBlurImage8NEON_MT&quot;</span><span class="p">,</span> <span class="s">&quot;VBlurImage8NEON_MT_TILED&quot;</span>
<span class="p">};</span>

<span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">timings</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// display median of all measurements for each type of call</span>
    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span> <span class="n">timings</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">begin</span><span class="p">(),</span> <span class="n">timings</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">end</span><span class="p">()</span> <span class="p">);</span>
    <span class="n">LOG</span><span class="p">(</span> <span class="s">&quot;%s(): %.3fms&quot;</span><span class="p">,</span> <span class="n">procNames</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">timings</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">timings</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="last">As you check the Android log, you notice that all the timings are very close to 0.0ms.
That is because the bodies of these function are empty.
We&#8217;ll show you how to fill those out over the course of this tutorial, and run the
test application to compare the execution speeds of different code versions.</p>
</div>
</div>
<div class="section" id="example-1-adding-images">
<h2>Example 1: Adding images<a class="headerlink" href="#example-1-adding-images" title="Permalink to this headline">¶</a></h2>
<p>In the first example we consider a simple operation of adding two images together while saturating
pixel sums at the maximum supported intensity. This is visualized in the figure below,
where the right image is a sum of left (NVIDIA logo) and middle (checker-board pattern) images.</p>
<a class="reference internal image-reference" href="_images/image_proc_add.png"><img alt="_images/image_proc_add.png" src="_images/image_proc_add.png" style="width: 1024.0px; height: 253.0px;" /></a>
<p>For the sake of simplicity let&#8217;s assume that each pixel is defined as an 8-bit intensity value,
in which case the image sum operation can be described with the following code:</p>
<ul>
<li><p class="first">Copy the function below to <tt class="docutils literal"><span class="pre">ExampleAddImageNEON.h</span></tt></p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">AddImage8</span><span class="p">(</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="o">*</span><span class="n">src1</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="o">*</span><span class="n">src2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// iterate over rows</span>
    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// iterate over pixels in a row</span>
        <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// sum pixel values</span>
            <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">src1</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">+</span> <span class="n">src2</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
            <span class="c1">// clamp the sum if it is larger than 8-bit integer can represent</span>
            <span class="n">dst</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="mi">255</span> <span class="o">?</span> <span class="mi">255</span> <span class="o">:</span> <span class="n">t</span><span class="p">;</span>
            <span class="c1">//  move over to the next pixel</span>
            <span class="n">index</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
<p>The above code can also be used for true color images, for which pixels contain multiple 8-bit color channels.
In such a case, we simply assume the width of the input image corresponds to the width of the true color
image multiplied by the number of color channels. For example, if the original width of 32-bit ARGB image is
1024, use 4096 instead.</p>
<div class="section" id="vectorizing-the-computation-with-neon-intrinsics">
<h3>Vectorizing the computation with NEON intrinsics<a class="headerlink" href="#vectorizing-the-computation-with-neon-intrinsics" title="Permalink to this headline">¶</a></h3>
<p>NVIDIA Tegra 3 CPU contains four ARM Cortex-A9 cores.
Each of these cores is equipped with a NEON SIMD
(<em>Single Instruction, Multiple Data</em>) co-processor that allows exploiting data level parallelism
in your algorithm.
To demonstrate how SIMD works, let&#8217;s consider a simple example of adding together two sets of numbers:</p>
<div class="highlight-python"><pre>a0 := b0 + c0;
a1 := b1 + c1;
a2 := b2 + c2;
a3 := b3 + c3;</pre>
</div>
<p>For SIMD approach, all <cite>a</cite>, <cite>b</cite> and <cite>c</cite> elements would be stored in corresponding vector words,
and the above code would map to a single instruction that operates on those vectors, i.e., <tt class="docutils literal"><span class="pre">a</span> <span class="pre">:=</span> <span class="pre">b</span> <span class="pre">+</span> <span class="pre">c</span></tt>.</p>
<p>There are two ways of programming the NEON unit.
The first one involves writing your routines as inline assembly
(see this <a class="reference external" href="http://www.ethernut.de/en/documents/arm-inline-asm.html">tutorial</a> for details).
It requires lots of manual labor, but also provides fine-grained control
over the generated machine code.
Another way, which we follow in this tutorial, is to use NEON intrinsics &#8211;
C-style functions that operate on vector data types.
Each intrinsic function has specific input and output type requirements and
maps directly to a single machine instruction.
An important feature of NEON intrinsics is the ability to map NEON vector
registers to regular C variables.
Combined with strong typing of vector data types, intrinsics make the programming safer
and less prone to bugs.
Because the programmer is relieved from manual register allocation and instruction scheduling,
the source code is also easier to read and modify.
The NEON vector registers are 128-bits long, and can be interpreted
as many primitive data types. The most important ones are listed below:</p>
<div class="highlight-python"><pre>int8x8_t    int8x16_t
int16x4_t   int16x8_t
int32x2_t   int32x4_t
int64x1_t   int64x2_t
uint8x8_t   uint8x16_t
uint16x4_t  uint16x8_t
uint32x2_t  uint32x4_t
uint64x1_t  uint64x2_t
float16x4_t float16x8_t
float32x2_t float32x4_t</pre>
</div>
<p>Each of these types reads as <cite>&lt;element_type&gt;&lt;element_size&gt;x&lt;element_count&gt;_t</cite>, where
<cite>element_type</cite> corresponds to the basic type (<cite>int</cite>, <cite>uint</cite>, <cite>float</cite>) of each element in a vector,
<cite>element_size</cite> denotes the size in bits of each element (8, 16, 32, 64-bits) and <cite>element_count</cite>
tells us how many elements fit in a vector. For instance, <tt class="docutils literal"><span class="pre">uint8x16_t</span></tt> type holds sixteen
8-bit unsigned integers.</p>
<p>The NEON unit has an extensive instruction set that has been optimized for many
multi-media related tasks. The functionality includes:</p>
<ul class="simple">
<li>Addition</li>
<li>Multiplication</li>
<li>Subtraction</li>
<li>Comparison</li>
<li>Absolute difference</li>
<li>Max/Min</li>
<li>Pairwise addition</li>
<li>Folding maximum</li>
<li>Folding minimum</li>
<li>Shifts by signed variable</li>
<li>Shifts by a constant</li>
<li>Shifts with insert</li>
<li>Loads of a single vector or lane</li>
<li>Store a single vector or lane</li>
<li>Loads of an N-element structure</li>
<li>Extract lanes from a vector and put into a register</li>
<li>Load a single lane of a vector from a literal</li>
<li>Initialize a vector from a literal bit pattern</li>
<li>Set all lanes to same value</li>
<li>Combining vectors</li>
<li>Splitting vectors</li>
<li>Converting vectors</li>
<li>Table look up</li>
<li>Operations with a scalar value</li>
<li>Vector extract</li>
<li>Reverse vector elements (swap endianness)</li>
<li>Abs, neg, bit counting</li>
<li>Reciprocal &amp; square root (with Newton-Raphson refinement)</li>
<li>Logical operations</li>
<li>Transposition operations</li>
</ul>
<p>See ARM Architecture Manual Reference and ARM web-site for a
detailed description of the instruction set. You can also look into <tt class="docutils literal"><span class="pre">arm_neon.h</span></tt>
header, where intrinsic prototypes and vector data types are defined.</p>
<p>The <tt class="docutils literal"><span class="pre">AddImage8()</span></tt> function can be efficiently vectorized by assuming
that a pack of 4 pixels (16 color channels or 16 unsigned 8-bit integers) maps
to a single vector word. The code performing the addition with saturation
of two images containing 16-bytes vectors data can be defined as:</p>
<ul>
<li><p class="first">Copy the function below to <tt class="docutils literal"><span class="pre">ExampleAddImageNEON.h</span></tt></p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">AddImage8AlignedNEON</span><span class="p">(</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="o">*</span><span class="n">src1</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="o">*</span><span class="n">src2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// compute the number of vector words that fit in each row</span>
    <span class="kt">int</span> <span class="k">const</span> <span class="n">vectorNumberPerRow</span> <span class="o">=</span> <span class="n">width</span> <span class="o">/</span> <span class="mi">16</span><span class="p">;</span>
    <span class="c1">// iterate over rows</span>
    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// iterate over *vectors* of pixels in a row</span>
        <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vectorNumberPerRow</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// load 16 pixels to vector a</span>
            <span class="kt">uint8x16_t</span> <span class="n">a</span> <span class="o">=</span> <span class="n">vld1q_u8</span><span class="p">(</span> <span class="n">src1</span> <span class="p">);</span>
            <span class="c1">// load 16 pixels to vector b</span>
            <span class="kt">uint8x16_t</span> <span class="n">b</span> <span class="o">=</span> <span class="n">vld1q_u8</span><span class="p">(</span> <span class="n">src2</span> <span class="p">);</span>
            <span class="c1">// perform 8-bit element-wise addition with saturation of vector data</span>
            <span class="kt">uint8x16_t</span> <span class="n">r</span> <span class="o">=</span> <span class="n">vqaddq_u8</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
            <span class="c1">// store the resulting vector in the destination image</span>
            <span class="n">vst1q_u8</span><span class="p">(</span> <span class="n">dst</span><span class="p">,</span> <span class="n">r</span> <span class="p">);</span>

            <span class="c1">// shift the source and destination pointers by 16 pixels we have just processed</span>
            <span class="n">src1</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">;</span>
            <span class="n">src2</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">;</span>
            <span class="n">dst</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
<p>Try compiling and running the application, and take a look at the log.  You can see that the NEON version
runs much faster than the basic version.  You can also check that the output images look right; check the
path from the log, and use command such as:</p>
<div class="highlight-python"><pre>adb pull /storage/sdcard0/Android/data/com.nvidia.tutorial.imageproc/files/result0.bmp</pre>
</div>
<p><tt class="docutils literal"><span class="pre">result0.bmp</span></tt> contains the output of the basic version, and <tt class="docutils literal"><span class="pre">result1.bmp</span></tt> the output from the NEON
version.  Some of the functions that we add next will overwrite the same files with their outputs.</p>
<p>It is important to note that ARM NEON unit assumes the pointers to source and destination data
(<tt class="docutils literal"><span class="pre">src1</span></tt>, <tt class="docutils literal"><span class="pre">src2</span></tt>, <tt class="docutils literal"><span class="pre">dst</span></tt>) are 16-bytes aligned. Reading from or writing to unaligned memory location
will result in a fatal exception and application termination. In theory, ARM CPUs support unaligned memory
accesses, however, such accesses are slower than their aligned counterparts. To get maximum performance
benefits from SIMD approach, your image processing code should always use aligned memory accesses.</p>
<p>The above code assumes that image data is always aligned, i.e., each row starts at a location aligned
to a 16-byte boundary. As the offset of the top-left pixel (zero) is always aligned to a vector boundary,
this constraint means that the image width must be a multiple of 16 for the code work.
In order to address this limitation and support all kinds of image sizes, we need to have two row
processing functions: a vectorized version that has both input and output addresses aligned,
and a scalar version that can be called for elements at arbitrary memory locations.</p>
<p>Knowing which function to call for which elements requires keeping track of current pixel offset alignment,
which is often a difficult task. To simplify the accounting, let&#8217;s introduce a template method
<tt class="docutils literal"><span class="pre">template&lt;typename</span> <span class="pre">T&gt;</span> <span class="pre">void</span> <span class="pre">RunVectorizedLoop&lt;T&gt;()</span></tt>. This method calls two member methods <tt class="docutils literal"><span class="pre">T::runScalarLoop()</span></tt>
and <tt class="docutils literal"><span class="pre">T::runVectorLoop()</span></tt> to process vector and scalar elements, respectively.</p>
<div class="admonition-implementation-note admonition">
<p class="first admonition-title">Implementation note</p>
<p><tt class="docutils literal"><span class="pre">RunVectorizedLoop()</span></tt> is a helper function (in <tt class="docutils literal"><span class="pre">Common.h</span></tt>) that executes image processing method from template
parameter class over a specified range of elements, automatically accounting for unaligned memory
accesses and lengths which are not multiples of vector size. The method is designed to work only for
single index loops, i.e., both source and destination images use the same index to address their
elements.</p>
<div class="last highlight-c++"><div class="highlight"><pre><span class="c1">// return an integer with last n bits as 1, other bits are 0</span>
<span class="n">FORCE_INLINE</span> <span class="kt">int</span> <span class="nf">LastBits</span><span class="p">(</span> <span class="kt">int</span> <span class="n">n</span> <span class="p">)</span>            <span class="p">{</span> <span class="k">return</span> <span class="p">(</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
<span class="c1">// find the largest number aligned to b bits that is at most as large as n</span>
<span class="n">FORCE_INLINE</span> <span class="kt">int</span> <span class="nf">AlignEnd</span><span class="p">(</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span> <span class="p">)</span>     <span class="p">{</span> <span class="k">return</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">LastBits</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span> <span class="p">}</span>
<span class="c1">// find how much to add to n to get to next number aligned to b bits</span>
<span class="n">FORCE_INLINE</span> <span class="kt">int</span> <span class="nf">AlignStart</span><span class="p">(</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span> <span class="p">)</span>   <span class="p">{</span> <span class="k">return</span> <span class="p">(</span> <span class="p">(</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="p">)</span> <span class="o">-</span> <span class="n">n</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="n">LastBits</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span> <span class="p">}</span>
<span class="cm">/*</span>
<span class="cm"> * a helper function that executes operator class over the specified range of elements</span>
<span class="cm"> * and automatically takes care of unaligned memory and length values which are not</span>
<span class="cm"> * multiple of vector size</span>
<span class="cm"> */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="n">FORCE_INLINE</span> <span class="kt">void</span> <span class="n">RunVectorizedLoop</span><span class="p">(</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">processor</span><span class="p">,</span> <span class="kt">int</span> <span class="n">loopStart</span><span class="p">,</span> <span class="kt">int</span> <span class="n">loopEnd</span><span class="p">,</span>
                                                       <span class="kt">int</span> <span class="n">baseOffset</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// start address alignment fix</span>
    <span class="kt">int</span> <span class="n">start0</span> <span class="o">=</span> <span class="n">loopStart</span> <span class="o">+</span> <span class="n">AlignStart</span><span class="p">(</span> <span class="n">baseOffset</span> <span class="o">+</span> <span class="n">loopStart</span><span class="p">,</span> <span class="n">T</span><span class="o">::</span><span class="n">VECTOR_LOG2_LENGTH</span> <span class="p">);</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">start0</span> <span class="o">&gt;</span> <span class="n">loopEnd</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">start0</span> <span class="o">=</span> <span class="n">loopEnd</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// run scalar computation for unaligned elements</span>
<span class="hll">    <span class="n">processor</span><span class="p">.</span><span class="n">runScalarLoop</span><span class="p">(</span> <span class="n">loopStart</span><span class="p">,</span> <span class="n">start0</span><span class="p">,</span> <span class="n">baseOffset</span> <span class="p">);</span>
</span>    <span class="c1">// vector count fix</span>
    <span class="kt">int</span> <span class="n">end0</span> <span class="o">=</span> <span class="n">start0</span> <span class="o">+</span> <span class="n">AlignEnd</span><span class="p">(</span> <span class="n">loopEnd</span> <span class="o">-</span> <span class="n">start0</span><span class="p">,</span> <span class="n">T</span><span class="o">::</span><span class="n">VECTOR_LOG2_LENGTH</span> <span class="p">);</span>
    <span class="c1">// run vector computation for aligned elements</span>
<span class="hll">    <span class="n">processor</span><span class="p">.</span><span class="n">runVectorLoop</span><span class="p">(</span> <span class="n">start0</span><span class="p">,</span> <span class="n">end0</span><span class="p">,</span> <span class="n">baseOffset</span> <span class="p">);</span>
</span>    <span class="c1">// run scalar computation for the remainder of elements</span>
<span class="hll">    <span class="n">processor</span><span class="p">.</span><span class="n">runScalarLoop</span><span class="p">(</span> <span class="n">end0</span><span class="p">,</span> <span class="n">loopEnd</span><span class="p">,</span> <span class="n">baseOffset</span> <span class="p">);</span>
</span><span class="p">}</span>
</pre></div>
</div>
</div>
<p>With this helper template, we can modify the previous code to add support for arbitrary image sizes:</p>
<ul>
<li><p class="first">Copy the function below to <tt class="docutils literal"><span class="pre">ExampleAddImageNEON.h</span></tt></p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">AddImage8UnalignedNEON</span><span class="p">(</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="o">*</span><span class="n">src1</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="o">*</span><span class="n">src2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// instantiate a row processing class with source and destination pointers</span>
    <span class="n">AddImage8Processor</span> <span class="n">processor</span><span class="p">(</span> <span class="n">dst</span><span class="p">,</span> <span class="n">src1</span><span class="p">,</span> <span class="n">src2</span> <span class="p">);</span>

    <span class="c1">// index of the 1st pixel in current row</span>
    <span class="kt">int</span> <span class="n">baseOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// iterate over rows</span>
    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// invoke a method that uses scalar and vector processing functions</span>
        <span class="c1">// of the row processor class to compute pixel values in the current row</span>
        <span class="n">RunVectorizedLoop</span><span class="p">(</span> <span class="n">processor</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">baseOffset</span> <span class="p">);</span>
        <span class="c1">// shift the offset to the next row</span>
        <span class="n">baseOffset</span> <span class="o">+=</span> <span class="n">width</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
<p>The instance of <tt class="docutils literal"><span class="pre">AddImage8Processor</span></tt> class stores pointers to source and destination images and
comprises two loop processing functions called by <tt class="docutils literal"><span class="pre">RunVectorizedLoop()</span></tt>:</p>
<ul>
<li><p class="first">Copy the function below to <tt class="docutils literal"><span class="pre">ExampleAddImageNEON.h</span></tt> (<tt class="docutils literal"><span class="pre">above</span> <span class="pre">AddImage8UnalignedNEON()</span></tt> function)</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">AddImage8Processor</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// base 2 logarithm of the numbers of elements (pixels) in a vector</span>
    <span class="c1">// trait needed by RunVectorizedLoop() template function</span>
    <span class="k">enum</span>
    <span class="p">{</span>
        <span class="n">VECTOR_LOG2_LENGTH</span> <span class="o">=</span> <span class="mi">4</span> <span class="c1">// 16 pixels in a vector</span>
    <span class="p">};</span>

    <span class="c1">// initialize source and destination pointers</span>
    <span class="n">AddImage8Processor</span><span class="p">(</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="o">*</span><span class="n">src1</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="o">*</span><span class="n">src2</span> <span class="p">)</span>
            <span class="o">:</span> <span class="n">mDst</span><span class="p">(</span> <span class="n">dst</span> <span class="p">),</span> <span class="n">mSrc1</span><span class="p">(</span> <span class="n">src1</span> <span class="p">),</span> <span class="n">mSrc2</span><span class="p">(</span> <span class="n">src2</span> <span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="c1">// scalar loop processor -&gt; start and end indices can have arbitrary values</span>
<span class="hll">    <span class="n">FORCE_INLINE</span> <span class="kt">void</span> <span class="n">runScalarLoop</span><span class="p">(</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int</span> <span class="n">baseOffset</span> <span class="p">)</span> <span class="k">const</span>
</span>    <span class="p">{</span>
        <span class="c1">// compute local source/dest pointers</span>
        <span class="kt">uint8_t</span> <span class="k">const</span> <span class="o">*</span><span class="n">src1</span> <span class="o">=</span> <span class="n">mSrc1</span> <span class="o">+</span> <span class="n">baseOffset</span><span class="p">;</span>
        <span class="kt">uint8_t</span> <span class="k">const</span> <span class="o">*</span><span class="n">src2</span> <span class="o">=</span> <span class="n">mSrc2</span> <span class="o">+</span> <span class="n">baseOffset</span><span class="p">;</span>
        <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="n">mDst</span> <span class="o">+</span> <span class="n">baseOffset</span><span class="p">;</span>

        <span class="c1">// iterate over columns of pixels</span>
        <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// sum pixel values</span>
            <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">src1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">src2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="c1">// clamp the sum if it is larger than 8-bit integer can represent</span>
            <span class="n">dst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="mi">255</span> <span class="o">?</span> <span class="mi">255</span> <span class="o">:</span> <span class="n">t</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// vector loop processor -&gt; (start + baseOffset) and (end + baseOffset) indices</span>
    <span class="c1">// must be a multiple of 2^VECTOR_LOG2_LENGTH (2^4=16 in this case)</span>
<span class="hll">    <span class="n">FORCE_INLINE</span> <span class="kt">void</span> <span class="n">runVectorLoop</span><span class="p">(</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int</span> <span class="n">baseOffset</span> <span class="p">)</span> <span class="k">const</span>
</span>    <span class="p">{</span>
        <span class="c1">// shift the range by base offset</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="n">baseOffset</span><span class="p">;</span>
        <span class="n">end</span> <span class="o">+=</span> <span class="n">baseOffset</span><span class="p">;</span>

        <span class="c1">// compute local source/dest pointers</span>
        <span class="kt">uint8_t</span> <span class="k">const</span> <span class="o">*</span><span class="n">src1</span> <span class="o">=</span> <span class="n">mSrc1</span> <span class="o">+</span> <span class="n">start</span><span class="p">;</span>
        <span class="kt">uint8_t</span> <span class="k">const</span> <span class="o">*</span><span class="n">src2</span> <span class="o">=</span> <span class="n">mSrc2</span> <span class="o">+</span> <span class="n">start</span><span class="p">;</span>
        <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="n">mDst</span> <span class="o">+</span> <span class="n">start</span><span class="p">;</span>

        <span class="c1">// convert element count to vector count</span>
        <span class="c1">// note: (end - start) is always a multiple of 16</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="p">(</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="p">)</span> <span class="o">/</span> <span class="mi">16</span><span class="p">;</span>

        <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// load 16 pixels to vector a</span>
            <span class="kt">uint8x16_t</span> <span class="n">a</span> <span class="o">=</span> <span class="n">vld1q_u8</span><span class="p">(</span> <span class="n">src1</span> <span class="p">);</span>
            <span class="c1">// load 16 pixels to vector b</span>
            <span class="kt">uint8x16_t</span> <span class="n">b</span> <span class="o">=</span> <span class="n">vld1q_u8</span><span class="p">(</span> <span class="n">src2</span> <span class="p">);</span>
            <span class="c1">// perform 8-bit element wise addition with saturation of vectors</span>
            <span class="kt">uint8x16_t</span> <span class="n">r</span> <span class="o">=</span> <span class="n">vqaddq_u8</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">);</span>
            <span class="c1">// store the resulting vector in the destination image</span>
            <span class="n">vst1q_u8</span><span class="p">(</span> <span class="n">dst</span><span class="p">,</span> <span class="n">r</span> <span class="p">);</span>

            <span class="c1">// shift the source and destination pointers by 16 pixels we have just processed</span>
            <span class="n">src1</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">;</span>
            <span class="n">src2</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">;</span>
            <span class="n">dst</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="c1">// pointer to destination image data</span>
    <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">mDst</span><span class="p">;</span>
    <span class="c1">// pointer to 1st source image data</span>
    <span class="kt">uint8_t</span> <span class="k">const</span> <span class="o">*</span><span class="n">mSrc1</span><span class="p">;</span>
    <span class="c1">// pointer to 2nd source image data</span>
    <span class="kt">uint8_t</span> <span class="k">const</span> <span class="o">*</span><span class="n">mSrc2</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="adding-multi-threading">
<h3>Adding multi-threading<a class="headerlink" href="#adding-multi-threading" title="Permalink to this headline">¶</a></h3>
<p>To improve the execution speed even further we can divide the work on a single
output image across multiple CPU cores.
The idea is to have each CPU core run its own worker thread that will
call image processing routine on a subset of image rows.
For example, for two threads, we can split the image into two equal parts,
assign top part to the first thread, bottom part to the second thread, and
process them independently.
We use the <a class="reference external" href="https://computing.llnl.gov/tutorials/pthreads/">POSIX Threads API</a>
for thread creation and management.</p>
<p>First, let&#8217;s define a structure holding the data shared between threads, such
as pointers to source/destination images and their dimensions:</p>
<ul>
<li><p class="first">Copy the code below to <tt class="docutils literal"><span class="pre">ExampleAddImageMT.h</span></tt></p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
    <span class="c1">// image width and height</span>
    <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">;</span>
    <span class="c1">// pointer to destination image data</span>
    <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">;</span>
    <span class="c1">// pointer to 1st source image data</span>
    <span class="kt">uint8_t</span> <span class="k">const</span> <span class="o">*</span><span class="n">src1</span><span class="p">;</span>
    <span class="c1">// pointer to 2nd source image data</span>
    <span class="kt">uint8_t</span> <span class="k">const</span> <span class="o">*</span><span class="n">src2</span><span class="p">;</span>
<span class="p">}</span> <span class="n">AddImage8Data</span><span class="p">;</span>
</pre></div>
</div>
</li>
</ul>
<p>After filling in the structure, we pass it to <tt class="docutils literal"><span class="pre">RunThreads()</span></tt> function that configures
and launches thread processing for a specific image processing function.
This is shown in the code below:</p>
<ul>
<li><p class="first">Copy the code below to <tt class="docutils literal"><span class="pre">ExampleAddImageMT.h</span></tt></p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">AddImage8MT</span><span class="p">(</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="o">*</span><span class="n">src1</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="o">*</span><span class="n">src2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">AddImage8Data</span> <span class="n">params</span><span class="p">;</span>

    <span class="c1">// set up shared thread data (pointers to source and destination images and their size)</span>
    <span class="n">params</span><span class="p">.</span><span class="n">src1</span>   <span class="o">=</span> <span class="n">src1</span><span class="p">;</span>
    <span class="n">params</span><span class="p">.</span><span class="n">src2</span>   <span class="o">=</span> <span class="n">src2</span><span class="p">;</span>
    <span class="n">params</span><span class="p">.</span><span class="n">dst</span>    <span class="o">=</span> <span class="n">dst</span><span class="p">;</span>
    <span class="n">params</span><span class="p">.</span><span class="n">width</span>  <span class="o">=</span> <span class="n">width</span><span class="p">;</span>
    <span class="n">params</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">height</span><span class="p">;</span>

    <span class="c1">// execute AddImage8ThreadProc() in parallel</span>
    <span class="c1">// the thread count is set to zero (auto-detect) and the granularity</span>
    <span class="c1">// of task is set to the number of image rows</span>
    <span class="n">RunThreads</span><span class="p">(</span> <span class="n">AddImage8ThreadProc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">params</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
<p>The last line of the above code runs <tt class="docutils literal"><span class="pre">AddImage8ThreadProc()</span></tt> function on a number of
threads, and returns when they finish. The last argument of <tt class="docutils literal"><span class="pre">RunThreads()</span></tt> is the
number of threads, 0 asks for the default number, which we have defined to be 2 in <tt class="docutils literal"><span class="pre">Common.cpp</span></tt>.
We refer to <tt class="docutils literal"><span class="pre">AddImage8ThreadProc()</span></tt> as the <em>thread body</em>:</p>
<ul>
<li><p class="first">Copy the code below to <tt class="docutils literal"><span class="pre">ExampleAddImageMT.h</span></tt> (above <tt class="docutils literal"><span class="pre">AddImage8MT()</span></tt> function)</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">AddImage8ThreadProc</span><span class="p">(</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">ThreadData</span><span class="o">&lt;</span><span class="n">AddImage8Data</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">*</span><span class="n">tdata</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">ThreadData</span><span class="o">&lt;</span><span class="n">AddImage8Data</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">*&gt;</span><span class="p">(</span> <span class="n">ptr</span> <span class="p">);</span>
    <span class="n">AddImage8Data</span> <span class="k">const</span> <span class="o">*</span><span class="n">params</span> <span class="o">=</span> <span class="n">tdata</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">;</span>

    <span class="c1">// compute start offset (tdata-&gt;taskStartIndex corresponds to image row number)</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">tdata</span><span class="o">-&gt;</span><span class="n">taskStartIndex</span> <span class="o">*</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">;</span>

    <span class="c1">// invoke image processing on the image area assigned to the current thread</span>
    <span class="n">AddImage8</span><span class="p">(</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">dst</span> <span class="o">+</span> <span class="n">index</span><span class="p">,</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">src1</span> <span class="o">+</span> <span class="n">index</span><span class="p">,</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">src2</span> <span class="o">+</span> <span class="n">index</span><span class="p">,</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span>
               <span class="n">tdata</span><span class="o">-&gt;</span><span class="n">taskEndIndex</span> <span class="o">-</span> <span class="n">tdata</span><span class="o">-&gt;</span><span class="n">taskStartIndex</span> <span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
<p>The argument that the thread body receives is a pointer to <tt class="docutils literal"><span class="pre">ThreadData</span></tt> that is filled in the
<tt class="docutils literal"><span class="pre">RunThreads()</span></tt> utility (see the implementation note below) in <tt class="docutils literal"><span class="pre">Common.cpp</span></tt>.
From that we know which part of the image should be processed by calling <tt class="docutils literal"><span class="pre">AddImage8()</span></tt>.</p>
<p>Note that the amount of code required to support multi-threading is relatively small.
The thread body function internally executes the standard single-threaded version of
the image adding function (<tt class="docutils literal"><span class="pre">AddImage8()</span></tt>). The only difference is that each thread
works only on a fragment of the output image.  Run the program and verify the running
times, you see that using 2 threads almost halves the running time compared to the
single-thread version. You can&#8217;t directly control where the threads will execute, but
if you start several threads with substantial workloads, they will be most likely
assigned to separate CPU cores (Tegra 3 has 4 fast CPU cores). However, power
saving policies may choose to make fewer than all four CPU cores available to your program.
Try varying the number of threads between 2 and 5 and see how that affects the execution time.</p>
<div class="admonition-implementation-note admonition">
<p class="first admonition-title">Implementation note</p>
<p><tt class="docutils literal"><span class="pre">RunThreads()</span></tt> function allows executing user-specified code in a number of threads
that may run simultaneously. Each thread will have a number of tasks assigned.
The concept of a task is abstract and does not correspond to any physical resource.
We use it to describe the granularity of work being distributed across threads.
The tasks are, by default, split equally between the threads, and their total number is
specified by the user.</p>
<p>In case of our image processing examples, the task count corresponds to the number of rows in the
image. Each thread will have a certain numbers of tasks (rows) assigned, and all together they will
process the entire image.</p>
<div class="last highlight-c++"><div class="highlight"><pre><span class="c1">// pointer to thread body</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">THREAD_PROC</span><span class="p">)(</span> <span class="kt">void</span> <span class="o">*</span> <span class="p">);</span>

<span class="c1">// per thread information structure</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">ThreadData</span>
<span class="p">{</span>
    <span class="c1">// the range of tasks to be executed by a given thread</span>
    <span class="kt">int</span> <span class="n">taskStartIndex</span><span class="p">,</span> <span class="n">taskEndIndex</span><span class="p">;</span>
    <span class="c1">// thread index</span>
    <span class="kt">int</span> <span class="n">threadIndex</span><span class="p">;</span>
    <span class="c1">// pointer to parameter structure passed in RunThreads() invocation</span>
    <span class="c1">// it is read-only and shared between all threads</span>
    <span class="n">T</span> <span class="k">const</span> <span class="o">*</span><span class="n">params</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">RunThreads</span><span class="p">(</span> <span class="n">THREAD_PROC</span> <span class="n">proc</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="kt">int</span> <span class="n">taskCount</span><span class="p">,</span> <span class="kt">int</span> <span class="n">threadNum</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">threadNum</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// if number of threads is less or equal zero, set it to default value</span>
        <span class="n">threadNum</span> <span class="o">=</span> <span class="n">DEFAULT_THREAD_COUNT</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// allocate space for per-thread data structure</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ThreadData</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="p">[]</span><span class="o">&gt;</span> <span class="n">tdata</span><span class="p">(</span> <span class="k">new</span> <span class="n">ThreadData</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">threadNum</span><span class="p">]</span> <span class="p">);</span>
    <span class="c1">// pthread thread ids array</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">pthread_t</span><span class="p">[]</span><span class="o">&gt;</span> <span class="n">tid</span><span class="p">(</span> <span class="k">new</span> <span class="kt">pthread_t</span><span class="p">[</span><span class="n">threadNum</span><span class="p">]</span> <span class="p">);</span>

    <span class="c1">// current thread task start index</span>
    <span class="kt">int</span> <span class="n">taskStartIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// the number of tasks per thread (rounded up)</span>
    <span class="kt">int</span> <span class="n">threadTaskRange</span> <span class="o">=</span> <span class="p">(</span> <span class="n">taskCount</span> <span class="o">+</span> <span class="n">threadNum</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">)</span> <span class="o">/</span> <span class="n">threadNum</span><span class="p">;</span>

    <span class="c1">// split the tasks across the threads</span>
    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">threadNum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// initialize data for each thread</span>
        <span class="n">tdata</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">threadIndex</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">tdata</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">taskStartIndex</span> <span class="o">=</span> <span class="n">taskStartIndex</span><span class="p">;</span>
        <span class="n">tdata</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">taskEndIndex</span> <span class="o">=</span> <span class="n">taskStartIndex</span> <span class="o">+</span> <span class="n">threadTaskRange</span><span class="p">;</span>
        <span class="n">tdata</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="p">;</span>

        <span class="c1">// last thread end range might go out of borders if height is not a multiple of threadNum</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">tdata</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">taskEndIndex</span> <span class="o">&gt;</span> <span class="n">taskCount</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">tdata</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">taskEndIndex</span> <span class="o">=</span> <span class="n">taskCount</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">taskStartIndex</span> <span class="o">+=</span> <span class="n">threadTaskRange</span><span class="p">;</span>

        <span class="c1">// spawn a thread</span>
<span class="hll">        <span class="n">pthread_create</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">tid</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span> <span class="cm">/* use default attributes */</span><span class="p">,</span> <span class="n">proc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tdata</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">);</span>
</span>    <span class="p">}</span>

    <span class="c1">// wait for each thread to complete its work</span>
    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">threadNum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
    <span class="p">{</span>
<span class="hll">        <span class="n">pthread_join</span><span class="p">(</span> <span class="n">tid</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span> <span class="cm">/* ignore exit status */</span> <span class="p">);</span>
</span>    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="combining-multi-threading-and-neon-code">
<h3>Combining multi-threading and NEON code<a class="headerlink" href="#combining-multi-threading-and-neon-code" title="Permalink to this headline">¶</a></h3>
<p>What if we would like to combine the benefits of vectorized code with multi-threaded execution?
It turns out that we can achieve this with minimal changes to the existing code.
First, let&#8217;s define a new version of the image adding function:</p>
<ul>
<li><p class="first">Copy the code below to <tt class="docutils literal"><span class="pre">ExampleAddImageMT.h</span></tt></p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">AddImage8NEON_MT</span><span class="p">(</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="o">*</span><span class="n">src1</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="o">*</span><span class="n">src2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">AddImage8Data</span> <span class="n">params</span><span class="p">;</span>

    <span class="c1">// set up shared thread data (pointers to source and destination images and their size)</span>
    <span class="n">params</span><span class="p">.</span><span class="n">src1</span>   <span class="o">=</span> <span class="n">src1</span><span class="p">;</span>
    <span class="n">params</span><span class="p">.</span><span class="n">src2</span>   <span class="o">=</span> <span class="n">src2</span><span class="p">;</span>
    <span class="n">params</span><span class="p">.</span><span class="n">dst</span>    <span class="o">=</span> <span class="n">dst</span><span class="p">;</span>
    <span class="n">params</span><span class="p">.</span><span class="n">width</span>  <span class="o">=</span> <span class="n">width</span><span class="p">;</span>
    <span class="n">params</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">height</span><span class="p">;</span>

    <span class="c1">// execute AddImage8ThreadProcNEON() in parallel</span>
    <span class="c1">// the thread count is set to zero (auto-detect) and the granularity</span>
    <span class="c1">// of task is set to the number of image rows</span>
    <span class="n">RunThreads</span><span class="p">(</span> <span class="n">AddImage8ThreadProcNEON</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">params</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
<p>Now, the only difference with respect to the previous code is that we pass a different
thread body function to <tt class="docutils literal"><span class="pre">RunThreads()</span></tt>:</p>
<ul>
<li><p class="first">Copy the code below to <tt class="docutils literal"><span class="pre">ExampleAddImageMT.h</span></tt> (above <tt class="docutils literal"><span class="pre">AddImage8NEON_MT()</span></tt> function)</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">AddImage8ThreadProcNEON</span><span class="p">(</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">ThreadData</span><span class="o">&lt;</span><span class="n">AddImage8Data</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">*</span><span class="n">tdata</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">ThreadData</span><span class="o">&lt;</span><span class="n">AddImage8Data</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">*&gt;</span><span class="p">(</span> <span class="n">ptr</span> <span class="p">);</span>
    <span class="n">AddImage8Data</span> <span class="k">const</span> <span class="o">*</span><span class="n">params</span> <span class="o">=</span> <span class="n">tdata</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">;</span>

    <span class="c1">// compute start offset (tdata-&gt;taskStartIndex corresponds to image row number)</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">tdata</span><span class="o">-&gt;</span><span class="n">taskStartIndex</span> <span class="o">*</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">;</span>

    <span class="c1">// invoke image processing on the image area assigned to the current thread</span>
    <span class="n">AddImage8UnalignedNEON</span><span class="p">(</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">dst</span> <span class="o">+</span> <span class="n">index</span><span class="p">,</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">src1</span> <span class="o">+</span> <span class="n">index</span><span class="p">,</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">src2</span> <span class="o">+</span> <span class="n">index</span><span class="p">,</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span>
                            <span class="n">tdata</span><span class="o">-&gt;</span><span class="n">taskEndIndex</span> <span class="o">-</span> <span class="n">tdata</span><span class="o">-&gt;</span><span class="n">taskStartIndex</span> <span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
<p>This function, similar to <tt class="docutils literal"><span class="pre">AddImage8ThreadProc()</span></tt>, calls a single-threaded image adding method to
process part of the image assigned to the current thread. In this case, however,
<tt class="docutils literal"><span class="pre">AddImage8UnalignedNEON()</span></tt> uses NEON extensions to accelerate processing across the columns.</p>
<div class="admonition-implementation-note admonition">
<p class="first admonition-title">Implementation note</p>
<p class="last">The code presented here creates and destroys multiple threads every time we call the image
processing function. This is a convinient approach, however, for very fast image processing functions
the overhead of thread management is often larger than the speedup gained through parallelization.
In such situations it is beneficial to manually manage threads with so called <em>thread pools</em>.
You can read more about design and implementation of thread pools
<a class="reference external" href="http://en.wikipedia.org/wiki/Thread_pool_pattern">here</a>.</p>
</div>
</div>
</div>
<div class="section" id="example-2-gaussian-blur">
<h2>Example 2: Gaussian blur<a class="headerlink" href="#example-2-gaussian-blur" title="Permalink to this headline">¶</a></h2>
<p>In this example we demonstrate how to parallelize convolution operation.
The following figure shows the effects of applying the operator (right)
to the result of previous example (left). For better visibility of blur,
we downsampled the input before filtering.</p>
<a class="reference internal image-reference" href="_images/image_proc_vblur.png"><img alt="_images/image_proc_vblur.png" src="_images/image_proc_vblur.png" style="width: 683.0px; height: 253.0px;" /></a>
<p>We start with a semi-optimized C++ version of a vertical blur function:</p>
<ul>
<li><p class="first">Copy the code below to <tt class="docutils literal"><span class="pre">ExampleVBlurImageNEON.h</span></tt></p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">VBlurImage8</span><span class="p">(</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="k">const</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="k">const</span> <span class="n">height</span><span class="p">,</span> <span class="kt">int</span> <span class="k">const</span> <span class="n">lineStride</span><span class="p">,</span>
                  <span class="kt">int</span> <span class="k">const</span> <span class="n">startY</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">endY</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// blur weights</span>
    <span class="kt">uint16_t</span> <span class="k">const</span> <span class="n">weights</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span> <span class="p">};</span>
    <span class="c1">// weight sum</span>
    <span class="kt">int</span> <span class="k">const</span> <span class="n">weightsSum</span> <span class="o">=</span> <span class="mi">13</span><span class="p">;</span>
    <span class="c1">// kernel size</span>
    <span class="kt">int</span> <span class="k">const</span> <span class="n">ksize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">weights</span> <span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">);</span>

    <span class="c1">// weight sum fractional precision</span>
    <span class="kt">int</span> <span class="k">const</span> <span class="n">weightsNormShift</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
    <span class="c1">// 1.0 represented as fixed point number</span>
    <span class="kt">float</span> <span class="k">const</span> <span class="n">weightsNorm</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="p">(</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">weightsNormShift</span> <span class="p">);</span>
    <span class="c1">// inverse of weight sum (fixed-point)</span>
    <span class="kt">float</span> <span class="k">const</span> <span class="n">iwsum</span> <span class="o">=</span> <span class="n">weightsNorm</span> <span class="o">/</span> <span class="n">weightsSum</span><span class="p">;</span>
    <span class="c1">// blur weights in fixed point precision</span>
    <span class="kt">uint16_t</span> <span class="k">const</span> <span class="n">iweights</span><span class="p">[]</span> <span class="o">=</span>
    <span class="p">{</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="p">(</span> <span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">iwsum</span> <span class="p">),</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="p">(</span> <span class="n">weights</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">iwsum</span> <span class="p">),</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="p">(</span> <span class="n">weights</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">iwsum</span> <span class="p">),</span>
      <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="p">(</span> <span class="n">weights</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">iwsum</span> <span class="p">),</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="p">(</span> <span class="n">weights</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">*</span> <span class="n">iwsum</span> <span class="p">)</span> <span class="p">};</span>

    <span class="c1">// shift source and destination pointers to the start row</span>
    <span class="n">dst</span> <span class="o">+=</span> <span class="n">startY</span> <span class="o">*</span> <span class="n">lineStride</span><span class="p">;</span>

    <span class="c1">// loop over a range of rows</span>
    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">startY</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">endY</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// we start integrating at current pixel y position minus half of the kernel size</span>
        <span class="kt">int</span> <span class="n">istart</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="p">(</span> <span class="n">ksize</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">);</span>
        <span class="c1">// we end integrating at current pixel y position plus half of the kernel size</span>
        <span class="kt">int</span> <span class="n">iend</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="p">(</span> <span class="n">ksize</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

        <span class="c1">// compute row start offset</span>
        <span class="kt">int</span> <span class="n">rowStartOffset</span> <span class="o">=</span> <span class="n">istart</span> <span class="o">*</span> <span class="n">lineStride</span><span class="p">;</span>

        <span class="k">if</span><span class="p">(</span> <span class="n">istart</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">iend</span> <span class="o">&lt;</span> <span class="n">height</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// integration happens completely inside of the image (no clipping)</span>

            <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span> <span class="p">)</span>
            <span class="p">{</span>
                <span class="c1">// current pixel offset</span>
                <span class="kt">int</span> <span class="n">currentOffset</span> <span class="o">=</span> <span class="n">rowStartOffset</span> <span class="o">+</span> <span class="n">x</span><span class="p">;</span>
                <span class="c1">// pixel accumulator</span>
                <span class="kt">int</span> <span class="n">accum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="c1">// accumulate weighted pixel values from neighboring rows</span>
                <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ksize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">accum</span> <span class="o">+=</span> <span class="n">iweights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">src</span><span class="p">[</span><span class="n">currentOffset</span><span class="p">];</span>
                    <span class="c1">// shift to the next row</span>
                    <span class="n">currentOffset</span> <span class="o">+=</span> <span class="n">lineStride</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="c1">// write out the accumulator divided by the sum of weights</span>
                <span class="n">dst</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">accum</span> <span class="o">&gt;&gt;</span> <span class="n">weightsNormShift</span> <span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="c1">// integration goes outside the image (clip)</span>
            <span class="kt">int</span> <span class="n">woffset</span> <span class="o">=</span> <span class="n">istart</span><span class="p">;</span>

            <span class="c1">// clip if we go outside of the image</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">istart</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span>    <span class="p">{</span>
               <span class="n">istart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
               <span class="n">rowStartOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">iend</span> <span class="o">&gt;</span> <span class="n">height</span> <span class="p">)</span> <span class="p">{</span> <span class="n">iend</span> <span class="o">=</span> <span class="n">height</span><span class="p">;</span> <span class="p">}</span>

            <span class="c1">// compute temporary *normalized* weights for this row</span>
            <span class="kt">uint16_t</span> <span class="n">tweights</span><span class="p">[</span><span class="n">ksize</span><span class="p">];</span>

            <span class="c1">// weights sum needed for normalization</span>
            <span class="kt">int</span> <span class="n">wsum</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">istart</span> <span class="o">-</span> <span class="n">woffset</span><span class="p">];</span>
            <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">istart</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iend</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
            <span class="p">{</span>
                <span class="n">wsum</span> <span class="o">+=</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">woffset</span><span class="p">];</span>
            <span class="p">}</span>

            <span class="c1">// normalize weights</span>
            <span class="kt">float</span> <span class="n">wnorm</span> <span class="o">=</span> <span class="n">weightsNorm</span> <span class="o">/</span> <span class="n">wsum</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">istart</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iend</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
            <span class="p">{</span>
                <span class="n">tweights</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">istart</span><span class="p">]</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">woffset</span><span class="p">]</span> <span class="o">*</span> <span class="n">wnorm</span> <span class="p">);</span>
            <span class="p">}</span>

            <span class="c1">// process pixels in a row</span>
            <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span> <span class="p">)</span>
            <span class="p">{</span>
                <span class="c1">// current pixel offset</span>
                <span class="kt">int</span> <span class="n">currentOffset</span> <span class="o">=</span> <span class="n">rowStartOffset</span> <span class="o">+</span> <span class="n">x</span><span class="p">;</span>
                <span class="c1">// pixel accumulator</span>
                <span class="kt">int</span> <span class="n">accum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="c1">// accumulate weighted pixel values from neighboring rows</span>
                <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">istart</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iend</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">accum</span> <span class="o">+=</span> <span class="n">tweights</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">istart</span><span class="p">]</span> <span class="o">*</span> <span class="n">src</span><span class="p">[</span><span class="n">currentOffset</span><span class="p">];</span>
                    <span class="c1">// shift to the next row</span>
                    <span class="n">currentOffset</span> <span class="o">+=</span> <span class="n">lineStride</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="c1">// write out the accumulator divided by the sum of weights</span>
                <span class="n">dst</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">accum</span> <span class="o">&gt;&gt;</span> <span class="n">weightsNormShift</span> <span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// shift to the next row of destination image</span>
        <span class="n">dst</span> <span class="o">+=</span> <span class="n">lineStride</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
<p>When vectorizing more complex image processing functions (such as the one shown above), we
recommend to transform your C++ code to a form that will be &#8220;almost&#8221; vectorized, i.e.,
selected lines of code can be directly replaced with NEON intrinsics. For example,
in the above function, we represent weights in 16-bit fixed-point arithmetic, so that
we can pack more pixel accumulators in a single NEON register. We simplify the
computations in the inner-most loop a lot (single multiply-add operation) so most
of the work is done by NEON unit.</p>
<div class="section" id="id1">
<h3>Vectorizing the computation with NEON intrinsics<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>Similar to the previous example, we can vectorize the code above simply by reinterpreting
the data in the image and processing pixels in packs of four.
For brevity and simplicity of this example, we limit the kernel to aligned data only
(image width must be a multiple of 16).</p>
<p>We first put all the NEON code into macros that we can use in both the clipped and unclipped
loop.  We fetch 16 bytes at a time.  We multiply them with weights using the same fixed-point
arithmetics as above: as the weights sum up to one, the weighted sum of 8-bit inputs will fit
into 16 bits.  We need to use two vectors that each can store 8 16-bit accumulators to calculate
the weighted sum.  We shift the results back right, dropping the decimal part, and pack the
lower-order 8-bit results into a single 16-wide vector, which we store to the destination image.</p>
<ul>
<li><p class="first">Copy the code below to <tt class="docutils literal"><span class="pre">ExampleVBlurImageNEON.h</span></tt></p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#define INIT_16BIT_ACCUMULATORS( a1, a2 ) \</span>
<span class="cp">    uint16x8_t a1 = vmovq_n_u16( 0 ); \</span>
<span class="cp">    uint16x8_t a2 = vmovq_n_u16( 0 )</span>

<span class="cp">#define ACCUMULATE_16_8BIT_WEIGHTED( data, a1, a2, weight ) \</span>
<span class="cp">    </span><span class="cm">/* load 16x8-bit uint pixels to a vector */</span><span class="cp"> \</span>
<span class="cp">    uint8x16_t p_u8 = vld1q_u8( data ); \</span>
<span class="cp">    </span><span class="cm">/* extract the first 8 and the last 8 to separate vectors */</span><span class="cp"> \</span>
<span class="cp">    uint8x8_t lp_u8 = vget_low_u8( p_u8 ); \</span>
<span class="cp">    uint8x8_t hp_u8 = vget_high_u8( p_u8 ); \</span>
<span class="cp">    </span><span class="cm">/* convert (expand) their format from 8x8-bit uint into 8x16-bit uint */</span><span class="cp"> \</span>
<span class="cp">    uint16x8_t lp_u16 = vmovl_u8( lp_u8 ); \</span>
<span class="cp">    uint16x8_t hp_u16 = vmovl_u8( hp_u8 ); \</span>
<span class="cp">    </span><span class="cm">/* multiply by scalar weight and add to accumulators */</span><span class="cp"> \</span>
<span class="cp">    a1 = vmlaq_n_u16( a1, lp_u16, weight ); \</span>
<span class="cp">    a2 = vmlaq_n_u16( a2, hp_u16, weight )</span>

<span class="cp">#define STORE_ACCUMULATORS_TO_16_8BIT( a1, a2, dst ) \</span>
<span class="cp">    </span><span class="cm">/* normalize the accumulators back to 8-bit range by shifting decimal point to right */</span><span class="cp"> \</span>
<span class="cp">    a1 = vshrq_n_u16( a1, weightsNormShift ); \</span>
<span class="cp">    a2 = vshrq_n_u16( a2, weightsNormShift ); \</span>
<span class="cp">    </span><span class="cm">/* convert accumulators format from 8x16-bit uint into 8x8-bit uint, high-order bits not needed */</span><span class="cp"> \</span>
<span class="cp">    uint8x8_t laccum_u8 = vmovn_u16( a1 ); \</span>
<span class="cp">    uint8x8_t haccum_u8 = vmovn_u16( a2 ); \</span>
<span class="cp">    </span><span class="cm">/* combine two 8x8-bit accumulators into one 16x8-bit accumulator */</span><span class="cp"> \</span>
<span class="cp">    uint8x16_t accum_u8 = vcombine_u8( laccum_u8, haccum_u8 ); \</span>
<span class="cp">    </span><span class="cm">/* store the resulting vector in the destination image */</span><span class="cp"> \</span>
<span class="cp">    vst1q_u8( dst, accum_u8 )</span>


<span class="n">NO_INLINE</span>
<span class="kt">void</span> <span class="nf">VBlurImage8AlignedNEON</span><span class="p">(</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="k">const</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="k">const</span> <span class="n">height</span><span class="p">,</span> <span class="kt">int</span> <span class="k">const</span> <span class="n">lineStride</span><span class="p">,</span>
                             <span class="kt">int</span> <span class="k">const</span> <span class="n">startY</span><span class="p">,</span> <span class="kt">int</span> <span class="k">const</span> <span class="n">endY</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// blur weights</span>
    <span class="kt">uint16_t</span> <span class="k">const</span> <span class="n">weights</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span> <span class="p">};</span>
    <span class="c1">// weight sum</span>
    <span class="kt">int</span> <span class="k">const</span> <span class="n">weightsSum</span> <span class="o">=</span> <span class="mi">13</span><span class="p">;</span>
    <span class="c1">// kernel size</span>
    <span class="kt">int</span> <span class="k">const</span> <span class="n">ksize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">weights</span> <span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">);</span>

    <span class="c1">// weight sum fractional precision</span>
    <span class="kt">int</span> <span class="k">const</span> <span class="n">weightsNormShift</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
    <span class="c1">// 1.0 represented as fixed point number</span>
    <span class="kt">float</span> <span class="k">const</span> <span class="n">weightsNorm</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="p">(</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">weightsNormShift</span> <span class="p">);</span>
    <span class="c1">// inverse of weight sum (fixed-point)</span>
    <span class="kt">float</span> <span class="k">const</span> <span class="n">iwsum</span> <span class="o">=</span> <span class="n">weightsNorm</span> <span class="o">/</span> <span class="n">weightsSum</span><span class="p">;</span>
    <span class="c1">// blur weights in fixed point precision</span>
    <span class="kt">uint16_t</span> <span class="k">const</span> <span class="n">iweights</span><span class="p">[]</span> <span class="o">=</span>
    <span class="p">{</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="p">(</span> <span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">iwsum</span> <span class="p">),</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="p">(</span> <span class="n">weights</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">iwsum</span> <span class="p">),</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="p">(</span> <span class="n">weights</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">iwsum</span> <span class="p">),</span>
      <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="p">(</span> <span class="n">weights</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">iwsum</span> <span class="p">),</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="p">(</span> <span class="n">weights</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">*</span> <span class="n">iwsum</span> <span class="p">)</span> <span class="p">};</span>

    <span class="c1">// compute the number of vector words that fit in each row</span>
    <span class="kt">int</span> <span class="k">const</span> <span class="n">vectorNumberPerRow</span> <span class="o">=</span> <span class="n">width</span> <span class="o">/</span> <span class="mi">16</span><span class="p">;</span>

    <span class="c1">// shift source and destination pointers to the start row</span>
    <span class="n">src</span> <span class="o">+=</span> <span class="n">startY</span> <span class="o">*</span> <span class="n">lineStride</span><span class="p">;</span>
    <span class="n">dst</span> <span class="o">+=</span> <span class="n">startY</span> <span class="o">*</span> <span class="n">lineStride</span><span class="p">;</span>

    <span class="c1">// loop over a range of rows</span>
    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">startY</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">endY</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// we start integrating at current pixel y position minus half of the kernel size</span>
        <span class="kt">int</span> <span class="n">istart</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="p">(</span> <span class="n">ksize</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">);</span>
        <span class="c1">// we end integrating at current pixel y position plus half of the kernel size</span>
        <span class="kt">int</span> <span class="n">iend</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="p">(</span> <span class="n">ksize</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">if</span><span class="p">(</span> <span class="n">istart</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">iend</span> <span class="o">&lt;</span> <span class="n">height</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// integration happens completely inside of the image (no clipping)</span>
            <span class="c1">// this is a major case executed for most of the image rows</span>

            <span class="kt">int</span> <span class="n">rowStartOffset</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span> <span class="n">ksize</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">)</span> <span class="o">*</span> <span class="n">lineStride</span><span class="p">;</span>

            <span class="c1">// iterate over all vectors in a row</span>
            <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">vectorNumberPerRow</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">,</span> <span class="n">src</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">,</span> <span class="n">dst</span> <span class="o">+=</span> <span class="mi">16</span> <span class="p">)</span>
            <span class="p">{</span>
                <span class="c1">// shift the source pointer to the top row</span>
                <span class="kt">uint8_t</span> <span class="k">const</span> <span class="o">*</span><span class="n">sourceData</span> <span class="o">=</span> <span class="n">src</span> <span class="o">+</span> <span class="n">rowStartOffset</span><span class="p">;</span>

                <span class="c1">// initialize two 8x16-bit accumulators so we can accumulate 16 pixels at a time</span>
                <span class="n">INIT_16BIT_ACCUMULATORS</span><span class="p">(</span> <span class="n">laccum_u16</span><span class="p">,</span> <span class="n">haccum_u16</span> <span class="p">);</span>

                <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ksize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">sourceData</span> <span class="o">+=</span> <span class="n">lineStride</span> <span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">ACCUMULATE_16_8BIT_WEIGHTED</span><span class="p">(</span> <span class="n">sourceData</span><span class="p">,</span> <span class="n">laccum_u16</span><span class="p">,</span> <span class="n">haccum_u16</span><span class="p">,</span> <span class="n">iweights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">);</span>
                <span class="p">}</span>

                <span class="n">STORE_ACCUMULATORS_TO_16_8BIT</span><span class="p">(</span> <span class="n">laccum_u16</span><span class="p">,</span> <span class="n">haccum_u16</span><span class="p">,</span> <span class="n">dst</span> <span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="c1">// integration goes outside the image (clip)</span>
            <span class="c1">// this is minor case executed for top and bottom-most rows in the image</span>

            <span class="kt">int</span> <span class="n">woffset</span> <span class="o">=</span> <span class="n">istart</span><span class="p">;</span>
            <span class="c1">// clip if we go outside of the image</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">istart</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span>    <span class="p">{</span> <span class="n">istart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">iend</span> <span class="o">&gt;</span> <span class="n">height</span> <span class="p">)</span> <span class="p">{</span> <span class="n">iend</span> <span class="o">=</span> <span class="n">height</span><span class="p">;</span> <span class="p">}</span>

            <span class="c1">// compute temporary *normalized* weights for this row</span>
            <span class="kt">uint16_t</span> <span class="n">tweights</span><span class="p">[</span><span class="n">ksize</span><span class="p">];</span>

            <span class="c1">// weights sum needed for normalization</span>
            <span class="kt">int</span> <span class="n">wsum</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">istart</span> <span class="o">-</span> <span class="n">woffset</span><span class="p">];</span>
            <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">istart</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iend</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
            <span class="p">{</span>
                <span class="n">wsum</span> <span class="o">+=</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">woffset</span><span class="p">];</span>
            <span class="p">}</span>

            <span class="kt">float</span> <span class="n">wnorm</span> <span class="o">=</span> <span class="n">weightsNorm</span> <span class="o">/</span> <span class="n">wsum</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">istart</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iend</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
            <span class="p">{</span>
                <span class="n">tweights</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">istart</span><span class="p">]</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">woffset</span><span class="p">]</span> <span class="o">*</span> <span class="n">wnorm</span> <span class="p">);</span>
            <span class="p">}</span>

            <span class="kt">int</span> <span class="n">rowStartOffset</span> <span class="o">=</span> <span class="p">(</span> <span class="n">istart</span> <span class="o">-</span> <span class="n">y</span> <span class="p">)</span> <span class="o">*</span> <span class="n">lineStride</span><span class="p">;</span>

            <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">vectorNumberPerRow</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">,</span> <span class="n">src</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">,</span> <span class="n">dst</span> <span class="o">+=</span> <span class="mi">16</span> <span class="p">)</span>
            <span class="p">{</span>
                <span class="kt">uint8_t</span> <span class="k">const</span> <span class="o">*</span><span class="n">sourceData</span> <span class="o">=</span> <span class="n">src</span> <span class="o">+</span> <span class="n">rowStartOffset</span><span class="p">;</span>

                <span class="c1">// initialize two 8x16-bit accumulators so we can accumulate 16 pixels at a time</span>
                <span class="n">INIT_16BIT_ACCUMULATORS</span><span class="p">(</span> <span class="n">laccum_u16</span><span class="p">,</span> <span class="n">haccum_u16</span> <span class="p">);</span>

                <span class="c1">// iterate over all vectors in a row</span>
                <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">istart</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iend</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">sourceData</span> <span class="o">+=</span> <span class="n">lineStride</span> <span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">ACCUMULATE_16_8BIT_WEIGHTED</span><span class="p">(</span> <span class="n">sourceData</span><span class="p">,</span> <span class="n">laccum_u16</span><span class="p">,</span> <span class="n">haccum_u16</span><span class="p">,</span> <span class="n">tweights</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">istart</span><span class="p">]</span> <span class="p">);</span>
                <span class="p">}</span>

                <span class="n">STORE_ACCUMULATORS_TO_16_8BIT</span><span class="p">(</span> <span class="n">laccum_u16</span><span class="p">,</span> <span class="n">haccum_u16</span><span class="p">,</span> <span class="n">dst</span> <span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// correct data pointers by the difference between image width and row stride</span>
        <span class="n">src</span> <span class="o">+=</span> <span class="n">lineStride</span> <span class="o">-</span> <span class="n">width</span><span class="p">;</span>
        <span class="n">dst</span> <span class="o">+=</span> <span class="n">lineStride</span> <span class="o">-</span> <span class="n">width</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="id2">
<h3>Adding multi-threading<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>In order to parallelize the work across multiple CPUs, we follow the methodology from
the previous example.
First, let&#8217;s define a structure holding read-only data for each of the threads:</p>
<ul>
<li><p class="first">Copy the code below to <tt class="docutils literal"><span class="pre">ExampleVBlurImageMT.h</span></tt></p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
    <span class="c1">// source and destination image size</span>
    <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">;</span>
    <span class="c1">// pointer to destination image data</span>
    <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">;</span>
    <span class="c1">// pointer to source image data</span>
    <span class="kt">uint8_t</span> <span class="k">const</span> <span class="o">*</span><span class="n">src</span><span class="p">;</span>
<span class="p">}</span> <span class="n">VBlurImage8Data</span><span class="p">;</span>
</pre></div>
</div>
</li>
</ul>
<p>Then, we specify the function that configures the extent of image processing work
and launches threads:</p>
<ul>
<li><p class="first">Copy the code below to <tt class="docutils literal"><span class="pre">ExampleVBlurImageMT.h</span></tt></p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">VBlurImage8MT</span><span class="p">(</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// set up shared thread data (pointers to source and destination images and their size)</span>
    <span class="n">VBlurImage8Data</span> <span class="n">params</span><span class="p">;</span>
    <span class="n">params</span><span class="p">.</span><span class="n">src</span> <span class="o">=</span> <span class="n">src</span><span class="p">;</span>
    <span class="n">params</span><span class="p">.</span><span class="n">dst</span> <span class="o">=</span> <span class="n">dst</span><span class="p">;</span>
    <span class="n">params</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">width</span><span class="p">;</span>
    <span class="n">params</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">height</span><span class="p">;</span>

    <span class="c1">// execute VBlurImage8ThreadProc() in parallel</span>
    <span class="c1">// the thread count is set to zero (auto-detect) and the granularity</span>
    <span class="c1">// of task is set to the number of image rows</span>
    <span class="n">RunThreads</span><span class="p">(</span> <span class="n">VBlurImage8ThreadProc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">params</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
<p>Finally, let&#8217;s define the function executed by each thread:</p>
<ul>
<li><p class="first">Copy the code below to <tt class="docutils literal"><span class="pre">ExampleVBlurImageMT.h</span></tt> (above <tt class="docutils literal"><span class="pre">VBlurImage8MT()</span></tt> function)</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">VBlurImage8ThreadProc</span><span class="p">(</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">ThreadData</span><span class="o">&lt;</span><span class="n">VBlurImage8Data</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">*</span><span class="n">tdata</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">ThreadData</span><span class="o">&lt;</span><span class="n">VBlurImage8Data</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">*&gt;</span><span class="p">(</span> <span class="n">ptr</span> <span class="p">);</span>
    <span class="n">VBlurImage8Data</span> <span class="k">const</span> <span class="o">*</span><span class="n">params</span> <span class="o">=</span> <span class="n">tdata</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">;</span>

    <span class="c1">// invoke image processing on the image area assigned to the current thread</span>
    <span class="n">VBlurImage8</span><span class="p">(</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">,</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">,</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">,</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span> <span class="n">tdata</span><span class="o">-&gt;</span><span class="n">taskStartIndex</span><span class="p">,</span>
                 <span class="n">tdata</span><span class="o">-&gt;</span><span class="n">taskEndIndex</span> <span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="id3">
<h3>Combining multi-threading and NEON code<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>Below we show how to extend the code for combined NEON and multi-threaded processing:</p>
<ul>
<li><p class="first">Copy the code below to <tt class="docutils literal"><span class="pre">ExampleVBlurImageMT.h</span></tt></p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">VBlurImage8NEON_MT</span><span class="p">(</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// set up shared thread data (pointers to source and destination images and their size)</span>
    <span class="n">VBlurImage8Data</span> <span class="n">params</span><span class="p">;</span>
    <span class="n">params</span><span class="p">.</span><span class="n">src</span> <span class="o">=</span> <span class="n">src</span><span class="p">;</span>
    <span class="n">params</span><span class="p">.</span><span class="n">dst</span> <span class="o">=</span> <span class="n">dst</span><span class="p">;</span>
    <span class="n">params</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">width</span><span class="p">;</span>
    <span class="n">params</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">height</span><span class="p">;</span>

    <span class="c1">// execute VBlurImage8ThreadProcNEON() in parallel</span>
    <span class="c1">// the thread count is set to zero (auto-detect) and the granularity</span>
    <span class="c1">// of task is set to the number of image rows</span>
    <span class="n">RunThreads</span><span class="p">(</span> <span class="n">VBlurImage8ThreadProcNEON</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">params</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
<p>Similar to the previous example, we replace the thread body with a function that uses NEON
for processing:</p>
<ul>
<li><p class="first">Copy the code below to <tt class="docutils literal"><span class="pre">ExampleVBlurImageMT.h</span></tt> (above <tt class="docutils literal"><span class="pre">VBlurImage8NEON_MT()</span></tt> function)</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">VBlurImage8ThreadProcNEON</span><span class="p">(</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">ThreadData</span><span class="o">&lt;</span><span class="n">VBlurImage8Data</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">*</span><span class="n">tdata</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">ThreadData</span><span class="o">&lt;</span><span class="n">VBlurImage8Data</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">*&gt;</span><span class="p">(</span> <span class="n">ptr</span> <span class="p">);</span>
    <span class="n">VBlurImage8Data</span> <span class="k">const</span> <span class="o">*</span><span class="n">params</span> <span class="o">=</span> <span class="n">tdata</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">;</span>

    <span class="c1">// invoke image processing on the image area assigned to the current thread</span>
    <span class="n">VBlurImage8AlignedNEON</span><span class="p">(</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">,</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">,</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">,</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span>
                            <span class="n">tdata</span><span class="o">-&gt;</span><span class="n">taskStartIndex</span><span class="p">,</span> <span class="n">tdata</span><span class="o">-&gt;</span><span class="n">taskEndIndex</span> <span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="going-further-cache-blocking">
<h3>Going further: cache blocking<a class="headerlink" href="#going-further-cache-blocking" title="Permalink to this headline">¶</a></h3>
<p>Tegra CPUs can process data very fast.
In fact, they can process the data much faster than they can read it from the system memory!
In order to reduce the amount of time the processor waits for the data
(commonly referred to as <em>access latency</em>), Tegra CPUs include a hierarchy of cache memory:
a small and fast subsystem that &#8220;buffers&#8221; memory operations between the CPU and the system
memory.
Cache memory is optimized towards data reuse: the data your code reads from the
system memory stays in the cache hierarchy for future reads, until it is overwritten
by newer chunks of data.
Because most memory access patterns in the CPU code are of random, but local nature, the use of
cache memory has a tremendous impact on the system performance.</p>
<p>To maximize the benefit from short cache access times, we have to make sure that our algorithm&#8217;s
memory access patterns maximize the probability of <em>cache hit</em> (requested data found in cache),
in other words, maximize the reuse of data stored in the cache.</p>
<p>From the two examples that we have presented, only the second one (image blurring) reads the same
pixel data multiple times. At first glance, it looks like the method has good data locality
&#8211; each output pixel is computed via weighted sum of its vertical neighbors. But what is
local in image space is not necessarily local to the CPU. This is because the CPU has a
linear view of the image data, so pixels in neighboring rows are located in different
memory regions.
The algorithm computes the output in a scan-line traversal order (left-to-right and top-to-bottom).
This means that as soon as rows used for the convolution operator become larger than
the cache capacity, processing the beginning of a new row will require refetching the data
from the system memory and result in a significant reduction of the performance.</p>
<p>To mitigate the above issue, we can use <em>cache blocking</em> method, which basically is a
modification of the computation/traversal order that maximizes <em>cache-hit</em> to <em>cache-miss</em> ratio.
Let&#8217;s start by defining a new variation of blurring method:</p>
<ul>
<li><p class="first">Copy the code below to <tt class="docutils literal"><span class="pre">ExampleVBlurImageMT.h</span></tt></p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">VBlurImage8NEON_MT_TILED</span><span class="p">(</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// set up shared thread data (pointers to source and destination images and their size)</span>
    <span class="n">VBlurImage8Data</span> <span class="n">params</span><span class="p">;</span>
    <span class="n">params</span><span class="p">.</span><span class="n">src</span> <span class="o">=</span> <span class="n">src</span><span class="p">;</span>
    <span class="n">params</span><span class="p">.</span><span class="n">dst</span> <span class="o">=</span> <span class="n">dst</span><span class="p">;</span>
    <span class="n">params</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">width</span><span class="p">;</span>
    <span class="n">params</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">height</span><span class="p">;</span>

    <span class="c1">// execute VBlurImage8ThreadProcTiledNEON() in parallel</span>
    <span class="c1">// the thread count is set to zero (auto-detect) and the granularity</span>
    <span class="c1">// of task is set to the number of image rows</span>
    <span class="n">RunThreads</span><span class="p">(</span> <span class="n">VBlurImage8ThreadProcTiledNEON</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">params</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p class="first">Copy the code below to <tt class="docutils literal"><span class="pre">ExampleVBlurImageMT.h</span></tt> (above <tt class="docutils literal"><span class="pre">VBlurImage8NEON_MT_TILED()</span></tt> function)</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">VBlurImage8ThreadProcTiledNEON</span><span class="p">(</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">ThreadData</span><span class="o">&lt;</span><span class="n">VBlurImage8Data</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">*</span><span class="n">tdata</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">ThreadData</span><span class="o">&lt;</span><span class="n">VBlurImage8Data</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">*&gt;</span><span class="p">(</span> <span class="n">ptr</span> <span class="p">);</span>
    <span class="n">VBlurImage8Data</span> <span class="k">const</span> <span class="o">*</span><span class="n">params</span> <span class="o">=</span> <span class="n">tdata</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">;</span>

    <span class="c1">// tile size set to 256x256 pixels</span>
    <span class="kt">int</span> <span class="k">const</span> <span class="n">tileSize</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>

    <span class="c1">// scan-line order for tile processing</span>
    <span class="c1">// TODO: space filling curve might improve the performance</span>

    <span class="c1">// row range</span>
    <span class="kt">int</span> <span class="k">const</span> <span class="n">startY</span> <span class="o">=</span> <span class="n">tdata</span><span class="o">-&gt;</span><span class="n">taskStartIndex</span><span class="p">;</span>
    <span class="kt">int</span> <span class="k">const</span> <span class="n">endY</span>   <span class="o">=</span> <span class="n">tdata</span><span class="o">-&gt;</span><span class="n">taskEndIndex</span><span class="p">;</span>

    <span class="c1">// image size</span>
    <span class="kt">int</span> <span class="k">const</span> <span class="n">imageWidth</span>  <span class="o">=</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">;</span>
    <span class="kt">int</span> <span class="k">const</span> <span class="n">imageHeight</span> <span class="o">=</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">;</span>

    <span class="kt">uint8_t</span> <span class="k">const</span> <span class="o">*</span><span class="n">src</span> <span class="o">=</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span>       <span class="o">=</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">;</span>

    <span class="c1">// iterate over rows of tiles</span>
    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">startY</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">endY</span><span class="p">;</span> <span class="n">y</span> <span class="o">+=</span> <span class="n">tileSize</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// clip end y coordinate of tiles in current row</span>
        <span class="c1">// if it goes out of valid row range</span>
        <span class="kt">int</span> <span class="n">ey</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">tileSize</span><span class="p">;</span>
        <span class="n">ey</span> <span class="o">=</span> <span class="n">ey</span> <span class="o">&gt;</span> <span class="n">endY</span> <span class="o">?</span> <span class="n">endY</span> <span class="o">:</span> <span class="n">ey</span><span class="p">;</span>

        <span class="c1">// iterate over a row of tiles</span>
        <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">imageWidth</span><span class="p">;</span> <span class="n">x</span> <span class="o">+=</span> <span class="n">tileSize</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// clip tile end x coordinate if it goes out of image</span>
            <span class="kt">int</span> <span class="n">ex</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">tileSize</span><span class="p">;</span>
            <span class="n">ex</span> <span class="o">=</span> <span class="n">ex</span> <span class="o">&gt;</span> <span class="n">imageWidth</span> <span class="o">?</span> <span class="n">imageWidth</span> <span class="o">:</span> <span class="n">ex</span><span class="p">;</span>

            <span class="c1">// execute NEON kernel for the current tile</span>
            <span class="n">VBlurImage8AlignedNEON</span><span class="p">(</span> <span class="n">dst</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">src</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">ex</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="n">imageHeight</span><span class="p">,</span> <span class="n">imageWidth</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">ey</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
<p>The thread body function has been modifed to process the image as a matrix
of fixed-size tiles. This way we make sure that, during the scan-line processing,
all the rows necessary for computation of convolution are in the cache, and each
new row inside of the tile will be fetched from the system memory only once.</p>
</div>
<div class="section" id="going-further-data-prefetching">
<h3>Going further: data prefetching<a class="headerlink" href="#going-further-data-prefetching" title="Permalink to this headline">¶</a></h3>
<p>Another method of hiding memory access latency is to pass a hint to the CPU memory controller
about the location of the data you will need in the near future, e.g., several iterations
ahead of the current one. Because the memory controller works independently from compute units,
we can start <em>prefetching</em> the data into cache for the next iterations while calculating
the result of current iteration. This effectively hides part of system memory access latency
behind the computation time. GCC compiler has a built-in command that allows to pass a prefetch
hint to the CPU memory controller: <tt class="docutils literal"><span class="pre">__builtin_prefetch(x)</span></tt>, where <tt class="docutils literal"><span class="pre">x</span></tt> is a pointer to memory
location we want to prefetch.</p>
<ul>
<li><p class="first">Copy the code below to the beginning of most inner loop (index i) of <tt class="docutils literal"><span class="pre">AddImage8AlignedNEON()</span></tt>
and <tt class="docutils literal"><span class="pre">runVectorLoop()</span></tt> in <tt class="docutils literal"><span class="pre">ExampleAddImageNeon.h</span></tt></p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// prefetch 64-bytes (2 cache lines on Tegra 3) ahead of current location in the source images</span>
<span class="n">__builtin_prefetch</span><span class="p">(</span><span class="n">src1</span> <span class="o">+</span> <span class="mi">64</span><span class="p">);</span>
<span class="n">__builtin_prefetch</span><span class="p">(</span><span class="n">src2</span> <span class="o">+</span> <span class="mi">64</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p class="first">Copy the code below to the beginning of most inner loop (index i) of <tt class="docutils literal"><span class="pre">VBlurImage8AlignedNEON()</span></tt> in <tt class="docutils literal"><span class="pre">ExampleVBlurImageNeon.h</span></tt></p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// prefetch 64-bytes (2 cache lines on Tegra 3) ahead of current location in the source image</span>
<span class="n">__builtin_prefetch</span><span class="p">(</span><span class="n">sourceData</span> <span class="o">+</span> <span class="mi">64</span><span class="p">);</span>
</pre></div>
</div>
</li>
</ul>
<p>The choice of how far ahead we should read is a tricky one. It highly depends on the algorithm, its memory
access patterns and even the type of CPU we optimize for (different architecture have different cache line
sizes). We recommend you to experiment with various settings and measure the speed improvements.
An arbitrary look ahead location can be passed as an argument, but in case of streaming processing,
where input elements are processed sequentially, prefetching 32&#8211;128 bytes ahead produces best results.
The address should also be aligned to the cache line size, which is a minimum transfer unit between
CPU and system memory.</p>
</div>
</div>
<div class="section" id="performance-analysis">
<h2>Performance analysis<a class="headerlink" href="#performance-analysis" title="Permalink to this headline">¶</a></h2>
<p>In this section we show the performance figures of the code covered in the tutorial.
The examples have been compiled on GNU GCC 4.6 compiler (part of <em>Android NDK r8b</em>)
with optimization flags set to <tt class="docutils literal"><span class="pre">-O2</span> <span class="pre">-mfpu=neon</span></tt>. The timings were generated
on NVIDIA Cardhu tablet running <em>Android 4.1</em>. The multi-threaded version of the
code used two threads for parallel execution.</p>
<div class="section" id="speed-up-comparison">
<h3>Speed-up comparison<a class="headerlink" href="#speed-up-comparison" title="Permalink to this headline">¶</a></h3>
<p>Running the test app on Cardhu produces the following timings for image sum operation:</p>
<div class="highlight-python"><pre>AddImage8():                  91.866ms
AddImage8AlignedNEON():       48.749ms
AddImage8UnalignedNEON():     50.969ms
AddImage8MT():                46.991ms
AddImage8NEON_MT():           43.770ms</pre>
</div>
<p>Speed-up ratios:</p>
<a class="reference internal image-reference" href="_images/image_proc_add_speedup.png"><img alt="_images/image_proc_add_speedup.png" src="_images/image_proc_add_speedup.png" style="width: 679.0px; height: 403.0px;" /></a>
<p>After augmenting the code with data prefetching the NEON code
becomes significantly faster:</p>
<div class="highlight-python"><pre>AddImage8():                  92.383ms
AddImage8AlignedNEON():       34.843ms
AddImage8UnalignedNEON():     43.002ms
AddImage8MT():                48.473ms
AddImage8NEON_MT():           32.402ms</pre>
</div>
<p>Speed-up ratios:</p>
<a class="reference internal image-reference" href="_images/image_proc_add_speedup2.png"><img alt="_images/image_proc_add_speedup2.png" src="_images/image_proc_add_speedup2.png" style="width: 676.0px; height: 405.0px;" /></a>
<p>The vertical blur operation from the second example takes:</p>
<div class="highlight-python"><pre>VBlurImage8():                394.113ms
VBlurImage8MT():              199.049ms
VBlurImage8AlignedNEON():     82.291ms
VBlurImage8NEON_MT():         53.299ms
VBlurImage8NEON_MT_TILED():   38.850ms</pre>
</div>
<p>Speed-up ratios:</p>
<a class="reference internal image-reference" href="_images/image_proc_vblur_speedup.png"><img alt="_images/image_proc_vblur_speedup.png" src="_images/image_proc_vblur_speedup.png" style="width: 677.0px; height: 401.0px;" /></a>
<p>The vertical blur code benefits from prefetching even more. Note that
manual data prefetching effectively canceled the benefits of cache blocking:</p>
<div class="highlight-python"><pre>VBlurImage8():                392.510ms
VBlurImage8MT():              197.895ms
VBlurImage8AlignedNEON():     65.176ms
VBlurImage8NEON_MT():         33.295ms
VBlurImage8NEON_MT_TILED():   35.479ms</pre>
</div>
<p>Speed-up ratios:</p>
<a class="reference internal image-reference" href="_images/image_proc_vblur_speedup2.png"><img alt="_images/image_proc_vblur_speedup2.png" src="_images/image_proc_vblur_speedup2.png" style="width: 678.0px; height: 403.0px;" /></a>
</div>
<div class="section" id="is-my-algorithm-compute-or-memory-bound">
<h3>Is my algorithm compute or memory bound?<a class="headerlink" href="#is-my-algorithm-compute-or-memory-bound" title="Permalink to this headline">¶</a></h3>
<p>While analyzing the above figures, you might notice that both algorithms behave
differently when increasing parallelism through vectorization and multi-threaded execution.</p>
<p>Image adding function doubles the performance with two threads, but does not go much
above that, although the NEON code processes 16-pixels in each iteration of the inner loop.
This is because the algorithm is not bound by slow computation, but by slow system memory
bandwidth.
It is important to identify such situations in your software, so you can avoid over-optimizing
the code and wasting computational resources. In case of image sum operation, the most optimal
version in terms of power/performance ratio is the single-threaded NEON version.</p>
<p>The vertical blur method, on the other hand, shows good scaling with the increase of
computational resources we throw at the problem. Only comparing the single-threaded+NEON
with multi-threaded+NEON versions we notice the speed-up does not quite match the
expectations, i.e., we get <cite>7.4x</cite> instead of <cite>9.6x</cite>. This is most likely the moment
where we also hit the memory bandwidth wall. We can address the problem with cache
blocking or manual prefetching, that allows us to get closer to the computational
SOL (<em>speed-of-light</em>) for this algorithm.</p>
</div>
</div>
<div class="section" id="example-3-computing-a-measure-of-similarity-between-images">
<h2>Example 3: Computing a measure of similarity between images<a class="headerlink" href="#example-3-computing-a-measure-of-similarity-between-images" title="Permalink to this headline">¶</a></h2>
<p>Image comparison is one of the most common tasks performed in computer vision.
The majority of methods addressing image registration, pattern matching, feature
detection or camera pose estimation, include an evaluation step where one image is transformed
and compared to the other using a specific distance metric (e.g., sum of absolute differences).
The result of the comparison is a single number that tells us how similar
the images are to each other.
In this section we demonstrate how to map this example computer vision algorithm
to programmable GPU hardware and how to use some of its fixed-functionality hardware
to greatly improve the run-time performance.</p>
<a class="reference internal image-reference" href="_images/image_proc_image_diff.png"><img alt="_images/image_proc_image_diff.png" src="_images/image_proc_image_diff.png" style="width: 640.0px; height: 400.0px;" /></a>
<div class="section" id="id4">
<h3>Test application<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>You can find the source code of an example GPGPU application in <tt class="docutils literal"><span class="pre">/tutorials/ImageProcessingGLES</span></tt>.
The import procedure is similar to previous examples.
Open Eclipse, select <em>File &gt; Import &gt; Android &gt; Existing Android Code into
Workspace</em>, and browse into the <em>Root Directory</em> of the test app (<tt class="docutils literal"><span class="pre">/tutorials/ImageProcessingGLES</span></tt>).
If you choose to copy the files into workspace, you may have to also copy the folder <tt class="docutils literal"><span class="pre">SharedCode</span></tt> under
the <tt class="docutils literal"><span class="pre">tutorials</span></tt> folder into the workspace.
Then hit <strong>Finish</strong>.</p>
<p>As this is a native project, select the C/C++ perspective.</p>
<a class="reference internal image-reference" href="_images/c_cpp_perspective.png"><img alt="_images/c_cpp_perspective.png" src="_images/c_cpp_perspective.png" style="width: 142.0px; height: 34.0px;" /></a>
<p>By default all Android projects are Java projects, so let&#8217;s convert ours to native
by right-clicking on the project in <em>Package Explorer</em> and selecting <em>Android Tools &gt; Add Native Support</em>.</p>
<a class="reference internal image-reference" href="_images/image_proc_native_support.png"><img alt="_images/image_proc_native_support.png" src="_images/image_proc_native_support.png" style="width: 648.0px; height: 197.0px;" /></a>
<p>Then we have to select a name for the library storing the native code. Please use <em>ImageProcessingGLES</em>
as the name. You might try to build the project (right-click <em>ImageProcessingGLES &gt; Build Project</em>),
however, the initial code base is incomplete. During the course of this tutorial you will fill in the
missing parts and in the end will be able to successfully run the code on the device.
If you would like to skip this step and work with the final application, import
<tt class="docutils literal"><span class="pre">/tutorials/ImageProcessingGLES_Complete</span></tt> project directly.</p>
<p>The application source code is separated into several files:</p>
<ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">ImageProcessingGLES.cpp</span></tt> &#8212; main Android native activity code that performs application
initalization, EGL window setup, and implements event parsing loop. Also, on every frame the code
calls <tt class="docutils literal"><span class="pre">ApplicationGPGPU::runStateMachine()</span></tt> method until it returns true (application has quit).</li>
<li><tt class="docutils literal"><span class="pre">ApplicationGLES.h</span></tt> &#8212; contains a definition of <tt class="docutils literal"><span class="pre">ApplicationGLES</span></tt> base class that
addresses common functionality of OpenGL ES 2.0 application (e.g., full-screen window setup,
event handling).</li>
<li><tt class="docutils literal"><span class="pre">ApplicationGPGPU.h</span></tt> &#8212; a simple application that loads a test bitmap (<em>/assets/lena.bmp</em>)
and computes its similarity to a transformed (i.e., rotated) copy. Additionally, the application
displays an intermediate difference image, GPU timing, and the measure of similarity (<em>Image difference</em>)
in text and graphical form (as a difference history scroll).</li>
</ol>
<p>We have implemented a simple state machine that controls the life-cycle of the application.
You can find its implementation in <tt class="docutils literal"><span class="pre">ApplicationGPGPU::runStateMachine()</span></tt> method. Note the three
distinct states: <tt class="docutils literal"><span class="pre">STATE_INIT</span></tt> (initial state used for resource loading and OpenGL ES 2.0 initialization),
<tt class="docutils literal"><span class="pre">STATE_PROCESS</span></tt> (main rendering loop), and <tt class="docutils literal"><span class="pre">STATE_EXIT</span></tt> (stop state).</p>
</div>
<div class="section" id="accelerating-image-processing-with-opengl-es-2-0">
<h3>Accelerating image processing with OpenGL ES 2.0<a class="headerlink" href="#accelerating-image-processing-with-opengl-es-2-0" title="Permalink to this headline">¶</a></h3>
<p>So far we have been focusing on CPU-based optimizations.
If the achieved speed-up is still not enough for your application, the next
step is to use another powerful accelerator inside the Tegra SoC &#8212;
a programmable GPU (<em>Graphics Processing Unit</em>).
There are many graphics-related applications for which GPUs
produce an order of magnitude higher speed-ups than those presented above.
In mobile world GPUs are normally used by Android OS to improve the user experience
and graphics quality of the system UI. They are also widely employed in video games,
where high pixel and geometry processing throughput is often required.
However, since the GPU is basically a programmable compute unit, we can use it to
accelerate the processing of many tasks traditionally handled by the CPU.
This programming paradigm, commonly referred to as GPGPU (<em>General-purpose computing on the GPU</em>)
is particularly beneficial to methods that involve moving image pixels around
(projective transformations), filtering, or resampling the image data.</p>
<div class="admonition-implementation-note admonition">
<p class="first admonition-title">Implementation note</p>
<p>One of the most important features introduced in core OpenGL ES 2.0 API are
<em>Frame Buffer Objects</em> (FBOs). They allow for efficient rendering
to an off-screen surface, where the off-screen surface might be defined as
a texture (<em>render-to-texture</em>) or a <em>Render Buffer Object</em> (RBO).
Texture FBO targets (or <em>attachments</em>) are necessary when we plan to
use the output of current rendering pass as an input to subsequent rendering passes,
whereas RBOs are more suitable when we plan to read the contents of the FBO back (to host CPU space)
or display it. Here is an example render-to-texture code:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="k">const</span> <span class="n">outputWidth</span>  <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
<span class="kt">int</span> <span class="k">const</span> <span class="n">outputHeight</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>

<span class="c1">// create destination texture</span>
<span class="n">GLuint</span> <span class="n">textureId</span><span class="p">;</span>
<span class="n">glGenTextures</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">textureId</span> <span class="p">);</span>
<span class="c1">// bind the texture</span>
<span class="n">glBindTexture</span><span class="p">(</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">textureId</span> <span class="p">);</span>
<span class="c1">// setup default filtering mode</span>
<span class="n">glTexParameteri</span><span class="p">(</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_NEAREST</span> <span class="p">);</span>
<span class="n">glTexParameteri</span><span class="p">(</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_NEAREST</span> <span class="p">);</span>
<span class="n">glTexParameteri</span><span class="p">(</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span> <span class="p">);</span>
<span class="n">glTexParameteri</span><span class="p">(</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span> <span class="p">);</span>
<span class="c1">// allocate memory</span>
<span class="n">glTexImage2D</span><span class="p">(</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGBA</span><span class="p">,</span> <span class="n">outputWidth</span><span class="p">,</span> <span class="n">outputHeight</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGBA</span><span class="p">,</span>
              <span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>

<span class="c1">// create FBO</span>
<span class="n">GLuint</span> <span class="n">fbo</span><span class="p">;</span>
<span class="n">glGenFramebuffers</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fbo</span> <span class="p">);</span>
<span class="c1">// bind FBO as the current frame buffer</span>
<span class="n">glBindFramebuffer</span><span class="p">(</span> <span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">fbo</span> <span class="p">);</span>
<span class="c1">// attach output texture to the framebuffer</span>
<span class="n">glFramebufferTexture2D</span><span class="p">(</span> <span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_COLOR_ATTACHMENT0</span><span class="p">,</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">textureId</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
<span class="c1">// set the rendering viewport size to match FBO attachment size</span>
<span class="n">glViewport</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">outputWidth</span><span class="p">,</span> <span class="n">outputHeight</span> <span class="p">);</span>

<span class="c1">// CALL YOUR RENDERING CODE HERE</span>

<span class="c1">// unbind FBO -&gt; switching to regular &quot;screen&quot; rendering mode</span>
<span class="n">glBindFramebuffer</span><span class="p">(</span> <span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
<span class="c1">// destroy the FBO when not needed anymore</span>
<span class="n">glDeleteFramebuffers</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fbo</span> <span class="p">);</span>
</pre></div>
</div>
<p>The code using RBOs instead of textures (providing possibly a more efficient read-back to system memory)
looks similar:</p>
<div class="last highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="k">const</span> <span class="n">outputWidth</span>  <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
<span class="kt">int</span> <span class="k">const</span> <span class="n">outputHeight</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>

<span class="c1">// create RBO</span>
<span class="n">GLuint</span> <span class="n">rbo</span><span class="p">;</span>
<span class="n">glGenRenderbuffers</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rbo</span> <span class="p">);</span>
<span class="c1">// bind the RBO</span>
<span class="n">glBindRenderbuffer</span><span class="p">(</span> <span class="n">GL_RENDERBUFFER</span><span class="p">,</span> <span class="n">rbo</span> <span class="p">);</span>
<span class="c1">// allocate memory for output pixels</span>
<span class="n">glRenderbufferStorage</span><span class="p">(</span> <span class="n">GL_RENDERBUFFER</span><span class="p">,</span> <span class="n">GL_RGBA8_OES</span><span class="p">,</span> <span class="n">outputWidth</span><span class="p">,</span> <span class="n">outputHeight</span> <span class="p">);</span>

<span class="c1">// create FBO</span>
<span class="n">GLuint</span> <span class="n">fbo</span><span class="p">;</span>
<span class="n">glGenFramebuffers</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fbo</span> <span class="p">);</span>
<span class="c1">// bind FBO as the current frame buffer</span>
<span class="n">glBindFramebuffer</span><span class="p">(</span> <span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">fbo</span> <span class="p">);</span>
<span class="c1">// attach the RBO to the framebuffer</span>
<span class="n">glFramebufferRenderbuffer</span><span class="p">(</span> <span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_COLOR_ATTACHMENT0</span><span class="p">,</span> <span class="n">GL_RENDERBUFFER</span><span class="p">,</span> <span class="n">rbo</span> <span class="p">);</span>
<span class="c1">// set the rendering viewport size to match FBO attachement size</span>
<span class="n">glViewport</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">outputWidth</span><span class="p">,</span> <span class="n">outputHeight</span> <span class="p">);</span>

<span class="c1">// CALL YOUR RENDERING CODE HERE</span>

<span class="c1">// read the results from the RBO</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">outputWidth</span> <span class="o">*</span> <span class="n">outputHeight</span><span class="p">];</span>
<span class="n">glReadPixels</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">outputWidth</span><span class="p">,</span> <span class="n">outputHeight</span><span class="p">,</span> <span class="n">GL_RGBA</span><span class="p">,</span> <span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span> <span class="n">data</span> <span class="p">);</span>

<span class="c1">// unbind FBO -&gt; switching to regular &quot;screen&quot; rendering mode</span>
<span class="n">glBindFramebuffer</span><span class="p">(</span> <span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
<span class="c1">// destroy framebuffer and renderbuffer when not needed anymore</span>
<span class="n">glDeleteRenderbuffers</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rbo</span> <span class="p">);</span>
<span class="n">glDeleteFramebuffers</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fbo</span> <span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="d-perspective-warp-on-the-gpu">
<h3>2D perspective warp on the GPU<a class="headerlink" href="#d-perspective-warp-on-the-gpu" title="Permalink to this headline">¶</a></h3>
<p>First, let&#8217;s define a basic image comparison algorithm:</p>
<ol class="arabic simple">
<li>Apply a perspective transformation to texture A. The transformation is described
by a 2D homography matrix <em>H</em>.</li>
<li>Write the result to A&#8217;.</li>
<li>Subtract texture B from A&#8217;.</li>
<li>Write out the absolute values of per pixel differences to texture D.</li>
<li>Accumulate values in D to create a single similarity measure.</li>
</ol>
<p>Next, let&#8217;s try to address each of those points and implement their functionality in C++.</p>
<p>Given the homography matrix <em>H</em>:</p>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">H_{3 \times 3}=\left(\begin{array}{ccc}
m_{00} &amp; m_{01} &amp; m_{02} \\
m_{10} &amp; m_{11} &amp; m_{12} \\
m_{20} &amp; m_{21} &amp; m_{22} \end{array} \right)</tt>)</p>
latex exited with error:
[stderr]

[stdout]
This is pdfTeX, Version 3.1415926-2.4-1.40.13 (TeX Live 2012)
 restricted \write18 enabled.
entering extended mode
(./math.tex
LaTeX2e &lt;2011/06/27&gt;
Babel &lt;v3.8m&gt; and hyphenation patterns for english, dumylang, nohyphenation, ba
sque, danish, dutch, ukenglish, usenglishmax, finnish, french, german, ngerman,
 swissgerman, hungarian, italian, bokmal, nynorsk, polish, portuguese, spanish,
 swedish, loaded.
(/usr/local/texlive/2012basic/texmf-dist/tex/latex/base/article.cls
Document Class: article 2007/10/19 v1.4h Standard LaTeX document class
(/usr/local/texlive/2012basic/texmf-dist/tex/latex/base/size12.clo))
(/usr/local/texlive/2012basic/texmf-dist/tex/latex/base/inputenc.sty

! LaTeX Error: File `utf8x.def&#8217; not found.

Type X to quit or &lt;RETURN&gt; to proceed,
or enter new name. (Default extension: def)

Enter file name: 
! Emergency stop.
&lt;read *&gt; 
         
l.131 \endinput
               ^^M
No pages of output.
Transcript written on math.log.
</div>
<p>we can define the 2D perspective transformation as:</p>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">dst(x,y)=src\left(\frac{m_{00}x+m_{01}y+m_{02}}{m_{20}x+m_{21}y+m_{22}},\frac{m_{10}x+m_{11}y+m_{12}}{m_{20}x+m_{21}y+m_{22}}\right)</tt>)</p>
latex exited with error:
[stderr]

[stdout]
This is pdfTeX, Version 3.1415926-2.4-1.40.13 (TeX Live 2012)
 restricted \write18 enabled.
entering extended mode
(./math.tex
LaTeX2e &lt;2011/06/27&gt;
Babel &lt;v3.8m&gt; and hyphenation patterns for english, dumylang, nohyphenation, ba
sque, danish, dutch, ukenglish, usenglishmax, finnish, french, german, ngerman,
 swissgerman, hungarian, italian, bokmal, nynorsk, polish, portuguese, spanish,
 swedish, loaded.
(/usr/local/texlive/2012basic/texmf-dist/tex/latex/base/article.cls
Document Class: article 2007/10/19 v1.4h Standard LaTeX document class
(/usr/local/texlive/2012basic/texmf-dist/tex/latex/base/size12.clo))
(/usr/local/texlive/2012basic/texmf-dist/tex/latex/base/inputenc.sty

! LaTeX Error: File `utf8x.def&#8217; not found.

Type X to quit or &lt;RETURN&gt; to proceed,
or enter new name. (Default extension: def)

Enter file name: 
! Emergency stop.
&lt;read *&gt; 
         
l.131 \endinput
               ^^M
No pages of output.
Transcript written on math.log.
</div>
<p>where <tt class="docutils literal"><span class="pre">src</span></tt> is the input image and <tt class="docutils literal"><span class="pre">dst</span></tt> is the output image. This formulation is
equivalent to OpenCV <tt class="docutils literal"><span class="pre">cv::warpPerspective()</span></tt> function and can be implemented on the GPU
in a straightforward way. All you need to do is render two triangles (<em>quad</em>) over
the entire area of the output image. This way we guarantee that every pixel&#8217;s value in
the output image is generated by the currently attached fragment program.
The pixel shader will simply evaluate the function for every pixel and write out its
value to corresponding location in the output texture.</p>
<p>This approach is clean and an order of magnitude faster that the CPU code, but we can
still accelerate it by using fixed-functionality hardware that enables perspective-corrected
rasterization. First, let&#8217;s take a quick (and simplified) look at the geometry
transformation stage in the OpenGL graphics pipeline (see section 2.11 of the OpenGL
ES 2.0 specification). The key observation here is that the vertex output position
<tt class="docutils literal"><span class="pre">V</span> <span class="pre">=</span> <span class="pre">(x,</span> <span class="pre">y,</span> <span class="pre">z,</span> <span class="pre">w)</span></tt>, together with every varying attribute generated by a vertex shader,
is projected to the clip-space via a perspective projection <tt class="docutils literal"><span class="pre">V'</span> <span class="pre">=</span> <span class="pre">(x/w,</span> <span class="pre">y/w,</span> <span class="pre">z/w,</span> <span class="pre">1/w)</span></tt>.
These coordinates are then linearly interpolated in screen-space by the rasterizer
(see section 3.5.1 of the OpenGL ES 2.0 specification), but right before they get
accessible in a fragment program they are subject to division by the last component
of vertex position (interpolated <tt class="docutils literal"><span class="pre">1/w</span></tt>) again. This way the values available to the
programmer in the pixel shader become &#8220;perspective corrected&#8221;. Since perspective correction
is always on (therefore &#8220;free&#8221;), we can speed up our 2D warping code significantly by
moving part of the computation to the vertex shader and rasterizer hardware.
This can be achieved simply by reshuffling coefficients of the 2D homography matrix
into a <cite>4x4</cite> OpenGL-compatible homography matrix:</p>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">H_{4 \times 4}=\left(\begin{array}{cccc}
m_{00} &amp; m_{01} &amp; 0 &amp; m_{02} \\
m_{10} &amp; m_{11} &amp; 0 &amp; m_{12} \\
0 &amp; 0 &amp; 1 &amp; 0 \\
m_{20} &amp; m_{21} &amp; 0 &amp; m_{22} \end{array} \right)</tt>)</p>
latex exited with error:
[stderr]

[stdout]
This is pdfTeX, Version 3.1415926-2.4-1.40.13 (TeX Live 2012)
 restricted \write18 enabled.
entering extended mode
(./math.tex
LaTeX2e &lt;2011/06/27&gt;
Babel &lt;v3.8m&gt; and hyphenation patterns for english, dumylang, nohyphenation, ba
sque, danish, dutch, ukenglish, usenglishmax, finnish, french, german, ngerman,
 swissgerman, hungarian, italian, bokmal, nynorsk, polish, portuguese, spanish,
 swedish, loaded.
(/usr/local/texlive/2012basic/texmf-dist/tex/latex/base/article.cls
Document Class: article 2007/10/19 v1.4h Standard LaTeX document class
(/usr/local/texlive/2012basic/texmf-dist/tex/latex/base/size12.clo))
(/usr/local/texlive/2012basic/texmf-dist/tex/latex/base/inputenc.sty

! LaTeX Error: File `utf8x.def&#8217; not found.

Type X to quit or &lt;RETURN&gt; to proceed,
or enter new name. (Default extension: def)

Enter file name: 
! Emergency stop.
&lt;read *&gt; 
         
l.131 \endinput
               ^^M
No pages of output.
Transcript written on math.log.
</div>
<p>The final vertex shader that renders a warped texture quad is defined as:</p>
<ul>
<li><p class="first">Copy the code below to <tt class="docutils literal"><span class="pre">assets/warped_diff.vert</span></tt></p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// vertex position</span>
<span class="n">attribute</span> <span class="n">vec2</span> <span class="n">aPosition</span><span class="p">;</span>
<span class="c1">// vertex coordinate inside the texture</span>
<span class="n">attribute</span> <span class="n">vec2</span> <span class="n">aTexCoord</span><span class="p">;</span>
<span class="c1">// transformation matrix</span>
<span class="n">uniform</span> <span class="n">mat4</span> <span class="n">uTransformMatrix</span><span class="p">;</span>
<span class="c1">// per-pixel coordinate inside the texture</span>
<span class="n">varying</span> <span class="n">vec2</span> <span class="n">vTexCoord</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">vTexCoord</span>   <span class="o">=</span> <span class="n">aTexCoord</span><span class="p">;</span>
   <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">uTransformMatrix</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span> <span class="n">aPosition</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">aPosition</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
<p>Since the perspective transformation has been done completely by the fixed-functionality hardware, the
pixel shader is reduced into a single texture look-up, and we can skip all the warping computations here:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">precision</span> <span class="n">mediump</span> <span class="kt">float</span><span class="p">;</span>
<span class="c1">// handler to input texture</span>
<span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">uWarpedTex</span><span class="p">;</span>
<span class="c1">// per pixel coordinate inside the texture (perspective transform corrected)</span>
<span class="n">varying</span> <span class="n">vec2</span> <span class="n">vTexCoord</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
   <span class="c1">// look-up the input texture and write out the result</span>
   <span class="n">gl_FragColor</span> <span class="o">=</span> <span class="n">texture2D</span><span class="p">(</span> <span class="n">uWarpedTex</span><span class="p">,</span> <span class="n">vTexCoord</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The above fragment program will read the input image, warp it (point #1 from the algorithm overview) and
write-out the result (point #2). Then, another render pass will read the warped image together with
image <cite>B</cite> (point #3) and compute the difference between them. To minimize the amount of utilized memory
bandwidth we can combine/fuse perspective warp with subtraction stage and create a single shader that
will directly (and in a single draw pass) compute a difference image between warped <cite>A</cite> and <cite>B</cite>:</p>
<ul>
<li><p class="first">Copy the code below to <tt class="docutils literal"><span class="pre">assets/warped_diff.frag</span></tt></p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">precision</span> <span class="n">mediump</span> <span class="kt">float</span><span class="p">;</span>
<span class="c1">// handler to the image B</span>
<span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">uBaseTex</span><span class="p">;</span>
<span class="c1">// handler to the image A</span>
<span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">uWarpedTex</span><span class="p">;</span>
<span class="c1">// normalization factor that converts window coordinates</span>
<span class="c1">// to texture coordinates (1/width, 1/height)</span>
<span class="n">uniform</span> <span class="n">vec2</span> <span class="n">uFragCoordNorm</span><span class="p">;</span>

<span class="n">varying</span> <span class="n">vec2</span> <span class="n">vTexCoord</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
   <span class="c1">// fetch texels from both images and subtract</span>
   <span class="n">vec4</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">texture2D</span><span class="p">(</span> <span class="n">uBaseTex</span><span class="p">,</span> <span class="n">gl_FragCoord</span><span class="p">.</span><span class="n">st</span> <span class="o">*</span> <span class="n">uFragCoordNorm</span> <span class="p">)</span> <span class="o">-</span> <span class="n">texture2D</span><span class="p">(</span> <span class="n">uWarpedTex</span><span class="p">,</span> <span class="n">vTexCoord</span> <span class="p">);</span>
   <span class="c1">// write out the absolute value</span>
   <span class="n">gl_FragColor</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span> <span class="n">diff</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
<p>As the above shader is not covering the entire output texture anymore (only the part resulting from warping the input
image), we need to clear the destination difference image before the draw calls (i.e., <tt class="docutils literal"><span class="pre">glClear(GL_COLOR_BUFFER_BIT)</span></tt>).</p>
<p>A complete function that renders the difference image into a texture is defined as follows:</p>
<ul>
<li><p class="first">Copy the code below into the <tt class="docutils literal"><span class="pre">ApplicationGPGPU</span></tt> class definition (inside <tt class="docutils literal"><span class="pre">ApplicationGPGPU.h</span></tt>)</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// compute difference image between an image and its perspective transformed copy</span>
<span class="kt">void</span> <span class="nf">generateDifferenceImage</span><span class="p">(</span> <span class="n">Math</span><span class="o">::</span><span class="n">Matrix4x4f</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">transformMatrix</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="c1">// bind the FBO</span>
   <span class="n">glBindFramebuffer</span><span class="p">(</span> <span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">mFBO</span> <span class="p">);</span>

   <span class="c1">// attach output texture to the framebuffer</span>
   <span class="n">glFramebufferTexture2D</span><span class="p">(</span> <span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_COLOR_ATTACHMENT0</span><span class="p">,</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">mImageDiffTexture</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
   <span class="n">glViewport</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mSourceImageWidth</span><span class="p">,</span> <span class="n">mSourceImageHeight</span> <span class="p">);</span>

   <span class="c1">// clear the output texture</span>
   <span class="n">glClearColor</span><span class="p">(</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span> <span class="p">);</span>
   <span class="n">glClear</span><span class="p">(</span> <span class="n">GL_COLOR_BUFFER_BIT</span> <span class="p">);</span>

   <span class="c1">// activate warping fragment program</span>
   <span class="n">glUseProgram</span><span class="p">(</span> <span class="n">mWarpedDiffProgram</span> <span class="p">);</span>

   <span class="c1">// setup uniforms</span>
   <span class="n">glActiveTexture</span><span class="p">(</span> <span class="n">GL_TEXTURE0</span> <span class="p">);</span>
   <span class="n">glBindTexture</span><span class="p">(</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">mSourceImageTexture</span> <span class="p">);</span>

   <span class="n">glActiveTexture</span><span class="p">(</span> <span class="n">GL_TEXTURE1</span> <span class="p">);</span>
   <span class="n">glBindTexture</span><span class="p">(</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">mSourceImageTexture</span> <span class="p">);</span>

   <span class="n">glUniform1i</span><span class="p">(</span> <span class="n">glGetUniformLocation</span><span class="p">(</span> <span class="n">mWarpedDiffProgram</span><span class="p">,</span> <span class="s">&quot;uBaseTex&quot;</span> <span class="p">),</span> <span class="mi">0</span> <span class="p">);</span>
   <span class="n">glUniform1i</span><span class="p">(</span> <span class="n">glGetUniformLocation</span><span class="p">(</span> <span class="n">mWarpedDiffProgram</span><span class="p">,</span> <span class="s">&quot;uWarpedTex&quot;</span> <span class="p">),</span> <span class="mi">1</span> <span class="p">);</span>

   <span class="c1">// scale quad to span from -1 to 1 in normalized device coordinate space</span>
   <span class="n">Math</span><span class="o">::</span><span class="n">Matrix4x4f</span> <span class="n">viewMatrix</span><span class="p">;</span>
   <span class="n">viewMatrix</span><span class="p">.</span><span class="n">setScale</span><span class="p">(</span> <span class="mf">2.0f</span> <span class="p">);</span>
   <span class="n">viewMatrix</span><span class="p">.</span><span class="n">applyTranslate</span><span class="p">(</span> <span class="o">-</span><span class="mf">1.0f</span> <span class="p">);</span>
   <span class="n">viewMatrix</span> <span class="o">*=</span> <span class="n">transformMatrix</span><span class="p">;</span>

   <span class="c1">// pass a normalizer for window coordinates (gl_FragCoord), we need to access reference</span>
   <span class="c1">// unwarped image from warped image renderer</span>
   <span class="n">glUniform2f</span><span class="p">(</span> <span class="n">glGetUniformLocation</span><span class="p">(</span> <span class="n">mWarpedDiffProgram</span><span class="p">,</span> <span class="s">&quot;uFragCoordNorm&quot;</span> <span class="p">),</span> <span class="mf">1.0f</span> <span class="o">/</span> <span class="n">mSourceImageWidth</span><span class="p">,</span>
               <span class="mf">1.0f</span> <span class="o">/</span> <span class="n">mSourceImageHeight</span> <span class="p">);</span>

   <span class="n">glUniformMatrix4fv</span><span class="p">(</span> <span class="n">glGetUniformLocation</span><span class="p">(</span> <span class="n">mWarpedDiffProgram</span><span class="p">,</span> <span class="s">&quot;uTransformMatrix&quot;</span> <span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span>
                      <span class="n">viewMatrix</span><span class="p">.</span><span class="n">mData</span> <span class="p">);</span>

   <span class="c1">// render difference image into a texture</span>
   <span class="n">drawQuad</span><span class="p">(</span> <span class="n">mWarpedDiffProgram</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
<p>The last line of the <tt class="docutils literal"><span class="pre">generateDifferenceImage()</span></tt> function calls a helper method <tt class="docutils literal"><span class="pre">drawQuad()</span></tt>
that renders a textured quad with width and height equal to one:</p>
<ul>
<li><p class="first">Copy the code below into the <tt class="docutils literal"><span class="pre">ApplicationGPGPU</span></tt> class definition (inside <tt class="docutils literal"><span class="pre">ApplicationGPGPU.h</span></tt>)</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">drawQuad</span><span class="p">(</span> <span class="n">GLuint</span> <span class="n">shader</span><span class="p">,</span> <span class="kt">float</span> <span class="n">texCoordScale</span> <span class="o">=</span> <span class="mf">1.0f</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="c1">// 2D vertex position data</span>
   <span class="kt">float</span> <span class="k">const</span> <span class="n">vertPositionData</span><span class="p">[]</span> <span class="o">=</span>
   <span class="p">{</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span> <span class="p">};</span>

   <span class="c1">// per vertex 2D coordinates inside the texture</span>
   <span class="kt">float</span> <span class="k">const</span> <span class="n">textureCoordData</span><span class="p">[]</span> <span class="o">=</span>
   <span class="p">{</span> <span class="n">texCoordScale</span><span class="p">,</span> <span class="n">texCoordScale</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="n">texCoordScale</span><span class="p">,</span> <span class="n">texCoordScale</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span> <span class="p">};</span>

   <span class="c1">// drawing quad</span>
   <span class="kt">int</span> <span class="n">attribPosCoord</span> <span class="o">=</span> <span class="n">glGetAttribLocation</span><span class="p">(</span> <span class="n">shader</span><span class="p">,</span> <span class="s">&quot;aPosition&quot;</span> <span class="p">);</span>
   <span class="kt">int</span> <span class="n">attribTexCoord</span> <span class="o">=</span> <span class="n">glGetAttribLocation</span><span class="p">(</span> <span class="n">shader</span><span class="p">,</span> <span class="s">&quot;aTexCoord&quot;</span> <span class="p">);</span>

   <span class="n">glVertexAttribPointer</span><span class="p">(</span> <span class="n">attribPosCoord</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vertPositionData</span> <span class="p">);</span>
   <span class="n">glVertexAttribPointer</span><span class="p">(</span> <span class="n">attribTexCoord</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">textureCoordData</span> <span class="p">);</span>
   <span class="n">glEnableVertexAttribArray</span><span class="p">(</span> <span class="n">attribPosCoord</span> <span class="p">);</span>
   <span class="n">glEnableVertexAttribArray</span><span class="p">(</span> <span class="n">attribTexCoord</span> <span class="p">);</span>
   <span class="n">glDrawArrays</span><span class="p">(</span> <span class="n">GL_TRIANGLE_STRIP</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span> <span class="p">);</span>
   <span class="n">glDisableVertexAttribArray</span><span class="p">(</span> <span class="n">attribPosCoord</span> <span class="p">);</span>
   <span class="n">glDisableVertexAttribArray</span><span class="p">(</span> <span class="n">attribTexCoord</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="computing-a-sum-of-pixel-values-on-the-gpu">
<h3>Computing a sum of pixel values on the GPU<a class="headerlink" href="#computing-a-sum-of-pixel-values-on-the-gpu" title="Permalink to this headline">¶</a></h3>
<p>After generating the difference image, we have to add up all the per-pixel differences
to create a single number that will tell us how far apart the images are. On the CPU,
such operation can be trivially implemented by iterating over the elements and adding
their values to a single accumulator. Unfortunately, this linear complexity algorithm
is sequential in nature and therefore does not map well to GPU hardware. In order to
exploit its massive parallel processing capabilities we implement the sum operation
with a pyramidal method that requires multiple render passes, but is fully parallelizable
and also linear in nature.</p>
<a class="reference internal image-reference" href="_images/image_proc_decimation.png"><img alt="_images/image_proc_decimation.png" src="_images/image_proc_decimation.png" style="width: 589.0px; height: 294.0px;" /></a>
<p>Every pass of the parallel sum algorithm creates a texture that is half the size of the input
texture and contains pixels that are sums of the local <em>2x2</em> pixel neighborhood from the input
(see the above figure). These partial sum textures are further decimated in subsequent passes
until the texture size of <em>1x1</em> is reached. The final texel contains the sum of all pixel
values from the input.</p>
<p>The vertex/pixel shader pair that implements this algorithm is defined as:</p>
<ul>
<li><p class="first">Copy the code below to <tt class="docutils literal"><span class="pre">assets/accum4.vert</span></tt></p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// vertex position</span>
<span class="n">attribute</span> <span class="n">vec2</span> <span class="n">aPosition</span><span class="p">;</span>
<span class="c1">// vertex coordinate inside the texture</span>
<span class="n">attribute</span> <span class="n">vec2</span> <span class="n">aTexCoord</span><span class="p">;</span>
<span class="c1">// transformation matrix</span>
<span class="n">uniform</span> <span class="n">mat4</span> <span class="n">uTransformMatrix</span><span class="p">;</span>
<span class="c1">// a distance of half a texel in normalized texture coordinates</span>
<span class="n">uniform</span> <span class="n">vec2</span> <span class="n">uHalfTexelSize</span><span class="p">;</span>
<span class="c1">// per-pixel coordinate of (0,0) and (1,0) neighbors inside the input texture</span>
<span class="n">varying</span> <span class="n">vec4</span> <span class="n">vTexCoord0</span><span class="p">;</span>
<span class="c1">// per-pixel coordinate of (0,1) and (1,1) neighbors inside the input texture</span>
<span class="n">varying</span> <span class="n">vec4</span> <span class="n">vTexCoord1</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
   <span class="c1">// construct texture coordinates pointing the 2x2 texel neighborhood in input</span>
   <span class="c1">// texture corresponding to every output texture pixel.</span>
   <span class="c1">// Output texture has half the size of the input texture</span>

   <span class="n">vTexCoord0</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span> <span class="n">aTexCoord</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">uHalfTexelSize</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">aTexCoord</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">uHalfTexelSize</span><span class="p">.</span><span class="n">y</span><span class="p">,</span>
                      <span class="n">aTexCoord</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">uHalfTexelSize</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">aTexCoord</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">uHalfTexelSize</span><span class="p">.</span><span class="n">y</span> <span class="p">);</span>
   <span class="n">vTexCoord1</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span> <span class="n">aTexCoord</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">uHalfTexelSize</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">aTexCoord</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">uHalfTexelSize</span><span class="p">.</span><span class="n">y</span><span class="p">,</span>
                      <span class="n">aTexCoord</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">uHalfTexelSize</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">aTexCoord</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">uHalfTexelSize</span><span class="p">.</span><span class="n">y</span> <span class="p">);</span>

   <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">uTransformMatrix</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aPosition</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">aPosition</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p class="first">Copy the code below to <tt class="docutils literal"><span class="pre">assets/accum4.frag</span></tt></p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">precision</span> <span class="n">mediump</span> <span class="kt">float</span><span class="p">;</span>
<span class="c1">// input texture handler</span>
<span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">uBaseTex</span><span class="p">;</span>
<span class="c1">// per-pixel coordinate of (0,0) and (1,0) neighbors inside the input texture</span>
<span class="n">varying</span> <span class="n">vec4</span> <span class="n">vTexCoord0</span><span class="p">;</span>
<span class="c1">// per-pixel coordinate of (0,1) and (1,1) neighbors inside the input texture</span>
<span class="n">varying</span> <span class="n">vec4</span> <span class="n">vTexCoord1</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
   <span class="c1">// fetch 2x2 texels</span>
   <span class="n">vec4</span> <span class="n">p00</span> <span class="o">=</span> <span class="n">texture2D</span><span class="p">(</span> <span class="n">uBaseTex</span><span class="p">,</span> <span class="n">vTexCoord0</span><span class="p">.</span><span class="n">st</span> <span class="p">);</span>
   <span class="n">vec4</span> <span class="n">p10</span> <span class="o">=</span> <span class="n">texture2D</span><span class="p">(</span> <span class="n">uBaseTex</span><span class="p">,</span> <span class="n">vTexCoord0</span><span class="p">.</span><span class="n">pq</span> <span class="p">);</span>
   <span class="n">vec4</span> <span class="n">p01</span> <span class="o">=</span> <span class="n">texture2D</span><span class="p">(</span> <span class="n">uBaseTex</span><span class="p">,</span> <span class="n">vTexCoord1</span><span class="p">.</span><span class="n">st</span> <span class="p">);</span>
   <span class="n">vec4</span> <span class="n">p11</span> <span class="o">=</span> <span class="n">texture2D</span><span class="p">(</span> <span class="n">uBaseTex</span><span class="p">,</span> <span class="n">vTexCoord1</span><span class="p">.</span><span class="n">pq</span> <span class="p">);</span>

   <span class="c1">// write out their scaled sum</span>
    <span class="n">gl_FragColor</span> <span class="o">=</span> <span class="p">(</span> <span class="n">p00</span> <span class="o">+</span> <span class="n">p10</span> <span class="o">+</span> <span class="n">p01</span> <span class="o">+</span> <span class="n">p11</span> <span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
<p>Note that in the pixel shader we sum up four neighbors, but output only half of their actual sum.
This is because the destination texture for the partial sum is stored in 8-bits per channel
precision and values above 255 (normalized to 1.0) get clipped to 1.0. Scaling down the
results before write-out reduces the saturation effects, but also slightly lowers the
precision of the final sum. Now, time for the complete GPGPU image similarity measure function:</p>
<ul>
<li><p class="first">Copy the code below into the <tt class="docutils literal"><span class="pre">ApplicationGPGPU</span></tt> class definition (inside <tt class="docutils literal"><span class="pre">ApplicationGPGPU.h</span></tt>)</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// down-scale and accumulate the difference image before downloading to system memory</span>
<span class="kt">float</span> <span class="nf">getImageSimilarityMeasure</span><span class="p">(</span> <span class="n">Math</span><span class="o">::</span><span class="n">Matrix4x4f</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">transformMatrix</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// generate difference image</span>
    <span class="n">generateDifferenceImage</span><span class="p">(</span> <span class="n">transformMatrix</span> <span class="p">);</span>
    <span class="c1">// bind the FBO</span>
    <span class="n">glBindFramebuffer</span><span class="p">(</span> <span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">mFBO</span> <span class="p">);</span>
    <span class="c1">// activate the accumulation fragment program</span>
    <span class="n">glUseProgram</span><span class="p">(</span> <span class="n">mAccumProgram</span> <span class="p">);</span>
    <span class="n">glViewport</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mSourceImageWidth</span><span class="p">,</span> <span class="n">mSourceImageHeight</span> <span class="p">);</span>

    <span class="c1">// setup uniforms</span>
    <span class="n">glUniform2f</span><span class="p">(</span> <span class="n">glGetUniformLocation</span><span class="p">(</span> <span class="n">mAccumProgram</span><span class="p">,</span> <span class="s">&quot;uHalfTexelSize&quot;</span> <span class="p">),</span> <span class="mf">0.5f</span> <span class="o">/</span> <span class="n">mSourceImageWidth</span><span class="p">,</span>
                 <span class="mf">0.5f</span> <span class="o">/</span> <span class="n">mSourceImageHeight</span> <span class="p">);</span>

    <span class="n">glActiveTexture</span> <span class="p">(</span><span class="n">GL_TEXTURE0</span><span class="p">);</span>
    <span class="n">glUniform1i</span><span class="p">(</span> <span class="n">glGetUniformLocation</span><span class="p">(</span> <span class="n">mAccumProgram</span><span class="p">,</span> <span class="s">&quot;uBaseTex&quot;</span> <span class="p">),</span> <span class="mi">0</span> <span class="p">);</span>

    <span class="n">GLuint</span> <span class="n">srcTexture</span> <span class="o">=</span> <span class="n">mImageDiffTexture</span><span class="p">;</span>
    <span class="n">GLuint</span> <span class="n">dstTexture</span> <span class="o">=</span> <span class="n">mTempTexture1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">srcWidth</span>   <span class="o">=</span> <span class="n">mSourceImageWidth</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">srcHeight</span>  <span class="o">=</span> <span class="n">mSourceImageHeight</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">dstScale</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>

    <span class="c1">// ping-pong style accumulation</span>
    <span class="k">while</span><span class="p">(</span> <span class="n">srcWidth</span> <span class="o">&gt;</span> <span class="n">MAX_TEXTURE_SIZE</span> <span class="o">&amp;&amp;</span> <span class="n">srcHeight</span> <span class="o">&gt;</span> <span class="n">MAX_TEXTURE_SIZE</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// attach output texture to the framebuffer</span>
        <span class="n">glFramebufferTexture2D</span><span class="p">(</span> <span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_COLOR_ATTACHMENT0</span><span class="p">,</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">dstTexture</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>

        <span class="c1">// setup uniforms</span>
        <span class="n">glBindTexture</span><span class="p">(</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">srcTexture</span> <span class="p">);</span>

        <span class="c1">// set transformation matrix</span>
        <span class="n">Math</span><span class="o">::</span><span class="n">Matrix4x4f</span> <span class="n">viewMatrix</span><span class="p">;</span>
        <span class="n">viewMatrix</span><span class="p">.</span><span class="n">setScale</span><span class="p">(</span> <span class="n">dstScale</span> <span class="p">);</span>
        <span class="n">viewMatrix</span><span class="p">.</span><span class="n">applyTranslate</span><span class="p">(</span> <span class="o">-</span><span class="mf">1.0f</span> <span class="p">);</span>
        <span class="n">glUniformMatrix4fv</span><span class="p">(</span> <span class="n">glGetUniformLocation</span><span class="p">(</span> <span class="n">mAccumProgram</span><span class="p">,</span> <span class="s">&quot;uTransformMatrix&quot;</span> <span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">viewMatrix</span><span class="p">.</span><span class="n">mData</span> <span class="p">);</span>

        <span class="c1">// render difference image into a texture</span>
        <span class="n">drawQuad</span><span class="p">(</span> <span class="n">mAccumProgram</span><span class="p">,</span> <span class="n">dstScale</span> <span class="p">);</span>

        <span class="c1">// swap source with destination textures</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">dstTexture</span> <span class="o">==</span> <span class="n">mTempTexture1</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">srcTexture</span> <span class="o">=</span> <span class="n">mTempTexture1</span><span class="p">;</span>
            <span class="n">dstTexture</span> <span class="o">=</span> <span class="n">mTempTexture2</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">srcTexture</span> <span class="o">=</span> <span class="n">mTempTexture2</span><span class="p">;</span>
            <span class="n">dstTexture</span> <span class="o">=</span> <span class="n">mTempTexture1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// next source texture will have dimensions of current destination</span>
        <span class="n">srcWidth</span>  <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">srcHeight</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>

        <span class="c1">// scale down the next destination</span>
        <span class="n">dstScale</span> <span class="o">*=</span> <span class="mf">0.5f</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// output final pass to the RBO and read-back results</span>

    <span class="c1">// attach RBO to the FBO for final output</span>
    <span class="n">glFramebufferRenderbuffer</span><span class="p">(</span> <span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_COLOR_ATTACHMENT0</span><span class="p">,</span> <span class="n">GL_RENDERBUFFER</span><span class="p">,</span> <span class="n">mRBO</span> <span class="p">);</span>

    <span class="c1">// last accumulation shader call</span>
    <span class="n">glBindTexture</span><span class="p">(</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">srcTexture</span> <span class="p">);</span>

    <span class="c1">// set transformation matrix</span>
    <span class="n">Math</span><span class="o">::</span><span class="n">Matrix4x4f</span> <span class="n">viewMatrix</span><span class="p">;</span>
    <span class="n">viewMatrix</span><span class="p">.</span><span class="n">setScale</span><span class="p">(</span> <span class="n">dstScale</span> <span class="p">);</span>
    <span class="n">viewMatrix</span><span class="p">.</span><span class="n">applyTranslate</span><span class="p">(</span> <span class="o">-</span><span class="mf">1.0f</span> <span class="p">);</span>
    <span class="n">glUniformMatrix4fv</span><span class="p">(</span> <span class="n">glGetUniformLocation</span><span class="p">(</span> <span class="n">mAccumProgram</span><span class="p">,</span> <span class="s">&quot;uTransformMatrix&quot;</span> <span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">viewMatrix</span><span class="p">.</span><span class="n">mData</span> <span class="p">);</span>

    <span class="c1">// render difference image into a texture</span>
    <span class="n">drawQuad</span><span class="p">(</span> <span class="n">mAccumProgram</span><span class="p">,</span> <span class="n">dstScale</span> <span class="p">);</span>

    <span class="c1">// next source texture will have dimensions of current destination</span>
    <span class="n">srcWidth</span>  <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">srcHeight</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>

    <span class="c1">// read the result back from the current texture attached to the framebuffer</span>
    <span class="n">Image</span><span class="o">&lt;</span><span class="n">IPF_argb32</span><span class="o">&gt;</span> <span class="n">image</span><span class="p">(</span> <span class="n">srcWidth</span><span class="p">,</span> <span class="n">srcHeight</span> <span class="p">);</span>
    <span class="n">glReadPixels</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">srcWidth</span><span class="p">,</span> <span class="n">srcHeight</span><span class="p">,</span> <span class="n">GL_RGBA</span><span class="p">,</span> <span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span> <span class="n">image</span><span class="p">.</span><span class="n">getRawPointer</span><span class="p">()</span> <span class="p">);</span>

    <span class="c1">// here we store the final accumulated difference between images</span>
    <span class="kt">float</span> <span class="n">diff</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
    <span class="c1">// sum up pixel differences over RGB channels</span>
    <span class="kt">int</span> <span class="n">isize</span> <span class="o">=</span> <span class="n">srcWidth</span> <span class="o">*</span> <span class="n">srcHeight</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">isize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ImagePixelARGB32</span> <span class="n">pixel</span><span class="p">(</span> <span class="n">image</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">);</span>
        <span class="n">diff</span> <span class="o">+=</span> <span class="n">pixel</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">diff</span> <span class="o">+=</span> <span class="n">pixel</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
        <span class="n">diff</span> <span class="o">+=</span> <span class="n">pixel</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="c1">// normalize by the number of accumulated samples</span>
    <span class="n">diff</span> <span class="o">/=</span> <span class="n">isize</span> <span class="o">*</span> <span class="mi">3</span><span class="p">;</span>

    <span class="c1">// unbind FBO</span>
    <span class="n">glBindFramebuffer</span><span class="p">(</span> <span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>

    <span class="c1">// restore the default viewport size</span>
    <span class="n">glViewport</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mEgl</span><span class="o">-&gt;</span><span class="n">getWidth</span><span class="p">(),</span> <span class="n">mEgl</span><span class="o">-&gt;</span><span class="n">getHeight</span><span class="p">()</span> <span class="p">);</span>

    <span class="k">return</span> <span class="n">diff</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
<p>Another important point to note is that we limit the number of render passes until the point we reach
a partial sum texture of certain size (i.e., <tt class="docutils literal"><span class="pre">MAX_TEXTURE_SIZE</span></tt> is set to 32 pixels by default).
The reason for that is twofold. First, the cost of issuing a draw call is constant and independent
of the texture size. For very small textures, it is much faster to compute the final sum on the CPU
rather than call the decimation shaders until we reach <em>1x1</em> partial texture size. Second, the final
accumulated difference is more precise when computed on the CPU, since we can use floating point precision
accumulator, as opposed to low bit-depth of the texture.</p>
<p>This step completes the compute part of the application. Now, to successfully run the project on
your Tegra device, we still need a function that handles the initalization of all intermediate
textures, shaders and FBOs:</p>
<ul>
<li><p class="first">Copy the code below into the <tt class="docutils literal"><span class="pre">ApplicationGPGPU</span></tt> class definition (inside <tt class="docutils literal"><span class="pre">ApplicationGPGPU.h</span></tt>)</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">static</span> <span class="kt">void</span> <span class="nf">RevertColorChannels</span><span class="p">(</span> <span class="n">Image</span><span class="o">&lt;</span><span class="n">IPF_argb32</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">bitmap</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// converts BGRA to ARGB and back</span>
    <span class="c1">// we need it to convert between OpenGL and Windows Bitmap pixel formats</span>
    <span class="kt">int</span> <span class="n">isize</span> <span class="o">=</span> <span class="n">bitmap</span><span class="p">.</span><span class="n">getWidth</span><span class="p">()</span> <span class="o">*</span> <span class="n">bitmap</span><span class="p">.</span><span class="n">getHeight</span><span class="p">();</span>
    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">isize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ImagePixelARGB32</span> <span class="n">pixel</span><span class="p">(</span> <span class="n">bitmap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">);</span>
        <span class="n">bitmap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ImagePixelARGB32</span><span class="p">(</span> <span class="n">pixel</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pixel</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pixel</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">255</span> <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">loadResources</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// initialize the NVIDIA bitfonts</span>
    <span class="n">NvBool</span> <span class="n">fontSplit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fontFile</span> <span class="o">=</span> <span class="s">&quot;utahcond+bold_1024.dds&quot;</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">NVBFInitialize</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fontFile</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fontSplit</span><span class="p">,</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">LOG</span><span class="p">(</span> <span class="s">&quot;could not initialize NvBitFont!&quot;</span> <span class="p">);</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// allocate the text for the clock and set its properties</span>
    <span class="n">mClockText</span> <span class="o">=</span> <span class="n">NVBFTextAlloc</span><span class="p">();</span>
    <span class="n">NVBFTextSetFont</span><span class="p">(</span> <span class="n">mClockText</span><span class="p">,</span> <span class="mi">1</span> <span class="p">);</span> <span class="c1">// should look up by font file name.</span>
    <span class="n">NVBFTextSetSize</span><span class="p">(</span> <span class="n">mClockText</span><span class="p">,</span> <span class="mi">32</span> <span class="p">);</span>
    <span class="n">NVBFTextCursorAlign</span><span class="p">(</span> <span class="n">mClockText</span><span class="p">,</span> <span class="n">NVBF_ALIGN_LEFT</span><span class="p">,</span> <span class="n">NVBF_ALIGN_TOP</span> <span class="p">);</span>
    <span class="n">NVBFTextCursorPos</span><span class="p">(</span> <span class="n">mClockText</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span> <span class="p">);</span>
    <span class="n">NVBFTextSetColor</span><span class="p">(</span> <span class="n">mClockText</span><span class="p">,</span> <span class="n">NV_PC_PREDEF_WHITE</span> <span class="p">);</span>
    <span class="n">NVBFTextSetShadow</span><span class="p">(</span> <span class="n">mClockText</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">NV_PC_PREDEF_BLACK</span> <span class="p">);</span>

    <span class="c1">// load test image</span>
    <span class="n">glGenTextures</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mSourceImageTexture</span> <span class="p">);</span>
    <span class="n">glBindTexture</span><span class="p">(</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">mSourceImageTexture</span> <span class="p">);</span>
    <span class="n">glTexParameteri</span><span class="p">(</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span> <span class="p">);</span>
    <span class="n">glTexParameteri</span><span class="p">(</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span> <span class="p">);</span>
    <span class="n">glTexParameteri</span><span class="p">(</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span> <span class="p">);</span>
    <span class="n">glTexParameteri</span><span class="p">(</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span> <span class="p">);</span>
    <span class="p">{</span>
        <span class="n">Image</span><span class="o">&lt;</span><span class="n">IPF_argb32</span><span class="o">&gt;</span> <span class="n">bitmap</span><span class="p">;</span>
        <span class="n">bitmap</span><span class="p">.</span><span class="n">loadImage</span><span class="p">(</span> <span class="s">&quot;lena.bmp&quot;</span> <span class="p">);</span>

        <span class="c1">// convert texture BGRA to RGBA OpenGL texture format</span>
        <span class="n">RevertColorChannels</span><span class="p">(</span> <span class="n">bitmap</span> <span class="p">);</span>

        <span class="n">mSourceImageWidth</span> <span class="o">=</span> <span class="n">bitmap</span><span class="p">.</span><span class="n">getWidth</span><span class="p">();</span>
        <span class="n">mSourceImageHeight</span> <span class="o">=</span> <span class="n">bitmap</span><span class="p">.</span><span class="n">getHeight</span><span class="p">();</span>
        <span class="n">LOG</span><span class="p">(</span> <span class="s">&quot;loaded %ix%i input image&quot;</span><span class="p">,</span> <span class="n">mSourceImageWidth</span><span class="p">,</span> <span class="n">mSourceImageHeight</span> <span class="p">);</span>

        <span class="n">glTexImage2D</span><span class="p">(</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGBA</span><span class="p">,</span> <span class="n">mSourceImageWidth</span><span class="p">,</span> <span class="n">mSourceImageHeight</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGBA</span><span class="p">,</span>
                      <span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span> <span class="n">bitmap</span><span class="p">.</span><span class="n">getRawPointer</span><span class="p">()</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// setup output diff texture</span>
    <span class="n">glGenTextures</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mImageDiffTexture</span> <span class="p">);</span>
    <span class="n">glBindTexture</span><span class="p">(</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">mImageDiffTexture</span> <span class="p">);</span>
    <span class="n">glTexParameteri</span><span class="p">(</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_NEAREST</span> <span class="p">);</span>
    <span class="n">glTexParameteri</span><span class="p">(</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_NEAREST</span> <span class="p">);</span>
    <span class="n">glTexParameteri</span><span class="p">(</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span> <span class="p">);</span>
    <span class="n">glTexParameteri</span><span class="p">(</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span> <span class="p">);</span>
    <span class="n">glTexImage2D</span><span class="p">(</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGBA</span><span class="p">,</span> <span class="n">mSourceImageWidth</span><span class="p">,</span> <span class="n">mSourceImageHeight</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGBA</span><span class="p">,</span> <span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>

    <span class="c1">// setup temporary texture for accumulated difference image</span>
    <span class="n">glGenTextures</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mTempTexture1</span> <span class="p">);</span>
    <span class="n">glBindTexture</span><span class="p">(</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">mTempTexture1</span> <span class="p">);</span>
    <span class="n">glTexParameteri</span><span class="p">(</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_NEAREST</span> <span class="p">);</span>
    <span class="n">glTexParameteri</span><span class="p">(</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_NEAREST</span> <span class="p">);</span>
    <span class="n">glTexParameteri</span><span class="p">(</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span> <span class="p">);</span>
    <span class="n">glTexParameteri</span><span class="p">(</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span> <span class="p">);</span>
    <span class="n">glTexImage2D</span><span class="p">(</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGBA</span><span class="p">,</span> <span class="n">mSourceImageWidth</span><span class="p">,</span> <span class="n">mSourceImageHeight</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGBA</span><span class="p">,</span> <span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>

    <span class="n">glGenTextures</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mTempTexture2</span> <span class="p">);</span>
    <span class="n">glBindTexture</span><span class="p">(</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">mTempTexture2</span> <span class="p">);</span>
    <span class="n">glTexParameteri</span><span class="p">(</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_NEAREST</span> <span class="p">);</span>
    <span class="n">glTexParameteri</span><span class="p">(</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_NEAREST</span> <span class="p">);</span>
    <span class="n">glTexParameteri</span><span class="p">(</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span> <span class="p">);</span>
    <span class="n">glTexParameteri</span><span class="p">(</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span> <span class="p">);</span>
    <span class="n">glTexImage2D</span><span class="p">(</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGBA</span><span class="p">,</span> <span class="n">mSourceImageWidth</span><span class="p">,</span> <span class="n">mSourceImageHeight</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGBA</span><span class="p">,</span> <span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>

    <span class="c1">// init shader loader</span>
    <span class="n">nv_shader_init</span><span class="p">(</span> <span class="n">mNativeAppInstance</span><span class="o">-&gt;</span><span class="n">activity</span><span class="o">-&gt;</span><span class="n">assetManager</span> <span class="p">);</span>

    <span class="c1">// load image warping shader</span>
    <span class="n">mWarpedDiffProgram</span> <span class="o">=</span> <span class="n">nv_load_program</span><span class="p">(</span> <span class="s">&quot;warped_diff&quot;</span> <span class="p">);</span>
    <span class="c1">// load difference accumulation shader</span>
    <span class="n">mAccumProgram</span> <span class="o">=</span> <span class="n">nv_load_program</span><span class="p">(</span> <span class="s">&quot;accum4&quot;</span> <span class="p">);</span>
    <span class="c1">// load shader drawing textured quad</span>
    <span class="n">mPlainTextureProgram</span> <span class="o">=</span> <span class="n">nv_load_program</span><span class="p">(</span> <span class="s">&quot;plain_tex&quot;</span> <span class="p">);</span>
    <span class="c1">// load shader drawing color filled quad</span>
    <span class="n">mPlainColorProgram</span> <span class="o">=</span> <span class="n">nv_load_program</span><span class="p">(</span> <span class="s">&quot;plain_col&quot;</span> <span class="p">);</span>

    <span class="c1">// setup OpenGL</span>
    <span class="n">glDisable</span><span class="p">(</span> <span class="n">GL_CULL_FACE</span> <span class="p">);</span>
    <span class="n">glDisable</span><span class="p">(</span> <span class="n">GL_BLEND</span> <span class="p">);</span>

    <span class="c1">// create FBO</span>
    <span class="n">glGenFramebuffers</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mFBO</span> <span class="p">);</span>

    <span class="c1">// create and configure RBO</span>
    <span class="n">glGenRenderbuffers</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mRBO</span> <span class="p">);</span>
    <span class="n">glBindRenderbuffer</span><span class="p">(</span> <span class="n">GL_RENDERBUFFER</span><span class="p">,</span> <span class="n">mRBO</span> <span class="p">);</span>
    <span class="n">glRenderbufferStorage</span><span class="p">(</span> <span class="n">GL_RENDERBUFFER</span><span class="p">,</span> <span class="n">GL_RGBA8_OES</span><span class="p">,</span> <span class="n">mSourceImageWidth</span><span class="p">,</span> <span class="n">mSourceImageHeight</span> <span class="p">);</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="fcamerapro.html" title="The FCameraPro application"
             >next</a> |</li>
        <li class="right" >
          <a href="fcam.html" title="Camera Control using the FCam API"
             >previous</a> |</li>
        <li><a href="index.html">home</a>|&nbsp;</li>
        <li><a href="search.html">search</a>|&nbsp;</li>
 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, NVIDIA Research - Mobile Visual Computing.
      Last updated on Jun 13, 2013.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>
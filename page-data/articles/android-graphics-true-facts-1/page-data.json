{
  "componentChunkName": "component---src-templates-post-js",
  "path": "/articles/android-graphics-true-facts-1/",
  "result": {
    "data": {
      "markdownRemark": {
        "frontmatter": {
          "title": "How about some Android graphics true facts? (Part 1 of 2)",
          "authors": [{ "id": "hackbod", "name": "Dianne Hackborn" }],
          "date": "2020-07-16T00:00:00.000Z",
          "date_pretty": "July 16th, 2020",
          "date_from_now": "2 years ago",
          "last_modified_at": null,
          "last_modified_at_from_now": null,
          "path": "/articles/android-graphics-true-facts-1/",
          "author": null,
          "excerpt": "A fantastic Google+ post by Dianne Hackborn (framework engineer on Android) explained the ins and outs of Android's hardware acceleration.",
          "tags": ["Android", "Graphics"],
          "image": {
            "childImageSharp": {
              "fluid": {
                "aspectRatio": 1.7741935483870968,
                "src": "/static/4e922c5dabc4c979d3900335c978fad7/fc20c/android-logo.jpg",
                "srcSet": "/static/4e922c5dabc4c979d3900335c978fad7/6e883/android-logo.jpg 275w,\n/static/4e922c5dabc4c979d3900335c978fad7/a09ef/android-logo.jpg 550w,\n/static/4e922c5dabc4c979d3900335c978fad7/fc20c/android-logo.jpg 1100w,\n/static/4e922c5dabc4c979d3900335c978fad7/5d6ff/android-logo.jpg 1650w,\n/static/4e922c5dabc4c979d3900335c978fad7/4fb49/android-logo.jpg 1920w",
                "sizes": "(max-width: 1100px) 100vw, 1100px"
              },
              "fixed": {
                "src": "/static/4e922c5dabc4c979d3900335c978fad7/fc20c/android-logo.jpg",
                "height": 619,
                "width": 1100
              }
            }
          },
          "toc": true,
          "comments": true,
          "comments_locked": true,
          "hide_meta": null
        },
        "id": "3b8705d0-d841-5764-8737-cc5651cdb1a3",
        "html": "<p><em>Original published at <a href=\"https://plus.google.com/105051985738280261832/posts/2FXDCz8x93s\">https://plus.google.com/105051985738280261832/posts/2FXDCz8x93s</a></em></p>\n<p>(Edit: there have been a number of comments treating this as being written as an excuse for Android or not mattering to users or such. I’d just like to clarify that I wrote this solely to address a lot of incorrect information that I see posted around the web as truth. This is no attempt to excuse anything, and it is solely for those who already have an interest in writing and reading the often factually incorrect technical information out there.)</p>\n<p>I get tired of seeing so much misinformation posted and repeated all over the place about how graphics rendering works on Android. Here is some truth:</p>\n<p>• Android has always used some hardware accelerated drawing. Since before 1.0 all window compositing to the display has been done with hardware.</p>\n<p>• This means that many of the animations you see have always been hardware accelerated: menus being shown, sliding the notification shade, transitions between activities, pop-ups and dialogs showing and hiding, etc.</p>\n<p>• Android did historically use software to render the contents of each window. For example in a UI<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup> like</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 461px; background-color: var(--input-background-color);\"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 166.54545454545456%; position: relative; bottom: 0; left: 0; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image lazyload\"\n        alt=\"alt text\"\n        title=\"alt text\"\n        data-src=\"/static/8344e155d6a3b0048e2259fd36e1e54e/9b127/2-home-menu.png\"\n        data-srcset=\"/static/8344e155d6a3b0048e2259fd36e1e54e/39133/2-home-menu.png 275w,\n/static/8344e155d6a3b0048e2259fd36e1e54e/9b127/2-home-menu.png 461w\"\n        sizes=\"(max-width: 461px) 100vw, 461px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p> there are four windows: the status bar, the wallpaper, the launcher on top of the wallpaper, and the menu. If one of the windows updates its contents, such as highlighting a menu item, then (prior to 3.0) software is used to draw the new contents of that window; however none of the other windows are redrawn at all, and the re-composition of the windows is done in hardware. Likewise, any movement of the windows such as the menu going up and down is all hardware rendering.</p>\n<p>• Looking at drawing inside of a window, you don’t necessarily need to do this in hardware to achieve full 60fps rendering. This depends very much on the number of pixels in your display and the speed of your CPU. For example, Nexus S has no trouble doing 60fps rendering of all the normal stuff you see in the Android UI like scrolling lists on its 800x480 screen. The original Droid however struggled with a similar screen resolution.</p>\n<p>• “Full” hardware accelerated drawing within a window was added in Android 3.0. The implementation in Android 4.0 is not any more full than in 3.0. Starting with 3.0, if you set the flag in your app saying that hardware accelerated drawing is allowed, then all drawing to the application’s windows will be done with the GPU. The main change in this regard in Android 4.0 is that now apps that are explicitly targeting 4.0 or higher will have acceleration enabled by default rather than having to put android:handwareAccelerated=“true” in their manifest. (And the reason this isn’t just turned on for all existing applications is that some types of drawing operations can’t be supported well in hardware and it also impacts the behavior when an application asks to have a part of its UI updated. Forcing hardware accelerated drawing upon existing apps will break a significant number of them, from subtly to significantly.)</p>\n<p>• Hardware accelerated drawing is not all full of win. For example on the PVR drivers of devices like the Nexus S and Galaxy Nexus, simply starting to use OpenGL in a process eats about 8MB of RAM. Given that our process overhead is about 2MB, this is pretty huge. That RAM takes away from other things, such as the number of background processes that can be kept running, potentially slowing down things like app switching.</p>\n<p>• Because of the overhead of OpenGL, one may very well not want to use it for drawing. For example some of the work we are doing to make Android 4.0 run well on the Nexus S has involved turning off hardware accelerated drawing in parts of the UI so we don’t lose 8MB of RAM in the system process, another 8MB in the phone process, another 8MB in the system UI process, etc. Trust me, you won’t notice – there is just no benefit on that device in using OpenGL to draw something like the status bar, even with fancy animations going on in there.</p>\n<p>• Hardware accelerated drawing is not a magical silver bullet to butter-smooth UI. There are many different efforts that have been going on towards this, such as improved scheduling of foreground vs. background threads in 1.6, rewriting the input system in 2.3, strict mode, concurrent garbage collection, loaders, etc. If you want to achieve 60fps, you have 20 milliseconds to handle each frame. This is not a lot of time. Just touching the flash storage system in the thread that is running the UI can in some cases introduce a delay that puts you out of that timing window, especially if you are writing to storage.</p>\n<p>• A recent example of the kinds of interesting things that impact UI smoothness: we noticed that ICS on Nexus S was actually less smooth when scrolling through lists than it was on Gingerbread. It turned out that the reason for this was due to subtle changes in timing, so that sometimes in ICS as the app was retrieving touch events and drawing the screen, it would go to get the next event slightly before it was ready, causing it to visibly miss a frame while tracking the finger even though it was drawing the screen at a solid 60fps. (Edit: for those who need this made clear, yes of course this particular issue is fixed.)</p>\n<p>• When people have historically compared web browser scrolling between Android and iOS, most of the differences they are seeing are not due to hardware accelerated drawing. Originally Android went a different route for its web page rendering and made different compromises: the web page is turned in to a display list, which is continually rendered to the screen, instead of using tiles. This has the benefit that scrolling and zooming never have artifacts of tiles that haven’t yet been drawn. Its downside is that as the graphics on the web page get more complicated to draw the frame rate goes down. As of Android 3.0, the browser now uses tiles, so it can maintain a consistent frame rate as you scroll or zoom, with the negative of having artifacts when newly needed tiles can’t be rendered quickly enough. The tiles themselves are rendered in software, which I believe is the case for iOS as well. (And this tile-based approach could be used prior to 3.0 without hardware accelerated drawing; as mentioned previously, the Nexus S CPU can easily draw the tiles to the window at 60fps.)</p>\n<p>• Hardware accleration does not magically make drawing performance problems disappear. There is still a limit to how much the GPU can do. A recent interesting example of this is tablets built with Tegra 2 – that GPU can touch every pixel of a 1280x800 screen about 2.5 times at 60fps. Now consider the Android 3.0 tablet home screen where you are switching to the all apps list: you need to draw the background (1x all pixels), then the layer of shortcuts and widgets (let’s be nice and say this is .5x all pixels), then the black background of all apps (1x all pixels), and the icons and labels of all apps (.5x all pixels). We’ve already blown our per-pixel budget, and we haven’t even composited the separate windows to the final display yet. To get 60fps animation, Android 3.0 and later use a number of tricks. A big one is that it tries to put all windows into overlays instead of having to copy them to the framebuffer with the GPU. In the case here even with that we are still over-budget, but we have another trick: because the wallpaper on Android is in a separate window, we can make this window larger than the screen to hold the entire bitmap. Now, as you scroll, the movement of the background doesn’t require any drawing, just moving its window… and because this window is in an overlay, it doesn’t even need to be composited to the screen with the GPU.</p>\n<p>• As device screen resolution goes up, achieving a 60fps UI is closely related to GPU speed and especially the GPU’s memory bus bandwidth. In fact, if you want to get an idea of the performance of a piece of hardware, always pay close attention to the memory bus bandwidth. There are plenty of times where the CPU (especially with those wonderful NEON instructions) can go a lot faster than the memory bus.</p>\n<p>EDIT:</p>\n<p>Wow this has generated a lot more discussion, and I won’t be able to address nearly everything that has been raised. But I’ll try to expand on things a bit here to better address what I think are some of the more interesting points.</p>\n<p>Some have raised points along the lines of Samsung Galaxy S2 phones already having a smoother UI and indicating that they are doing something different vs. the Galaxy Nexus. When comparing individual devices though you really need to look at all of the factors. For example, the S2’s screen is 480x800 vs. the Galaxy Nexus at 720x1280. If the Nexus S could already do 60fps for simple UIs on its 480x800, the CPU in the S2’s is even better off.</p>\n<p>The real important difference between these two screens is just that the Galaxy Nexus has 2.4x as many pixels that need to be drawn as the S2. This means that to achieve the same efficiency at drawing the screen, you need a CPU that can run a single core at 2.4x the speed (and rendering a UI for a single app is essentially not parallelizable, so multiple cores isn’t going to save you).</p>\n<p>This is where hardware accelerated rendering really becomes important: as the number of pixels goes up, GPUs can generally scale much better to handle them, since they are more specialized at their task. In fact this was the primary incentive for implementing hardware accelerated drawing in Android – at 720x1280 we are well beyond the point where current ARM CPUs can provide 60fps. (And this is a reason to be careful about making comparisons between the Galaxy Nexus and other devices like the S2 – if you are running third party apps, there is a good chance today that the app is not enabling hardware acceleration, so your comparison is doing CPU rendering on the Galaxy Nexus which means you almost certainly aren’t going to get 60fps out of it, because it needs to hit 2.4x as many pixels as the S2 does.)</p>\n<p>To be complete, there is another big advantage that the GPU gives you – many more drawing effects become feasible. For example, if you are drawing a bitmap in software, you basically can’t do anything to it except apply an offset. Just trying to scale it is going to make rendering significantly slower. On a GPU, applying transformations well beyond simple scales is basically free. This is why in the new default Holo themes in Android we have background images – with hardware accelerated drawing, we can afford to draw (and scale) them. In fact, if the hardware path is not enabled by the app, these background images will be turned off.</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">\n<p><a href=\"http://www.simplemobilereview.com/wp-content/uploads/2010/12/2-home-menu.png\">http://www.simplemobilereview.com/wp-content/uploads/2010/12/2-home-menu.png</a></p>\n<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>",
        "excerpt": "Original published at https://plus.google.com/105051985738280261832/posts/2FXDCz8x93s (Edit: there have been a number of comments treating…",
        "timeToRead": 8,
        "tableOfContents": ""
      },
      "comments": { "edges": [] }
    },
    "pageContext": {
      "next": {
        "frontmatter": {
          "path": "/articles/android-graphics-true-facts-2/",
          "title": "How about some Android graphics true facts? (Part 2 of 2)",
          "authors": [{ "id": "hackbod", "name": "Dianne Hackborn" }],
          "categories": ["articles"],
          "tags": ["Android", "Graphics"]
        },
        "fileAbsolutePath": "/home/28041/opensource/github.com/tonykwok/made-mistakes-gatsby/src/posts/articles/How-about-some-Android-graphics-true-facts-continued.md"
      },
      "previous": {
        "frontmatter": {
          "path": "/articles/android-system-framework-architecture/",
          "title": "How should I design my Android application?",
          "authors": [{ "id": "hackbod", "name": "Dianne Hackborn" }],
          "categories": ["articles"],
          "tags": ["Android"]
        },
        "fileAbsolutePath": "/home/28041/opensource/github.com/tonykwok/made-mistakes-gatsby/src/posts/articles/How-should-I-design-my-Android-application.md"
      }
    }
  },
  "staticQueryHashes": ["215131063", "3443189517"]
}

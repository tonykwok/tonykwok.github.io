{
  "componentChunkName": "component---src-templates-post-js",
  "path": "/articles/android-graphics-true-facts-2/",
  "result": {
    "data": {
      "markdownRemark": {
        "frontmatter": {
          "title": "How about some Android graphics true facts? (Part 2 of 2)",
          "authors": [{ "id": "hackbod", "name": "Dianne Hackborn" }],
          "date": "2020-07-16T00:00:00.000Z",
          "date_pretty": "July 16th, 2020",
          "date_from_now": "2 years ago",
          "last_modified_at": null,
          "last_modified_at_from_now": null,
          "path": "/articles/android-graphics-true-facts-2/",
          "author": null,
          "excerpt": "A fantastic Google+ post by Dianne Hackborn (framework engineer on Android) explained the ins and outs of Android's hardware acceleration.",
          "tags": ["Android", "Graphics"],
          "image": {
            "childImageSharp": {
              "fluid": {
                "aspectRatio": 1.7741935483870968,
                "src": "/static/4e922c5dabc4c979d3900335c978fad7/fc20c/android-logo.jpg",
                "srcSet": "/static/4e922c5dabc4c979d3900335c978fad7/6e883/android-logo.jpg 275w,\n/static/4e922c5dabc4c979d3900335c978fad7/a09ef/android-logo.jpg 550w,\n/static/4e922c5dabc4c979d3900335c978fad7/fc20c/android-logo.jpg 1100w,\n/static/4e922c5dabc4c979d3900335c978fad7/5d6ff/android-logo.jpg 1650w,\n/static/4e922c5dabc4c979d3900335c978fad7/4fb49/android-logo.jpg 1920w",
                "sizes": "(max-width: 1100px) 100vw, 1100px"
              },
              "fixed": {
                "src": "/static/4e922c5dabc4c979d3900335c978fad7/fc20c/android-logo.jpg",
                "height": 619,
                "width": 1100
              }
            }
          },
          "toc": true,
          "comments": true,
          "comments_locked": true,
          "hide_meta": null
        },
        "id": "03f25d58-f1bc-5b79-b990-e6e306304a9e",
        "html": "<p><em>Original published at <a href=\"https://plus.google.com/u/0/105051985738280261832/posts/XAZ4CeVP6DC\">https://plus.google.com/u/0/105051985738280261832/posts/XAZ4CeVP6DC</a></em></p>\n<p>A few days ago I wrote a post trying to correct a lot of the inaccurate statements I have seen repeatedly mentioned about how graphics on Android works. This resulted in a lot of nice discussion, but unfortunately has also lead some people to come up with new, novel, and often technically inaccurate complaints about how Android works.</p>\n<p>These new topics have been more about some fundamental design decisions in Android, and why they are wrong. I‚Äôd like to help people better understand (and judge) these discussions by giving some real background on why Android‚Äôs UI was designed the way it is and how it actually works.</p>\n<p>One issue that has been raised is that Android doesn‚Äôt use thread priorities to reduce how much background work interrupts the user interface. This is outright wrong. It actually uses a number of priorities, which you can even find defined right here <a href=\"http://developer.android.com/reference/android/os/Process.html#THREAD_PRIORITY_AUDIO\">http://developer.android.com/reference/android/os/Process.html#THREAD_PRIORITY_AUDIO</a> in the SDK.</p>\n<p>The most important of these are the background and default priorities. User interface threads normally run at the default priority; background threads run in the background priority. Application processes that are in the background have all of their threads forced to the background priority.</p>\n<p>Android‚Äôs background priority is actually pretty interesting. It uses a Linux facility called cgroups to put all background threads into a special scheduling group which, all together, can‚Äôt use more than 10% of the CPU. That is, if you have 10 processes in the background all trying to run at the same time, when combined they can‚Äôt take away more than 10% of the time needed by foreground threads. This is enough to allow background threads to make some forward progress, without having enough of an impact on the foreground threads to be generally visible to the user.</p>\n<p>(You may have noticed that a ‚Äúforeground‚Äù priority is also defined. This is not used in current Android; it was in the original implementation, but we found that the Linux scheduler does not give enough preference to threads based on pure priority, so switched to cgroups in Android 1.6.)</p>\n<p>I have also seen a number of claims that the basic Android design is fundamentally flawed and archaic because it doesn‚Äôt use a rendering thread like iOS. There are certainly some advantages to how iOS work, but this view is too focused on one specific detail to be useful, and glosses over actual similarities in how they behave.</p>\n<p>Android had a number of very different original design goals than iOS did. A key goal of Android was to provide an open application platform, using application sandboxes to create a much more secure environment that doesn‚Äôt rely on a central authority to verify that applications do what they claim. To achieve this, it uses Linux process isolation and user IDs to prevent each application from being able to access the system or other application in ways that are not controlled and secure.</p>\n<p>This is very different from iOS‚Äôs original design constraints, which remember didn‚Äôt allow any third party applications at all.</p>\n<p>An important part of achieving this security is having a way for (EDIT: It has been pointed out to me that iOS does in fact use multiple windows and multiple GL contexts. Lesson to me, just don‚Äôt talk about anything I haven‚Äôt directly verified. üôÇ That still doesn‚Äôt change things for Android, though, where as I mention later we simply did not have hardware and drivers that could do multiple GL contexts until fairly recently.)\nindividual UI elements to share the screen in a secure way. This is why there are windows on Android. The status bar and its notification shade are windows owned and drawn by the system. These are separate from the application‚Äôs window, so the application can not touch anything about the status bar, such as to scrape the text of SMS messages as they are displayed there. Likewise the soft keyboard is a separate window, owned by a separate application, and it and the application can only interact with each other through a well defined and controlled interface. (This is also why Android can safely support third party input methods.)</p>\n<p>Another objective of Android was to allow close collaboration between applications, so that for example it is easy to implement a share API that launches a part of another application integrated with the original application‚Äôs flow. As part of this, Android applications traditionally are split into pieces (called ‚ÄúActivities‚Äù) that handle a single specific part of the UI of the application. For example, the contacts lists is one activity, the details of a contact is another, and editing a contact is a third. Moving between those parts of the contacts UI means switching between these activities, and each of these activities is its own separate window.</p>\n<p>Now we can see something interesting: in almost all of the places in the original Android UI where you see animations, you are actually seeing windows animate. Launching Contacts is an animation of the home screen window and the contacts list window. Tapping on a contact to see its details is an animation of the contacts list window and the contacts details window. Displaying the soft keyboard is an animation of the keyboard window. Showing the dialog where you pick an app to share with is an animation of a window displaying that dialog.</p>\n<p>When you see a window on screen, what you are seeing is actually something called a ‚Äúsurface‚Äù. This is a separate piece of shared memory that the window draws its UI in, and is composited with the other windows to the screen by a separate system service (in a separate thread, running at a higher than normal priority) called the ‚Äúsurface flinger.‚Äù Does this sound familiar? In fact this is very much like what iOS is doing with its views being composited by a separate thread, just at a less fine-grained but significantly more secure level. (And this window composition has been hardware accelerated in Android from the beginning.)</p>\n<p>The other main interesting interaction in the UI is tracking your finger ‚Äî scrolling and flinging a list, swiping a gallery, etc. These interactions involve updating the contents inside of a window, so require re-rendering that window for each movement. However, being able to do this rendering off the main thread probably doesn‚Äôt gain you much. These are not simple ‚Äúmove this part of the UI from X to Y, and maybe tell me when you are done‚Äù animations ‚Äî each movement is based on events received about the finger on the screen, which need to be processed by the application on its main thread.</p>\n<p>That said, being able to avoid redrawing all of the contents of the parts of the UI that are moving can help performance. And this is also a technique that Android has employed since before 1.0; UI elements like a ListView that want to scroll their content can call <a href=\"http://developer.android.com/reference/android/view/View.html#setDrawingCacheEnabled(boolean\">http://developer.android.com/reference/android/view/View.html#setDrawingCacheEnabled(boolean</a>) to have that content rendered into a cache so that only the bitmap needs to be drawn as it moves.</p>\n<p>Traditionally on Android, views only have their drawing cache enabled as a transient state, such as while scrolling or tracking a finger. This is because they introduce a fair amount more overhead: extra memory for the bitmap (which can easily total to multiple times larger than the actual frame buffer if there are a number of visual layers), and when the contents inside of a cached view need to be redrawn it is more expensive because there is an additional step required to draw the cached bitmap back to the window.</p>\n<p>So, all those things considered, in Android 1.0 having each view drawn into a texture and those textures composited to the window in another thread is just not that much of a gain, with a lot of cost. The cost is also in engineering time ‚Äî our time was better spent working on other things like a layout-based view hierarchy (to provide flexibility in adjusting for different screen sizes) and ‚Äúremote views‚Äù for notifications and widgets, which have significantly benefited the platform as it develops.</p>\n<p>In fact it was just not feasible to implement hardware accelerated drawing inside windows until recently. Because Android is designed around having multiple windows on the screen, to have the drawing inside each window be hardware accelerated means requiring that the GPU and driver support multiple active GL contexts in different processes running at the same time. The hardware at that time just didn‚Äôt support this, even ignoring the additional memory needed for it that was not available. Even today we are in the early stages of this ‚Äî most mobile GPUs still have fairly expensive GL context switching.</p>\n<p>I hope this helps people better understand how Android works. And just to be clear again from my last point ‚Äî I am not writing this to make excuses for whatever things people don‚Äôt like about Android, I just get tired of seeing people write egregiously wrong explanations about how Android works and worse present themselves as authorities on the topic.</p>\n<p>There are of course many things that can be improved in Android today, just as there are many things that have been improved since 1.0. As other more pressing issues are addressed, and hardware capabilities improve and change, we continue to push the platform forward and make it better.</p>\n<p>One final thought. I saw an interesting comment from Brent Royal-Gordon on what developers sometimes need to do to achieve 60fps scrolling in iOS lists: ‚ÄúGetting it up to sixty is more difficult‚Äîyou may have to simplify the cell‚Äôs view hierarchy, or delay adding some of the content, or remove text formatting that would otherwise require a more expensive text rendering API, or even rip the subviews out of the cell altogether and draw everything by hand.‚Äù</p>\n<p>I am no expert on iOS, so I‚Äôll take that as as true. These are the exact same recommendations that we have given to Android‚Äôs app developers, and based on this statement I don‚Äôt see any indication that there is something intrinsically flawed about Android in making lists scroll at 60fps, any more than there is in iOS.</p>",
        "excerpt": "Original published at https://plus.google.com/u/0/105051985738280261832/posts/XAZ4CeVP6DC A few days ago I wrote a post trying to correct a‚Ä¶",
        "timeToRead": 7,
        "tableOfContents": ""
      },
      "comments": { "edges": [] }
    },
    "pageContext": {
      "next": null,
      "previous": {
        "frontmatter": {
          "path": "/articles/android-graphics-true-facts-1/",
          "title": "How about some Android graphics true facts? (Part 1 of 2)",
          "authors": [{ "id": "hackbod", "name": "Dianne Hackborn" }],
          "categories": ["articles"],
          "tags": ["Android", "Graphics"]
        },
        "fileAbsolutePath": "/home/28041/opensource/github.com/tonykwok/made-mistakes-gatsby/src/posts/articles/How-about-some-Android-graphics-true-facts.md"
      }
    }
  },
  "staticQueryHashes": ["215131063", "3443189517"]
}

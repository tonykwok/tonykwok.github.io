

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>OpenGL ES 2.0 &mdash; FCam for Tegra 1.3 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="FCam for Tegra 1.3 documentation" href="index.html" />
    <link rel="next" title="OpenCV on Tegra" href="opencv.html" />
    <link rel="prev" title="Introduction to Android development" href="devprocess.html" /> 
  </head>
  <body>

<div style="background-color: black; text-align: left; padding: 10px 10px 15px 15px">
<a href="index.html"><img src="_static/nvidia_logo.png" border="0" alt="NVIDIA logo"/></a>
</div>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="opencv.html" title="OpenCV on Tegra"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="devprocess.html" title="Introduction to Android development"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">home</a>|&nbsp;</li>
        <li><a href="search.html">search</a>|&nbsp;</li>
 
      </ul>
    </div>

      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">OpenGL ES 2.0</a><ul>
<li><a class="reference internal" href="#importing-an-existing-project">Importing an existing project</a></li>
<li><a class="reference internal" href="#creating-a-gl-project-from-scratch">Creating a GL project from scratch</a></li>
<li><a class="reference internal" href="#creating-a-gl-project-using-the-nvidia-framework">Creating a GL project using the NVIDIA framework</a></li>
<li><a class="reference internal" href="#using-shaders-in-your-gl-project">Using shaders in your GL project</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="devprocess.html"
                        title="previous chapter">Introduction to Android development</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="opencv.html"
                        title="next chapter">OpenCV on Tegra</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/opengles.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="opengl-es-2-0">
<span id="opengles"></span><h1>OpenGL ES 2.0<a class="headerlink" href="#opengl-es-2-0" title="Permalink to this headline">¶</a></h1>
<p>OpenGL ES provides a fast way to display the camera images, possibly after some image processing,
and allows building simple user interfaces.  In this section we only cover 2D graphics using
OpenGL ES 2.0, for 3D graphics there are other tutorials available, as well as the NativeGlobe example
provided in TADP.  From now on, we&#8217;ll use GL as a shorthand for OpenGL ES 2.0.
We also cover how to handle various Android events in a native program.</p>
<p>We first show how to import an existing native GL project into your workspace,
and then we show you how to create the same project from scratch. For the latter, we will follow
similar steps to those described in <a class="reference internal" href="devprocess.html#creating-a-nativeactivity"><em>Creating a NativeActivity</em></a>, in case you need a more
in-depth overview.</p>
<div class="section" id="importing-an-existing-project">
<span id="import-existing-project-opengles"></span><h2>Importing an existing project<a class="headerlink" href="#importing-an-existing-project" title="Permalink to this headline">¶</a></h2>
<p>Let&#8217;s start the first GL application by importing an existing project to Eclipse.
Start by importing <tt class="docutils literal"><span class="pre">/tutorials/SimpleNativeGL</span></tt> project.
Open Eclipse, select <em>File &gt; Import &gt; Android &gt; Existing Android Code into
Workspace</em>, and browse into the <em>Root Directory</em> (<tt class="docutils literal"><span class="pre">/tutorials/SimpleNativeGL</span></tt>).
You can copy the files into the project directory in the workspace
if you want by selecting one of the boxes.  Then hit <strong>Finish</strong>.</p>
<p>If the project has the default name</p>
<blockquote>
<div><a class="reference internal image-reference" href="_images/import_wrong_name.png"><img alt="_images/import_wrong_name.png" src="_images/import_wrong_name.png" style="width: 248.0px; height: 70.0px;" /></a>
</div></blockquote>
<p>rename the project (right-click the project and find the <em>Rename</em> option,
its location may vary depending on the operating system, could be under Refactor)</p>
<blockquote>
<div><a class="reference internal image-reference" href="_images/project_rename.png"><img alt="_images/project_rename.png" src="_images/project_rename.png" style="width: 452.0px; height: 267.2px;" /></a>
</div></blockquote>
<p>to SampleNativeGL. Open the project in the <em>Package Explorer</em>.</p>
<blockquote>
<div><a class="reference internal image-reference" href="_images/simple_gl_project.png"><img alt="_images/simple_gl_project.png" src="_images/simple_gl_project.png" style="width: 235.0px; height: 237.0px;" /></a>
</div></blockquote>
<p>The files and folders within the red rectangle are the ones you just imported,
others were generated during the Import operation.</p>
<p>As this is a native project, select the C/C++ perspective.</p>
<blockquote>
<div><a class="reference internal image-reference" href="_images/c_cpp_perspective.png"><img alt="_images/c_cpp_perspective.png" src="_images/c_cpp_perspective.png" style="width: 142.0px; height: 34.0px;" /></a>
</div></blockquote>
<p>By default all Android projects are Java projects, let&#8217;s convert ours to native
by right-clicking the project in <em>Package Explorer</em> and selecting <em>New &gt; Convert
to C/C++ Project</em>.  Select <em>Project Type</em> to be <em>Makefile project</em> and
<em>Toolchain</em> to be <em>Android GCC</em>.</p>
<blockquote>
<div><a class="reference internal image-reference" href="_images/convert_to_cpp.png"><img alt="_images/convert_to_cpp.png" src="_images/convert_to_cpp.png" style="width: 454.0px; height: 537.0px;" /></a>
</div></blockquote>
<p>Sometimes the project might be imported with the wrong Android version.
In the Project Explorer right-click on the project folder and choose
<em>Properties</em>. In the <em>Android</em> tab, make sure that the version selected is
at least <em>Android 4.0.3</em> (API 15):</p>
<blockquote>
<div><a class="reference internal image-reference" href="_images/GL_setAndroid.png"><img alt="_images/GL_setAndroid.png" src="_images/GL_setAndroid.png" style="width: 625.0px; height: 486.0px;" /></a>
</div></blockquote>
<p>Build the project (right-click <em>SimpleNativeGL &gt; Build Project</em>) and run it on
device (right-click <em>SimpleNativeGL &gt; Run As &gt; Android Application</em>).  Try
tapping the device display and slide your finger along the display; the solid
color that is displayed should vary depending on the touch location.</p>
</div>
<div class="section" id="creating-a-gl-project-from-scratch">
<span id="creating-project-opengles"></span><h2>Creating a GL project from scratch<a class="headerlink" href="#creating-a-gl-project-from-scratch" title="Permalink to this headline">¶</a></h2>
<p>To learn how to create a project from scratch, let&#8217;s go through the steps
necessary to create the project we imported in the previous section. If you
imported the project already, right-click on the project name in the Project
Explorer pane and click delete. If you copied the files into the workspace when
importing the project, in the next window check the box
<cite>Delete project contents from disk (cannot be undone)</cite> and make sure you&#8217;re
deleting the correct project; in general be really careful when using this
option since Eclipse does not move the project to the trash but rather
deletes it completely. Finally click <strong>OK</strong>.</p>
<p>From the Java perspective, let&#8217;s create the new project:</p>
<ul class="simple">
<li>Create a new Android application (<cite>File &gt; New &gt; Android Application Project</cite>)</li>
<li>Pick an <cite>Application Name</cite> (in this tutorial we are using <cite>SimpleNativeGL</cite> as a name)</li>
<li>Change the <cite>Minimum Required SDK</cite> to <cite>API 9: Android 2.3 (Gingerbread)</cite></li>
<li>Uncheck <cite>Create custom launcher icon</cite> and click <strong>Next</strong></li>
<li>Uncheck <cite>Create activity</cite> and click <strong>Finish</strong></li>
</ul>
<p>Now we need to add native support:</p>
<ul class="simple">
<li>Right-click on the project name and choose <cite>Android tools &gt; Add Native Support ...</cite></li>
<li>Leave the name of the lib as is and click <strong>Finish</strong></li>
</ul>
<p>Eclipse should now have switched to the <cite>C/C++</cite> perspective. First let&#8217;s modify
the manifest file. Open the <tt class="docutils literal"><span class="pre">AndroidManifest.xml</span></tt> file and switch to the
<tt class="docutils literal"><span class="pre">AndroidManifest.xml</span></tt> tab at the bottom of the window to be able to see the
actual xml code. Now replace the code within the application block with the
lines highlighted below:</p>
<div class="highlight-xml"><div class="highlight"><pre>  <span class="nt">&lt;manifest</span> <span class="na">xmlns:android=</span><span class="s">&quot;http://schemas.android.com/apk/res/android&quot;</span>
      <span class="na">package=</span><span class="s">&quot;com.nvidia.example.simplenativegl&quot;</span>
      <span class="na">android:versionCode=</span><span class="s">&quot;1&quot;</span>
      <span class="na">android:versionName=</span><span class="s">&quot;1.0&quot;</span> <span class="nt">&gt;</span>

      <span class="nt">&lt;uses-sdk</span>
          <span class="na">android:minSdkVersion=</span><span class="s">&quot;14&quot;</span>
          <span class="na">android:targetSdkVersion=</span><span class="s">&quot;15&quot;</span> <span class="nt">/&gt;</span>

<span class="hll">      <span class="c">&lt;!-- We do not have Java code. Therefore android:hasCode is set to false. --&gt;</span>
</span><span class="hll">      <span class="nt">&lt;application</span>
</span><span class="hll">          <span class="na">android:hasCode=</span><span class="s">&quot;false&quot;</span>
</span><span class="hll">          <span class="na">android:label=</span><span class="s">&quot;@string/app_name&quot;</span> <span class="nt">&gt;</span>
</span><span class="hll">
</span><span class="hll">          <span class="c">&lt;!--</span>
</span><span class="hll"><span class="c">             Our activity is the built-in NativeActivity framework class.</span>
</span><span class="hll"><span class="c">             This will take care of integrating with our NDK code.</span>
</span><span class="hll"><span class="c">          --&gt;</span>
</span><span class="hll">          <span class="nt">&lt;activity</span>
</span><span class="hll">              <span class="na">android:name=</span><span class="s">&quot;android.app.NativeActivity&quot;</span>
</span><span class="hll">              <span class="na">android:configChanges=</span><span class="s">&quot;orientation|keyboard|keyboardHidden&quot;</span>
</span><span class="hll">              <span class="na">android:label=</span><span class="s">&quot;@string/app_name&quot;</span>
</span><span class="hll">              <span class="na">android:theme=</span><span class="s">&quot;@android:style/Theme.NoTitleBar.Fullscreen&quot;</span> <span class="nt">&gt;</span>
</span><span class="hll">
</span><span class="hll">              <span class="c">&lt;!-- Tell NativeActivity the name of our .so --&gt;</span>
</span><span class="hll">              <span class="nt">&lt;meta-data</span>
</span><span class="hll">                  <span class="na">android:name=</span><span class="s">&quot;android.app.lib_name&quot;</span>
</span><span class="hll">                  <span class="na">android:value=</span><span class="s">&quot;SimpleNativeGL&quot;</span> <span class="nt">/&gt;</span>
</span><span class="hll">
</span><span class="hll">              <span class="nt">&lt;intent-filter&gt;</span>
</span><span class="hll">                  <span class="nt">&lt;action</span> <span class="na">android:name=</span><span class="s">&quot;android.intent.action.MAIN&quot;</span> <span class="nt">/&gt;</span>
</span><span class="hll">
</span><span class="hll">                  <span class="nt">&lt;category</span> <span class="na">android:name=</span><span class="s">&quot;android.intent.category.LAUNCHER&quot;</span> <span class="nt">/&gt;</span>
</span><span class="hll">              <span class="nt">&lt;/intent-filter&gt;</span>
</span><span class="hll">          <span class="nt">&lt;/activity&gt;</span>
</span><span class="hll">      <span class="nt">&lt;/application&gt;</span>
</span>
  <span class="nt">&lt;/manifest&gt;</span>
</pre></div>
</div>
<p>Now open the <tt class="docutils literal"><span class="pre">Android.mk</span></tt> file from the <tt class="docutils literal"><span class="pre">jni</span></tt> folder and add the lines highlighted
below:</p>
<div class="highlight-xml"><div class="highlight"><pre>  LOCAL_PATH := $(call my-dir)

  include $(CLEAR_VARS)

  LOCAL_MODULE    := SimpleNativeGL
  LOCAL_SRC_FILES := SimpleNativeGL.cpp
<span class="hll">  LOCAL_LDLIBS    := -llog -landroid -lEGL -lGLESv2
</span><span class="hll">  LOCAL_STATIC_LIBRARIES := android_native_app_glue
</span>
  include $(BUILD_SHARED_LIBRARY)

<span class="hll">  $(call import-module, android/native_app_glue)
</span></pre></div>
</div>
<p>In addition to what we went over in the tutorial <a class="reference internal" href="devprocess.html#creating-a-nativeactivity"><em>Creating a NativeActivity</em></a>,
we need to link against the <em>EGL</em> and <em>GLESv2</em> libraries.</p>
<p>In order to make sure that our application will be fully optimized, let&#8217;s create
an <tt class="docutils literal"><span class="pre">Application.mk</span></tt> file: right-click on the <tt class="docutils literal"><span class="pre">jni</span></tt> folder then <em>New &gt; File</em> and
set the name to <tt class="docutils literal"><span class="pre">Application.mk</span></tt>. Open the new file and add to it the line:</p>
<div class="highlight-xml"><div class="highlight"><pre>APP_ABI := armeabi-v7a
</pre></div>
</div>
<p>Now we need to populate the file <tt class="docutils literal"><span class="pre">SimpleNativeGL.cpp</span></tt>. Let&#8217;s start by including
headers and creating macros to log events:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &lt;jni.h&gt;</span>
<span class="cp">#include &lt;errno.h&gt;</span>

<span class="cp">#include &lt;EGL/egl.h&gt;</span>
<span class="cp">#include &lt;GLES2/gl2.h&gt;</span>

<span class="cp">#include &lt;android/sensor.h&gt;</span>
<span class="cp">#include &lt;android_native_app_glue.h&gt;</span>

<span class="cp">#include &lt;android/log.h&gt;</span>
<span class="cp">#define LOGW(...) ((void)__android_log_print(ANDROID_LOG_WARN, &quot;SimpleNativeGL&quot;, __VA_ARGS__))</span>
<span class="cp">#define LOGI(...) ((void)__android_log_print(ANDROID_LOG_INFO, &quot;SimpleNativeGL&quot;, __VA_ARGS__))</span>
</pre></div>
</div>
<p>Now let&#8217;s create a <tt class="docutils literal"><span class="pre">struct</span></tt> to share the current status between different functions, and let&#8217;s
add placeholders for the functions we&#8217;ll need to implement for this simple example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cm">/**</span>
<span class="cm">* State of our app</span>
<span class="cm">*/</span>
<span class="k">struct</span> <span class="n">Engine</span>
<span class="p">{</span>
     <span class="c1">// Save in the engine a pointer to the Android app</span>
     <span class="k">struct</span> <span class="n">android_app</span> <span class="o">*</span><span class="n">app</span><span class="p">;</span>

     <span class="c1">// EGL Display, surface, and context</span>
     <span class="n">EGLDisplay</span> <span class="n">display</span><span class="p">;</span>
     <span class="n">EGLSurface</span> <span class="n">surface</span><span class="p">;</span>
     <span class="n">EGLContext</span> <span class="n">context</span><span class="p">;</span>

     <span class="c1">// States and touch locations</span>
     <span class="kt">bool</span> <span class="n">animating</span><span class="p">;</span>
     <span class="kt">int</span>  <span class="n">width</span><span class="p">;</span>
     <span class="kt">int</span>  <span class="n">height</span><span class="p">;</span>
     <span class="kt">int</span>  <span class="n">x_touch</span><span class="p">;</span>
     <span class="kt">int</span>  <span class="n">y_touch</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Initialize an EGL context for the current display</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">engine_init_display</span><span class="p">(</span> <span class="k">struct</span> <span class="n">Engine</span> <span class="o">*</span><span class="n">engine</span> <span class="p">){}</span>

<span class="cm">/**</span>
<span class="cm"> * Draw the current frame on the display</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">engine_draw_frame</span><span class="p">(</span> <span class="k">struct</span> <span class="n">Engine</span> <span class="o">*</span><span class="n">engine</span> <span class="p">){}</span>

<span class="cm">/**</span>
<span class="cm"> * Tear down the EGL context currently associated with the display</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">engine_term_display</span><span class="p">(</span> <span class="k">struct</span> <span class="n">Engine</span> <span class="o">*</span><span class="n">engine</span> <span class="p">){}</span>

<span class="cm">/**</span>
<span class="cm"> * Process the input event</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int32_t</span> <span class="nf">engine_handle_input</span><span class="p">(</span> <span class="k">struct</span> <span class="n">android_app</span> <span class="o">*</span><span class="n">app</span><span class="p">,</span> <span class="n">AInputEvent</span> <span class="o">*</span><span class="n">event</span> <span class="p">){}</span>

<span class="cm">/**</span>
<span class="cm"> * Process the next main command</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">engine_handle_cmd</span><span class="p">(</span> <span class="k">struct</span> <span class="n">android_app</span> <span class="o">*</span><span class="n">app</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">cmd</span> <span class="p">){}</span>

<span class="cm">/**</span>
<span class="cm"> * This is the main entry point of a native application that is using</span>
<span class="cm"> * android_native_app_glue.  It runs in its own thread, with its own</span>
<span class="cm"> * event loop for receiving input events and doing other things.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">android_main</span><span class="p">(</span> <span class="k">struct</span> <span class="n">android_app</span> <span class="o">*</span><span class="n">app</span> <span class="p">){}</span>
</pre></div>
</div>
<p>Now let&#8217;s implement the different functions starting with the main:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> * This is the main entry point of a native application that is using</span>
<span class="cm"> * android_native_app_glue.  It runs in its own thread, with its own</span>
<span class="cm"> * event loop for receiving input events and doing other things.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">android_main</span><span class="p">(</span> <span class="k">struct</span> <span class="n">android_app</span> <span class="o">*</span><span class="n">app</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Make sure glue isn&#39;t stripped</span>
    <span class="n">app_dummy</span><span class="p">();</span>

    <span class="c1">// Initialize the engine.</span>
    <span class="c1">// The engine stores the state and global variables of the application.</span>
    <span class="k">struct</span> <span class="n">Engine</span> <span class="n">engine</span><span class="p">;</span>
    <span class="n">memset</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">engine</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">engine</span> <span class="p">)</span> <span class="p">);</span>
    <span class="c1">// The engine needs a pointer to app, e.g., to access the window data</span>
    <span class="n">engine</span><span class="p">.</span><span class="n">app</span> <span class="o">=</span> <span class="n">app</span><span class="p">;</span>

    <span class="c1">// Link the app to the engine and attach callbacks.</span>
    <span class="c1">// Store a pointer to the application engine for event handling.</span>
    <span class="n">app</span><span class="o">-&gt;</span><span class="n">userData</span>     <span class="o">=</span> <span class="o">&amp;</span><span class="n">engine</span><span class="p">;</span>
    <span class="c1">// Callback for handling application status changes</span>
    <span class="n">app</span><span class="o">-&gt;</span><span class="n">onAppCmd</span>     <span class="o">=</span> <span class="n">engine_handle_cmd</span><span class="p">;</span>
    <span class="c1">// Callback for handling touch input</span>
    <span class="n">app</span><span class="o">-&gt;</span><span class="n">onInputEvent</span> <span class="o">=</span> <span class="n">engine_handle_input</span><span class="p">;</span>

    <span class="c1">// The core of the main is an infinite loop which waits for events</span>
    <span class="c1">// and redraws the frame when needed.</span>
    <span class="k">while</span><span class="p">(</span> <span class="mi">1</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// read all pending events</span>
        <span class="kt">int</span> <span class="n">events</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">android_poll_source</span> <span class="o">*</span><span class="n">source</span><span class="p">;</span>

        <span class="c1">// If not animating, we will block forever waiting for events.</span>
        <span class="c1">// If animating, we loop until all events are read, then continue</span>
        <span class="c1">// to draw the next frame of animation.</span>
        <span class="k">while</span><span class="p">(</span> <span class="p">(</span> <span class="n">ALooper_pollAll</span><span class="p">(</span> <span class="n">engine</span><span class="p">.</span><span class="n">animating</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">events</span><span class="p">,</span> <span class="p">(</span> <span class="kt">void</span> <span class="o">**</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">source</span> <span class="p">)</span> <span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// Process this event.</span>
            <span class="c1">// Depending on the event, app-&gt;onAppCmd or app-&gt;onInputEvent may be called.</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">source</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span>
            <span class="p">{</span>
                <span class="n">source</span><span class="o">-&gt;</span><span class="n">process</span><span class="p">(</span> <span class="n">app</span><span class="p">,</span> <span class="n">source</span> <span class="p">);</span>
            <span class="p">}</span>

            <span class="c1">// Check if we are exiting (e.g., user presses the back button)</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">app</span><span class="o">-&gt;</span><span class="n">destroyRequested</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
            <span class="p">{</span>
                <span class="n">engine_term_display</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">engine</span> <span class="p">);</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span><span class="p">(</span> <span class="n">engine</span><span class="p">.</span><span class="n">animating</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// Done with events; draw next animation frame.</span>
            <span class="c1">// Drawing is synched with the screen update rate, so there</span>
            <span class="c1">// is no need to do timing here.</span>
            <span class="n">engine_draw_frame</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">engine</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>First, <tt class="docutils literal"><span class="pre">app_dummy()</span></tt> is called to make sure all the Android callbacks are not
optimized away by the compiler (more about it
<a class="reference external" href="http://blog.beuc.net/posts/Make_sure_glue_isn__39__t_stripped/">here</a>).
Next, an instance of <tt class="docutils literal"><span class="pre">struct</span> <span class="pre">Engine</span></tt> is created to store the global
data of this application, including a pointer back to <tt class="docutils literal"><span class="pre">struct</span> <span class="pre">android_app</span>
<span class="pre">*app</span></tt>.  <tt class="docutils literal"><span class="pre">app</span></tt> stores a pointer to the Engine, as well as pointers to
two callbacks defined below. The core of this function is an infinite loop
that iterates between handling events such as touches, and drawing a frame.</p>
<p>Before diving into the functions that perform the GL calls we need to implement
the functions that handle the callback inputs:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> * Process the input event</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int32_t</span> <span class="nf">engine_handle_input</span><span class="p">(</span> <span class="k">struct</span> <span class="n">android_app</span> <span class="o">*</span><span class="n">app</span><span class="p">,</span> <span class="n">AInputEvent</span> <span class="o">*</span><span class="n">event</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Get a local pointer to the engine that we stored in the application</span>
    <span class="k">struct</span> <span class="n">Engine</span> <span class="o">*</span><span class="n">engine</span> <span class="o">=</span> <span class="p">(</span> <span class="k">struct</span> <span class="n">Engine</span> <span class="o">*</span> <span class="p">)</span> <span class="n">app</span><span class="o">-&gt;</span><span class="n">userData</span><span class="p">;</span>

    <span class="c1">// Analyze the type of event</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">AInputEvent_getType</span><span class="p">(</span> <span class="n">event</span> <span class="p">)</span> <span class="o">==</span> <span class="n">AINPUT_EVENT_TYPE_MOTION</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// If the user lifted the finger from the screen, stop updating</span>
        <span class="kt">int32_t</span> <span class="n">action</span> <span class="o">=</span> <span class="n">AMotionEvent_getAction</span><span class="p">(</span> <span class="n">event</span> <span class="p">);</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">action</span> <span class="o">!=</span> <span class="n">AMOTION_EVENT_ACTION_MOVE</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">engine</span><span class="o">-&gt;</span><span class="n">animating</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Otherwise get the touch position and set animation to true</span>
        <span class="n">engine</span><span class="o">-&gt;</span><span class="n">x_touch</span> <span class="o">=</span> <span class="n">AMotionEvent_getX</span><span class="p">(</span> <span class="n">event</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
        <span class="n">engine</span><span class="o">-&gt;</span><span class="n">y_touch</span> <span class="o">=</span> <span class="n">AMotionEvent_getY</span><span class="p">(</span> <span class="n">event</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
        <span class="n">engine</span><span class="o">-&gt;</span><span class="n">animating</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Process the next main command</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">engine_handle_cmd</span><span class="p">(</span> <span class="k">struct</span> <span class="n">android_app</span> <span class="o">*</span><span class="n">app</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">cmd</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Get a local pointer to the engine that we stored in the application</span>
    <span class="k">struct</span> <span class="n">Engine</span> <span class="o">*</span><span class="n">engine</span> <span class="o">=</span> <span class="p">(</span> <span class="k">struct</span> <span class="n">Engine</span> <span class="o">*</span> <span class="p">)</span> <span class="n">app</span><span class="o">-&gt;</span><span class="n">userData</span><span class="p">;</span>

    <span class="c1">// Analyze the command</span>
    <span class="k">switch</span><span class="p">(</span> <span class="n">cmd</span> <span class="p">)</span>
    <span class="p">{</span>
    <span class="k">case</span> <span class="n">APP_CMD_INIT_WINDOW</span>:
        <span class="c1">// The window is being shown, get it ready</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">engine</span><span class="o">-&gt;</span><span class="n">app</span><span class="o">-&gt;</span><span class="n">window</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// Initialize the engine based on the current display</span>
            <span class="n">engine_init_display</span><span class="p">(</span> <span class="n">engine</span> <span class="p">);</span>
            <span class="c1">// Start drawing</span>
            <span class="n">engine_draw_frame</span><span class="p">(</span> <span class="n">engine</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">APP_CMD_TERM_WINDOW</span>:
        <span class="c1">// The window is being hidden or closed, clean it up</span>
        <span class="n">engine_term_display</span><span class="p">(</span> <span class="n">engine</span> <span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">APP_CMD_LOST_FOCUS</span>:
        <span class="c1">// When our app loses focus, we stop animating</span>
        <span class="n">engine</span><span class="o">-&gt;</span><span class="n">animating</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The GL calls happen in functions <tt class="docutils literal"><span class="pre">static</span> <span class="pre">int</span> <span class="pre">engine_init_display(struct</span>
<span class="pre">Engine</span> <span class="pre">*engine)</span></tt>, <tt class="docutils literal"><span class="pre">static</span> <span class="pre">void</span> <span class="pre">engine_draw_frame(struct</span> <span class="pre">Engine</span> <span class="pre">*engine)</span></tt>,
and <tt class="docutils literal"><span class="pre">static</span> <span class="pre">void</span> <span class="pre">engine_term_display(struct</span> <span class="pre">Engine</span> <span class="pre">*engine)</span></tt>.  The first
one initializes GL context and drawing surface using the GL companion API EGL.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> * Initialize an EGL context for the current display</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">engine_init_display</span><span class="p">(</span> <span class="k">struct</span> <span class="n">Engine</span> <span class="o">*</span><span class="n">engine</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// initialize OpenGL ES and EGL</span>
    <span class="n">EGLDisplay</span> <span class="n">display</span> <span class="o">=</span> <span class="n">eglGetDisplay</span><span class="p">(</span> <span class="n">EGL_DEFAULT_DISPLAY</span> <span class="p">);</span>

    <span class="n">eglInitialize</span><span class="p">(</span> <span class="n">display</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>

    <span class="c1">// Specify the attributes of the desired configuration.</span>
    <span class="c1">// We select an EGLConfig with at least 8 bits per color component</span>
    <span class="c1">// that is compatible with on-screen windows.</span>
    <span class="k">const</span> <span class="n">EGLint</span> <span class="n">attribs</span><span class="p">[]</span> <span class="o">=</span>
    <span class="p">{</span> <span class="n">EGL_SURFACE_TYPE</span><span class="p">,</span> <span class="n">EGL_WINDOW_BIT</span><span class="p">,</span> <span class="n">EGL_BLUE_SIZE</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">EGL_GREEN_SIZE</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">EGL_RED_SIZE</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">EGL_NONE</span> <span class="p">};</span>

    <span class="c1">// Here, the application chooses the configuration it desires.</span>
    <span class="c1">// eglChooseConfig in general returns all the configurations compatible</span>
    <span class="c1">// with the attributes passed. In this sample, we have a very simplified</span>
    <span class="c1">// selection process, where we pick the first EGLConfig that matches</span>
    <span class="c1">// our criteria (by setting the third argument to 1).</span>
    <span class="n">EGLConfig</span> <span class="n">config</span><span class="p">;</span>
    <span class="n">EGLint</span> <span class="n">numConfigs</span><span class="p">;</span>
    <span class="n">eglChooseConfig</span><span class="p">(</span> <span class="n">display</span><span class="p">,</span> <span class="n">attribs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">config</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">numConfigs</span> <span class="p">);</span>

    <span class="c1">// EGL_NATIVE_VISUAL_ID is an attribute of the EGLConfig that is</span>
    <span class="c1">// guaranteed to be accepted by ANativeWindow_setBuffersGeometry().</span>
    <span class="c1">// We can use it to make the ANativeWindow buffers to match.</span>
    <span class="n">EGLint</span> <span class="n">format</span><span class="p">;</span>
    <span class="n">eglGetConfigAttrib</span><span class="p">(</span> <span class="n">display</span><span class="p">,</span> <span class="n">config</span><span class="p">,</span> <span class="n">EGL_NATIVE_VISUAL_ID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">format</span> <span class="p">);</span>

    <span class="c1">// Set a native Android window to have the format configured by EGL</span>
    <span class="n">ANativeWindow_setBuffersGeometry</span><span class="p">(</span> <span class="n">engine</span><span class="o">-&gt;</span><span class="n">app</span><span class="o">-&gt;</span><span class="n">window</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">format</span> <span class="p">);</span>

    <span class="c1">// Create EGL surface and context</span>
    <span class="n">EGLSurface</span> <span class="n">surface</span> <span class="o">=</span> <span class="n">eglCreateWindowSurface</span><span class="p">(</span> <span class="n">display</span><span class="p">,</span> <span class="n">config</span><span class="p">,</span> <span class="n">engine</span><span class="o">-&gt;</span><span class="n">app</span><span class="o">-&gt;</span><span class="n">window</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">);</span>
    <span class="n">EGLContext</span> <span class="n">context</span> <span class="o">=</span> <span class="n">eglCreateContext</span><span class="p">(</span> <span class="n">display</span><span class="p">,</span> <span class="n">config</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">);</span>

    <span class="c1">// Use the surface and context we just created and configure the engine</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">eglMakeCurrent</span><span class="p">(</span> <span class="n">display</span><span class="p">,</span> <span class="n">surface</span><span class="p">,</span> <span class="n">surface</span><span class="p">,</span> <span class="n">context</span> <span class="p">)</span> <span class="o">==</span> <span class="n">EGL_FALSE</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">LOGW</span><span class="p">(</span> <span class="s">&quot;Unable to eglMakeCurrent&quot;</span> <span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Get width and height of the surface</span>
    <span class="n">EGLint</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">;</span>
    <span class="n">eglQuerySurface</span><span class="p">(</span> <span class="n">display</span><span class="p">,</span> <span class="n">surface</span><span class="p">,</span> <span class="n">EGL_WIDTH</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">w</span> <span class="p">);</span>
    <span class="n">eglQuerySurface</span><span class="p">(</span> <span class="n">display</span><span class="p">,</span> <span class="n">surface</span><span class="p">,</span> <span class="n">EGL_HEIGHT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h</span> <span class="p">);</span>

    <span class="c1">// Store the app variables so the callbacks can access the data</span>
    <span class="n">engine</span><span class="o">-&gt;</span><span class="n">display</span> <span class="o">=</span> <span class="n">display</span><span class="p">;</span>
    <span class="n">engine</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="n">context</span><span class="p">;</span>
    <span class="n">engine</span><span class="o">-&gt;</span><span class="n">surface</span> <span class="o">=</span> <span class="n">surface</span><span class="p">;</span>
    <span class="n">engine</span><span class="o">-&gt;</span><span class="n">width</span>   <span class="o">=</span> <span class="n">w</span><span class="p">;</span>
    <span class="n">engine</span><span class="o">-&gt;</span><span class="n">height</span>  <span class="o">=</span> <span class="n">h</span><span class="p">;</span>

    <span class="c1">// Initialize GL state</span>
    <span class="n">glEnable</span><span class="p">(</span> <span class="n">GL_CULL_FACE</span> <span class="p">);</span>
    <span class="n">glDisable</span><span class="p">(</span> <span class="n">GL_DEPTH_TEST</span> <span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now that we have initialized the engine we can implement the function to draw frames.
In this simple example we will be just setting a solid background color based on the
touch location: we set the green channel to zero, and the blue (red) channel is driven
by the vertical (horizontal) position of the touch on the screen.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> * Draw the current frame on the display</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">engine_draw_frame</span><span class="p">(</span> <span class="k">struct</span> <span class="n">Engine</span> <span class="o">*</span><span class="n">engine</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">engine</span><span class="o">-&gt;</span><span class="n">display</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span> <span class="k">return</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// No display</span>

    <span class="c1">// Set the clear color based on the touch location from the engine</span>
    <span class="n">glClearColor</span><span class="p">(</span> <span class="p">(</span> <span class="p">(</span> <span class="kt">float</span> <span class="p">)</span> <span class="n">engine</span><span class="o">-&gt;</span><span class="n">x_touch</span> <span class="p">)</span> <span class="o">/</span> <span class="n">engine</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span>  <span class="c1">// Red channel</span>
                  <span class="mi">0</span><span class="p">,</span>                                              <span class="c1">// Green channel</span>
                  <span class="p">(</span> <span class="p">(</span> <span class="kt">float</span> <span class="p">)</span> <span class="n">engine</span><span class="o">-&gt;</span><span class="n">y_touch</span> <span class="p">)</span> <span class="o">/</span> <span class="n">engine</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">,</span> <span class="c1">// Blue channel</span>
                  <span class="mi">1</span> <span class="p">);</span>                                            <span class="c1">// Alpha channel</span>
    <span class="c1">// Clear the screen to the color we just set</span>
    <span class="n">glClear</span><span class="p">(</span> <span class="n">GL_COLOR_BUFFER_BIT</span> <span class="p">);</span>

    <span class="c1">// Swap the buffers, which indicates we&#39;re done with rendering this frame</span>
    <span class="n">eglSwapBuffers</span><span class="p">(</span> <span class="n">engine</span><span class="o">-&gt;</span><span class="n">display</span><span class="p">,</span> <span class="n">engine</span><span class="o">-&gt;</span><span class="n">surface</span> <span class="p">);</span>
    <span class="c1">// LOGI( &quot;Buffers swapped by eglSwapBuffers...&quot; );</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The last function that we need to implement cleans up the EGL structures
at application exit:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> * Tear down the EGL context currently associated with the display</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">engine_term_display</span><span class="p">(</span> <span class="k">struct</span> <span class="n">Engine</span> <span class="o">*</span><span class="n">engine</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">engine</span><span class="o">-&gt;</span><span class="n">display</span> <span class="o">!=</span> <span class="n">EGL_NO_DISPLAY</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">eglMakeCurrent</span><span class="p">(</span> <span class="n">engine</span><span class="o">-&gt;</span><span class="n">display</span><span class="p">,</span> <span class="n">EGL_NO_SURFACE</span><span class="p">,</span> <span class="n">EGL_NO_SURFACE</span><span class="p">,</span> <span class="n">EGL_NO_CONTEXT</span> <span class="p">);</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">engine</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">!=</span> <span class="n">EGL_NO_CONTEXT</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">eglDestroyContext</span><span class="p">(</span> <span class="n">engine</span><span class="o">-&gt;</span><span class="n">display</span><span class="p">,</span> <span class="n">engine</span><span class="o">-&gt;</span><span class="n">context</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">engine</span><span class="o">-&gt;</span><span class="n">surface</span> <span class="o">!=</span> <span class="n">EGL_NO_SURFACE</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">eglDestroySurface</span><span class="p">(</span> <span class="n">engine</span><span class="o">-&gt;</span><span class="n">display</span><span class="p">,</span> <span class="n">engine</span><span class="o">-&gt;</span><span class="n">surface</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="n">eglTerminate</span><span class="p">(</span> <span class="n">engine</span><span class="o">-&gt;</span><span class="n">display</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="n">engine</span><span class="o">-&gt;</span><span class="n">animating</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">engine</span><span class="o">-&gt;</span><span class="n">display</span>   <span class="o">=</span> <span class="n">EGL_NO_DISPLAY</span><span class="p">;</span>
    <span class="n">engine</span><span class="o">-&gt;</span><span class="n">context</span>   <span class="o">=</span> <span class="n">EGL_NO_CONTEXT</span><span class="p">;</span>
    <span class="n">engine</span><span class="o">-&gt;</span><span class="n">surface</span>   <span class="o">=</span> <span class="n">EGL_NO_SURFACE</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="creating-a-gl-project-using-the-nvidia-framework">
<h2>Creating a GL project using the NVIDIA framework<a class="headerlink" href="#creating-a-gl-project-using-the-nvidia-framework" title="Permalink to this headline">¶</a></h2>
<p>In the previous example, we described how to create an application from scratch, using
the GL API; for Tegra-based devices, NVIDIA offers a framework that greatly simplifies
the process. (The framework will probably work on other Android devices too, but we haven&#8217;t tested that.)
We will now implement a project that is very similar to the previous one, but
we will employ this helper, to show its basic usage. The app will still change the background
color based on the x and y position of the touches but, in addition to that, it will
also overlay different text if the app is in focus or paused. In order to perform the
latter, we will process the events generated by the UI. If the application is in focus
we will display &#8220;Active mode!&#8221; and we will track the position of the touches. When the
return button is pressed once, or the &#8220;Recent app&#8221; button is pressed, or the bottom
right corner is pressed, the app will be considered paused, or out-of-focus, and the
text will be changed to:</p>
<div class="highlight-python"><pre>Auto-pause
Press back to quit
Tap window to resume</pre>
</div>
<p>When the app is paused, unless a new event is generated, an additional 4 more frames are going
to be rendered, and after that, nothing else will happen.</p>
<p>Let&#8217;s start. We first create a project (SimpleNativeGL_NV) the same way we did before.
Follow the first steps described above up to the part where we modified the
<tt class="docutils literal"><span class="pre">AndroidManifest.xml</span></tt> file. The only difference in the manifest file is the
name we give to the library:</p>
<div class="highlight-xml"><div class="highlight"><pre>[...]
<span class="c">&lt;!-- Tell NativeActivity the name of our .so --&gt;</span>
<span class="nt">&lt;meta-data</span> <span class="na">android:name=</span><span class="s">&quot;android.app.lib_name&quot;</span>
<span class="hll">           <span class="na">android:value=</span><span class="s">&quot;SimpleNativeGL_NV&quot;</span> <span class="nt">/&gt;</span>
</span>[...]
</pre></div>
</div>
<p>Now let&#8217;s modify the <tt class="docutils literal"><span class="pre">Android.mk</span></tt> file in the <tt class="docutils literal"><span class="pre">jni</span></tt> folder of the project:</p>
<div class="highlight-make"><div class="highlight"><pre><span class="nv">LOCAL_PATH</span> <span class="o">:=</span> <span class="k">$(</span>call my-dir<span class="k">)</span>

<span class="cp">include $(CLEAR_VARS)</span>

<span class="nv">LOCAL_MODULE</span>    <span class="o">:=</span> SimpleNativeGL_NV
<span class="nv">LOCAL_SRC_FILES</span> <span class="o">:=</span> SimpleNativeGL_NV.cpp Engine.cpp
<span class="nv">LOCAL_LDLIBS</span>    <span class="o">:=</span> -lc -lm -llog -landroid -ldl -lGLESv2 -lEGL
<span class="hll"><span class="nv">LOCAL_STATIC_LIBRARIES</span> <span class="o">:=</span> nv_and_util nv_egl_util nv_bitfont nv_math nv_glesutil nv_hhdds nv_log nv_shader nv_file nv_thread
</span><span class="nv">LOCAL_CFLAGS</span>    <span class="o">+=</span> -std<span class="o">=</span>gnu++0x

<span class="cp">include $(BUILD_SHARED_LIBRARY)</span>

<span class="hll"><span class="c"># Add the folder with the NVIDIA helper, assuming we are at the nvsample_workspace</span>
</span><span class="hll"><span class="k">$(</span>call import-add-path, <span class="k">$(</span>NVPACK_PATH<span class="k">)</span>/TDK_Samples/tegra_android_native_samples_v10p10/libs/jni<span class="k">)</span>
</span><span class="hll">
</span><span class="hll"><span class="c"># Import the modules from the NVIDIA helper</span>
</span><span class="hll"><span class="k">$(</span>call import-module, nv_and_util<span class="k">)</span>
</span><span class="hll"><span class="k">$(</span>call import-module, nv_egl_util<span class="k">)</span>
</span><span class="hll"><span class="k">$(</span>call import-module, nv_bitfont<span class="k">)</span>
</span><span class="hll"><span class="k">$(</span>call import-module, nv_math<span class="k">)</span>
</span><span class="hll"><span class="k">$(</span>call import-module, nv_glesutil<span class="k">)</span>
</span><span class="hll"><span class="k">$(</span>call import-module, nv_hhdds<span class="k">)</span>
</span><span class="hll"><span class="k">$(</span>call import-module, nv_log<span class="k">)</span>
</span><span class="hll"><span class="k">$(</span>call import-module, nv_shader<span class="k">)</span>
</span><span class="hll"><span class="k">$(</span>call import-module, nv_file<span class="k">)</span>
</span><span class="hll"><span class="k">$(</span>call import-module, nv_thread<span class="k">)</span>
</span></pre></div>
</div>
<p>In addition to what we did in the example we created in <a class="reference internal" href="#creating-project-opengles"><em>Creating a GL project from scratch</em></a>,
here we are just linking against the NVIDIA libraries and importing the corresponding
modules. Note that we are assuming again that you are working in the
<tt class="docutils literal"><span class="pre">$NVPACK_PATH/nvsample_workspace</span></tt> workspace. If not, you will have to change the pointer
to the NVIDIA helper folder. Because we will create a class called <tt class="docutils literal"><span class="pre">Engine</span></tt>
we added the corresponding source file to the list of <tt class="docutils literal"><span class="pre">LOCAL_SRC_FILES</span></tt>.</p>
<p>Also, we need the fonts for the text we will overlay on the screen.
We can get them from the <tt class="docutils literal"><span class="pre">assets</span></tt> folder of other projects in the workspace. For
instance, in the Project Explorer, expand the folder <cite>NativeBasic &gt; assets</cite>.  Copy the two
<cite>*.abc</cite> and <cite>*.dds</cite> files to the <tt class="docutils literal"><span class="pre">assets</span></tt> folder of our project (in total, you should
be copying 4 files).  Dragging-and-dropping with holding ALT within Eclipse Project Explorer
is probably the easiest way to do this.</p>
<p>Finally, to make sure that our application is fully optimized, we need the
<cite>Application.mk</cite>. You can create it like we did in <a class="reference internal" href="#creating-project-opengles"><em>Creating a GL project from scratch</em></a>,or copy it
directly from the other project. Because we want to use smart pointers of the new C++ 11 STL,
we need to add a line to indicate we will be using the GNU STL implementation:</p>
<div class="highlight-make"><div class="highlight"><pre><span class="nv">APP_ABI</span> <span class="o">:=</span> armeabi-v7a
<span class="hll"><span class="nv">APP_STL</span> <span class="o">:=</span> gnustl_static
</span></pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The use of C++ 11 features, like <tt class="docutils literal"><span class="pre">std::unique_ptr</span></tt> requires the compiler flag
<tt class="docutils literal"><span class="pre">-std=gnu++0x</span></tt> and GCC version 4.6, which is the default compiler in NDK r8b.
The compiler flags are given under <tt class="docutils literal"><span class="pre">LOCAL_C_FLAGS</span></tt> in the <tt class="docutils literal"><span class="pre">Android.mk</span></tt> file.</p>
</div>
<p>We will now create a class expanding the Engine <tt class="docutils literal"><span class="pre">struct</span></tt> from the previous example,
and we will move much of the code to it.</p>
<p>In the <cite>Project Explorer</cite> pane, right-click on the <tt class="docutils literal"><span class="pre">jni</span></tt> folder and then <cite>New &gt; Class</cite>.
In the <cite>Class name</cite> field, type <cite>Engine</cite> and then click <strong>Finish</strong>. Eclipse has now
created for us both the header and source files for the class. Let&#8217;s start from the header
file:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#ifndef __ENGINE_H</span>
<span class="cp">#define __ENGINE_H</span>

<span class="c1">// Includes for the NVIDIA helper libraries</span>
<span class="cp">#include &lt;nv_and_util/nv_native_app_glue.h&gt;</span>
<span class="cp">#include &lt;nv_egl_util/nv_egl_util.h&gt;</span>

<span class="c1">// Logging macros</span>
<span class="cp">#define APP_NAME &quot;SimpleNativeGL_NV&quot;</span>
<span class="cp">#define LOGD(...) ((void)__android_log_print(ANDROID_LOG_DEBUG,APP_NAME, __VA_ARGS__))</span>
<span class="cp">#define LOGI(...) ((void)__android_log_print(ANDROID_LOG_INFO, APP_NAME, __VA_ARGS__))</span>
<span class="cp">#define LOGW(...) ((void)__android_log_print(ANDROID_LOG_WARN, APP_NAME, __VA_ARGS__))</span>

<span class="cp">#define FRAMES_TO_RENDER 4</span>

<span class="cm">/**</span>
<span class="cm"> *  This is the engine which implements the required callback functions,</span>
<span class="cm"> *  as well as a few utility functions.</span>
<span class="cm"> *  This implementation relies on the NVIDIA utilities.</span>
<span class="cm"> */</span>
<span class="k">class</span> <span class="nc">Engine</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="cm">/**</span>
<span class="cm">     * The constructor saves a pointer to the engine and to the callback</span>
<span class="cm">     * functions in the Android app. It also initializes the nv_shader library.</span>
<span class="cm">     */</span>
    <span class="n">Engine</span><span class="p">(</span> <span class="n">NvEGLUtil</span><span class="o">&amp;</span> <span class="n">egl</span><span class="p">,</span> <span class="k">struct</span> <span class="n">android_app</span> <span class="o">*</span><span class="n">app</span> <span class="p">);</span>

    <span class="cm">/**</span>
<span class="cm">     * The destructor mainly frees the allocated BitFonts.</span>
<span class="cm">     */</span>
    <span class="o">~</span><span class="n">Engine</span><span class="p">();</span>

    <span class="cm">/**</span>
<span class="cm">     * The application can be active or paused. This function returns</span>
<span class="cm">     * false when the application is paused.</span>
<span class="cm">     */</span>
    <span class="kt">bool</span> <span class="nf">isActiveMode</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">mActiveMode</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/**</span>
<span class="cm">     * Render the frame, after checking what the status of the Android app is.</span>
<span class="cm">     * Interactible should be true if the app is running, it is active, focused,</span>
<span class="cm">     * and has a valid surface.</span>
<span class="cm">     */</span>
    <span class="kt">void</span> <span class="nf">updateFrame</span><span class="p">(</span> <span class="kt">bool</span> <span class="n">interactible</span> <span class="p">);</span>

<span class="nl">protected:</span>

    <span class="cm">/**</span>
<span class="cm">     *  Wrapper to handle commands generated by the UI.</span>
<span class="cm">     */</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="nf">handleCmdThunk</span><span class="p">(</span> <span class="k">struct</span> <span class="n">android_app</span> <span class="o">*</span><span class="n">app</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">cmd</span> <span class="p">);</span>

    <span class="cm">/**</span>
<span class="cm">     * Handle commands.</span>
<span class="cm">     */</span>
    <span class="kt">void</span> <span class="nf">handleCommand</span><span class="p">(</span> <span class="kt">int</span> <span class="n">cmd</span> <span class="p">);</span>

    <span class="cm">/**</span>
<span class="cm">     * Wrapper to handle input events generated by the UI.</span>
<span class="cm">     */</span>
    <span class="k">static</span> <span class="kt">int32_t</span> <span class="nf">handleInputThunk</span><span class="p">(</span> <span class="k">struct</span> <span class="n">android_app</span> <span class="o">*</span><span class="n">app</span><span class="p">,</span> <span class="n">AInputEvent</span> <span class="o">*</span><span class="n">event</span> <span class="p">);</span>

    <span class="cm">/**</span>
<span class="cm">     * Handle inputs.</span>
<span class="cm">     */</span>
    <span class="kt">int</span> <span class="nf">handleInput</span><span class="p">(</span> <span class="n">AInputEvent</span> <span class="o">*</span><span class="n">event</span> <span class="p">);</span>

    <span class="cm">/* Auxiliary functions */</span>

    <span class="cm">/**</span>
<span class="cm">     * Set mActiveMode; we use mActiveMode to keep track of whether the app is actually</span>
<span class="cm">     * running or paused. Examples of when the app is paused is when the user has pressed</span>
<span class="cm">     * the back button, the &quot;Recent apps&quot; button, or the time at the bottom right corner</span>
<span class="cm">     * of the screen.</span>
<span class="cm">     */</span>
    <span class="kt">void</span> <span class="nf">setActiveMode</span><span class="p">(</span> <span class="kt">bool</span> <span class="n">running</span> <span class="p">);</span>

    <span class="cm">/**</span>
<span class="cm">     * If the app&#39;s window had been resized returns true and forces the frame to be</span>
<span class="cm">     * rendered.</span>
<span class="cm">     */</span>
    <span class="kt">bool</span> <span class="nf">checkWindowResized</span><span class="p">();</span>

    <span class="cm">/**</span>
<span class="cm">     * Resets the number of frames that need to be rendered.</span>
<span class="cm">     */</span>
    <span class="kt">void</span> <span class="nf">requestForceRender</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// Even when no events are generated, we required that the system still renders</span>
        <span class="c1">// FRAMES_TO_RENDER frames.</span>
        <span class="n">mForceRender</span> <span class="o">=</span> <span class="n">FRAMES_TO_RENDER</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/*</span>
<span class="cm">     * Check if we are done rendering frames.</span>
<span class="cm">     */</span>
    <span class="kt">bool</span> <span class="nf">isForcedRenderPending</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// mForceRender is decremented every time a frame is rendered and</span>
        <span class="c1">// reinitialized to FRAMES_TO_RENDER when a new event is generated</span>
        <span class="c1">// by the UI</span>
        <span class="k">return</span> <span class="n">mForceRender</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/**</span>
<span class="cm">     * This is the actual method which renders the frame.</span>
<span class="cm">     * It returns false if either EGL was not ready to render or</span>
<span class="cm">     * the UI could not be initialized.</span>
<span class="cm">     */</span>
    <span class="kt">bool</span> <span class="nf">renderFrame</span><span class="p">(</span> <span class="kt">bool</span> <span class="n">allocateIfNeeded</span> <span class="p">);</span>

    <span class="cm">/**</span>
<span class="cm">     * Initialize the UI</span>
<span class="cm">     * Returns true if the UI was initialized, false if the fonts could not be</span>
<span class="cm">     * initialized.</span>
<span class="cm">     */</span>
    <span class="kt">bool</span> <span class="nf">initUI</span><span class="p">();</span>

    <span class="cm">/**</span>
<span class="cm">     * If there is a pending window resize, perform it and return true.</span>
<span class="cm">     */</span>
    <span class="kt">bool</span> <span class="nf">resizeIfNeeded</span><span class="p">();</span>

    <span class="cm">/* Variables */</span>

    <span class="k">struct</span> <span class="n">android_app</span> <span class="o">*</span><span class="n">mApp</span><span class="p">;</span> <span class="c1">// Pointer to the Android app</span>
    <span class="n">NvEGLUtil</span> <span class="o">&amp;</span><span class="n">mEgl</span><span class="p">;</span>          <span class="c1">// NvEGLUtil is the NVIDIA wrapper to EGL</span>

    <span class="kt">bool</span>  <span class="n">mResizePending</span><span class="p">;</span>     <span class="c1">// Is there a window-resize pending?</span>
    <span class="kt">bool</span>  <span class="n">mActiveMode</span><span class="p">;</span>        <span class="c1">// Is the app active or has it been paused?</span>
    <span class="kt">bool</span>  <span class="n">mUiInitialized</span><span class="p">;</span>     <span class="c1">// Has the UI been initialized?</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">mUiText</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>         <span class="c1">// We need this variable to get a pointer to the bftext objects</span>
    <span class="kt">int</span>   <span class="n">mTouchX</span><span class="p">,</span> <span class="n">mTouchY</span><span class="p">;</span>   <span class="c1">// Position of the touch event</span>
    <span class="kt">int</span>   <span class="n">mForceRender</span><span class="p">;</span>       <span class="c1">// This variable counts how many more frames we want</span>
                              <span class="c1">// to render in case no new requests are generated.</span>
<span class="p">};</span>

<span class="cp">#endif </span><span class="c1">// __ENGINE_H</span>
</pre></div>
</div>
<p>The comments and the naming of methods and variables should be self-explanatory.
Open <tt class="docutils literal"><span class="pre">Engine.cpp</span></tt> so we can look at the implementation of the different methods,
starting with the includes, constructor and destructor:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;Engine.h&quot;</span>

<span class="c1">// Includes for GL and EGL</span>
<span class="cp">#include &lt;EGL/egl.h&gt;</span>
<span class="cp">#include &lt;EGL/eglplatform.h&gt;</span>
<span class="cp">#include &lt;GLES2/gl2.h&gt;</span>

<span class="c1">// Includes for the NVIDIA helper libraries</span>
<span class="cp">#include &lt;nv_and_util/nv_native_app_glue.h&gt;</span>
<span class="cp">#include &lt;nv_egl_util/nv_egl_util.h&gt;</span>
<span class="cp">#include &lt;nv_bitfont/nv_bitfont.h&gt;</span>
<span class="cp">#include &lt;nv_shader/nv_shader.h&gt;</span>

<span class="n">Engine</span><span class="o">::</span><span class="n">Engine</span><span class="p">(</span> <span class="n">NvEGLUtil</span><span class="o">&amp;</span> <span class="n">egl</span><span class="p">,</span> <span class="k">struct</span> <span class="n">android_app</span> <span class="o">*</span><span class="n">app</span> <span class="p">)</span>
         <span class="o">:</span> <span class="n">mEgl</span><span class="p">(</span> <span class="n">egl</span> <span class="p">),</span> <span class="n">mApp</span><span class="p">(</span> <span class="n">app</span> <span class="p">),</span> <span class="n">mResizePending</span><span class="p">(</span> <span class="nb">false</span> <span class="p">),</span> <span class="n">mActiveMode</span><span class="p">(</span> <span class="nb">true</span> <span class="p">),</span>
           <span class="n">mForceRender</span><span class="p">(</span> <span class="mi">4</span> <span class="p">),</span> <span class="n">mUiInitialized</span><span class="p">(</span> <span class="nb">false</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Save a pointer to the engine in the Android app</span>
    <span class="n">app</span><span class="o">-&gt;</span><span class="n">userData</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>

    <span class="c1">// Save pointers to the implementation of the callback functions in the</span>
    <span class="c1">// Android app</span>
    <span class="n">app</span><span class="o">-&gt;</span><span class="n">onAppCmd</span>     <span class="o">=</span> <span class="o">&amp;</span><span class="n">Engine</span><span class="o">::</span><span class="n">handleCmdThunk</span><span class="p">;</span>
    <span class="n">app</span><span class="o">-&gt;</span><span class="n">onInputEvent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Engine</span><span class="o">::</span><span class="n">handleInputThunk</span><span class="p">;</span>

    <span class="c1">// Initialize the nv_shader library</span>
    <span class="n">nv_shader_init</span><span class="p">(</span> <span class="n">app</span><span class="o">-&gt;</span><span class="n">activity</span><span class="o">-&gt;</span><span class="n">assetManager</span> <span class="p">);</span>

    <span class="c1">// Initialize the pointers to the bftext objects</span>
    <span class="n">mUiText</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">mUiText</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">Engine</span><span class="o">::~</span><span class="n">Engine</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Free the allocated BitFonts</span>
    <span class="n">NVBFTextFree</span><span class="p">(</span> <span class="n">mUiText</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">);</span>
    <span class="n">NVBFTextFree</span><span class="p">(</span> <span class="n">mUiText</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">);</span>
    <span class="n">NVBFCleanup</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the code above we used some of the NVIDIA libraries, such as an EGL utility.
There is no comprehensive documentation of the libraries, but the code is
commented pretty well.  Let&#8217;s study what the EGL utility is made of.  Place the
cursor on <tt class="docutils literal"><span class="pre">NvEGLUtil</span></tt> on the argument list of the Engine constructor and hit
<strong>F3</strong> (or CTRL-click [CMD-click on Mac]).  This should take you to the
definition of that object in <tt class="docutils literal"><span class="pre">nv_egl_util.h</span></tt>.  If the indexer worked
correctly, you could now do the same thing to toggle between the declaration and
definition of some member function, such as <tt class="docutils literal"><span class="pre">swap()</span></tt>.  You can always toggle
between the header and implementation files with CTRL-TAB.  To get indexer
working for <tt class="docutils literal"><span class="pre">nv_egl_util.h</span></tt>, if you care, you&#8217;d need to go to <em>Project
Properties &gt; C/C++ General &gt; Paths and Symbols &gt; Source Locations</em> and link the
folder to where the <tt class="docutils literal"><span class="pre">nv_egl_util.cpp</span></tt> file is (it is in
<tt class="docutils literal"><span class="pre">$NVPACK_PATH/TDK_Samples/tegra_android_native_samples_v10p10/libs/jni/nv_egl_util</span></tt>).
In any case, browsing these
two files allows you to see how the <tt class="docutils literal"><span class="pre">NvEGLUtil</span></tt> class works.</p>
<p>So far, it is pretty much like before, with the exeption that we initialize the
<tt class="docutils literal"><span class="pre">nv_shader</span></tt> library. Now we need to write the functions that handle commands
from the UI. In the constructor we linked the <tt class="docutils literal"><span class="pre">app-&gt;onAppCmd</span></tt> callback to
the method <tt class="docutils literal"><span class="pre">Engine::handleCmdThunk()</span></tt>; this method just gets a pointer to the
engine object from the app and calls a method which actually handles the commands.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">Engine</span><span class="o">::</span><span class="n">handleCmdThunk</span><span class="p">(</span> <span class="k">struct</span> <span class="n">android_app</span> <span class="o">*</span><span class="n">app</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">cmd</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Get a pointer to the Engine we stored in the Android app</span>
    <span class="n">Engine</span> <span class="o">*</span><span class="n">engine</span> <span class="o">=</span> <span class="p">(</span> <span class="n">Engine</span> <span class="o">*</span> <span class="p">)</span> <span class="n">app</span><span class="o">-&gt;</span><span class="n">userData</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">engine</span> <span class="p">)</span> <span class="p">{</span> <span class="n">engine</span><span class="o">-&gt;</span><span class="n">handleCommand</span><span class="p">(</span> <span class="n">cmd</span> <span class="p">);</span> <span class="p">}</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">Engine</span><span class="o">::</span><span class="n">handleCommand</span><span class="p">(</span> <span class="kt">int</span> <span class="n">cmd</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span><span class="p">(</span> <span class="n">cmd</span> <span class="p">)</span>
    <span class="p">{</span>
    <span class="k">case</span> <span class="n">APP_CMD_INIT_WINDOW</span>:
        <span class="c1">// The window is being shown, get it ready.</span>
        <span class="c1">// Note that on ICS, the EGL size will often be correct for the new size here,</span>
        <span class="c1">// but on HC it will not be.  We need to defer checking the new res until the</span>
        <span class="c1">// first render with the new surface! Fall through to the window resize case.</span>

    <span class="k">case</span> <span class="n">APP_CMD_WINDOW_RESIZED</span>:
        <span class="c1">// A command to resize the window was issued, we need to</span>
        <span class="c1">// redraw it with its new size.</span>
        <span class="n">mEgl</span><span class="p">.</span><span class="n">setWindow</span><span class="p">(</span> <span class="n">mApp</span><span class="o">-&gt;</span><span class="n">window</span> <span class="p">);</span>
        <span class="n">requestForceRender</span><span class="p">();</span>
        <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">APP_CMD_TERM_WINDOW</span>:
        <span class="c1">// The window is being hidden or closed, clean it up.</span>
        <span class="n">mEgl</span><span class="p">.</span><span class="n">setWindow</span><span class="p">(</span> <span class="nb">NULL</span> <span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">APP_CMD_GAINED_FOCUS</span>:
        <span class="c1">// The app window gained focus we need to start rendering it.</span>
        <span class="n">requestForceRender</span><span class="p">();</span>
        <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">APP_CMD_LOST_FOCUS</span>:
        <span class="c1">// The app window lost focus so we need to pause it.</span>
        <span class="c1">// Fall through to the command pause case.</span>

    <span class="k">case</span> <span class="n">APP_CMD_PAUSE</span>:
        <span class="c1">// Move out of active mode if we are in it. But if we are</span>
        <span class="c1">// in another dialog mode, leave it as-is.</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">mActiveMode</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">setActiveMode</span><span class="p">(</span> <span class="nb">false</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">// Note that we still want to render in background.</span>
        <span class="n">requestForceRender</span><span class="p">();</span>
        <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">APP_CMD_CONFIG_CHANGED</span>:
        <span class="c1">// ICS does not appear to require this, but on GB phones,</span>
        <span class="c1">// not having this causes rotation changes to be delayed or</span>
        <span class="c1">// ignored when we&#39;re in a non-rendering mode like autopause.</span>
        <span class="c1">// The forced renders appear to allow GB to process the rotation.</span>
        <span class="n">requestForceRender</span><span class="p">();</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Similarly, in the constructor we also linked the <tt class="docutils literal"><span class="pre">app-&gt;onInputEvent</span></tt> callback to
the method <tt class="docutils literal"><span class="pre">Engine::handleInputThunk()</span></tt>. Finally the method <tt class="docutils literal"><span class="pre">Engine::handleInput()</span></tt>
analyzes the event and either updates the touch positions or, if the event was
a &#8220;back button&#8221; event, handles pausing the app or closing it.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> * Process the next input event.</span>
<span class="cm"> */</span>
<span class="kt">int32_t</span> <span class="n">Engine</span><span class="o">::</span><span class="n">handleInputThunk</span><span class="p">(</span> <span class="k">struct</span> <span class="n">android_app</span> <span class="o">*</span><span class="n">app</span><span class="p">,</span> <span class="n">AInputEvent</span> <span class="o">*</span><span class="n">event</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Get a pointer to the Engine we stored in the Android app</span>
    <span class="n">Engine</span> <span class="o">*</span><span class="n">engine</span> <span class="o">=</span> <span class="p">(</span> <span class="n">Engine</span> <span class="o">*</span> <span class="p">)</span> <span class="n">app</span><span class="o">-&gt;</span><span class="n">userData</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">engine</span> <span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">return</span> <span class="n">engine</span><span class="o">-&gt;</span><span class="n">handleInput</span><span class="p">(</span> <span class="n">event</span> <span class="p">);</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="n">Engine</span><span class="o">::</span><span class="n">handleInput</span><span class="p">(</span> <span class="n">AInputEvent</span> <span class="o">*</span><span class="n">event</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// We only handle motion events (touchscreen) and key (button/key) events</span>
    <span class="kt">int32_t</span> <span class="n">eventType</span> <span class="o">=</span> <span class="n">AInputEvent_getType</span><span class="p">(</span> <span class="n">event</span> <span class="p">);</span>

    <span class="k">if</span><span class="p">(</span> <span class="n">eventType</span> <span class="o">==</span> <span class="n">AINPUT_EVENT_TYPE_MOTION</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int32_t</span> <span class="n">action</span> <span class="o">=</span> <span class="n">AMOTION_EVENT_ACTION_MASK</span> <span class="o">&amp;</span> <span class="n">AMotionEvent_getAction</span><span class="p">(</span> <span class="p">(</span> <span class="k">const</span> <span class="n">AInputEvent</span> <span class="o">*</span> <span class="p">)</span> <span class="n">event</span> <span class="p">);</span>

        <span class="c1">// A tap on the screen takes us out of autopause into active mode if</span>
        <span class="c1">// we were paused.  No other touch processing is done.</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">action</span> <span class="o">==</span> <span class="n">AMOTION_EVENT_ACTION_DOWN</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">setActiveMode</span><span class="p">(</span> <span class="nb">true</span> <span class="p">);</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">mTouchX</span> <span class="o">=</span> <span class="n">AMotionEvent_getX</span><span class="p">(</span> <span class="n">event</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
        <span class="n">mTouchY</span> <span class="o">=</span> <span class="n">AMotionEvent_getY</span><span class="p">(</span> <span class="n">event</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>

        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span> <span class="n">eventType</span> <span class="o">==</span> <span class="n">AINPUT_EVENT_TYPE_KEY</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int32_t</span> <span class="n">code</span> <span class="o">=</span> <span class="n">AKeyEvent_getKeyCode</span><span class="p">(</span> <span class="p">(</span> <span class="k">const</span> <span class="n">AInputEvent</span> <span class="o">*</span> <span class="p">)</span> <span class="n">event</span> <span class="p">);</span>

        <span class="c1">// If we are in active mode, we eat the back button and move into</span>
        <span class="c1">// pause mode.  If we are already in pause mode, we allow the back</span>
        <span class="c1">// button to be handled by the OS, which means we&#39;ll be shut down.</span>
        <span class="k">if</span><span class="p">(</span> <span class="p">(</span> <span class="n">code</span> <span class="o">==</span> <span class="n">AKEYCODE_BACK</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">mActiveMode</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">setActiveMode</span><span class="p">(</span> <span class="nb">false</span> <span class="p">);</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now let&#8217;s write the methods that perform the actual rendering of the frame. We will have an
auxiliary method, <tt class="docutils literal"><span class="pre">Engine::updateFrame()</span></tt> that looks at the status of our application and
decides whether we need to render or not.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">Engine</span><span class="o">::</span><span class="n">updateFrame</span><span class="p">(</span> <span class="kt">bool</span> <span class="n">interactible</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">interactible</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Each frame, we check to see if the window has resized.  While the</span>
        <span class="c1">// various events we get _should_ cover this, in practice, it appears</span>
        <span class="c1">// that the safest move across all platforms and OSes is to check at</span>
        <span class="c1">// the top of each frame.</span>
        <span class="n">checkWindowResized</span><span class="p">();</span>

        <span class="c1">// Time stands still when we&#39;re auto-paused, and we don&#39;t</span>
        <span class="c1">// automatically render.</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">mActiveMode</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// This will try to set up EGL if it isn&#39;t set up.</span>
            <span class="c1">// When we first set up EGL completely, we also load our GLES resources.</span>
            <span class="c1">// If these are already set up or we succeed at setting them all up now, then</span>
            <span class="c1">// we go ahead and render.</span>
            <span class="n">renderFrame</span><span class="p">(</span> <span class="nb">true</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span> <span class="n">isForcedRenderPending</span><span class="p">()</span> <span class="p">)</span> <span class="c1">// forced rendering when needed for UI, etc.</span>
        <span class="p">{</span>
            <span class="c1">// This forces to change the text when paused.</span>
            <span class="n">renderFrame</span><span class="p">(</span> <span class="nb">true</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="c1">// Even if we are not interactive, we may be visible, so we</span>
        <span class="c1">// HAVE to do any forced renderings if we can.  We must also</span>
        <span class="c1">// check for resize, since that may have been the point of the</span>
        <span class="c1">// forced render request in the first place!</span>

        <span class="c1">// Basically it still renders even if the application is not in focus.</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">isForcedRenderPending</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">mEgl</span><span class="p">.</span><span class="n">isReadyToRender</span><span class="p">(</span> <span class="nb">false</span> <span class="p">)</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">checkWindowResized</span><span class="p">();</span>
            <span class="n">renderFrame</span><span class="p">(</span> <span class="nb">false</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The actual method that performs rendering has to first make sure that everything is ready
(EGL ready and UI initialized), then it clears the buffer to the color selected with the
touch position and renders the text:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="n">Engine</span><span class="o">::</span><span class="n">renderFrame</span><span class="p">(</span> <span class="kt">bool</span> <span class="n">allocateIfNeeded</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Check that EGL is ready to render. If allocateIfNeeded</span>
    <span class="c1">// try to also allocate the rendering surface and bind it</span>
    <span class="c1">// to the context.</span>
    <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">mEgl</span><span class="p">.</span><span class="n">isReadyToRender</span><span class="p">(</span> <span class="n">allocateIfNeeded</span> <span class="p">)</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Make sure that the UI is initialized</span>
    <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">initUI</span><span class="p">()</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">LOGW</span><span class="p">(</span> <span class="s">&quot;Could not initialize UI - assets may be missing!&quot;</span> <span class="p">);</span>
        <span class="n">ANativeActivity_finish</span><span class="p">(</span> <span class="n">mApp</span><span class="o">-&gt;</span><span class="n">activity</span> <span class="p">);</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">resizeIfNeeded</span><span class="p">();</span>

    <span class="c1">// Set up viewport</span>
    <span class="n">glViewport</span><span class="p">(</span> <span class="p">(</span> <span class="n">GLint</span> <span class="p">)</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span> <span class="n">GLint</span> <span class="p">)</span> <span class="mi">0</span><span class="p">,</span>
                <span class="p">(</span> <span class="n">GLsizei</span> <span class="p">)(</span> <span class="n">mEgl</span><span class="p">.</span><span class="n">getWidth</span><span class="p">()</span> <span class="p">),</span> <span class="p">(</span> <span class="n">GLsizei</span> <span class="p">)(</span> <span class="n">mEgl</span><span class="p">.</span><span class="n">getHeight</span><span class="p">()</span> <span class="p">)</span> <span class="p">);</span>

    <span class="c1">// Set the clear color...</span>
    <span class="n">glClearColor</span><span class="p">(</span> <span class="p">(</span> <span class="p">(</span> <span class="kt">float</span> <span class="p">)</span> <span class="n">mTouchX</span> <span class="p">)</span> <span class="o">/</span> <span class="p">(</span> <span class="p">(</span> <span class="kt">float</span> <span class="p">)</span> <span class="n">mEgl</span><span class="p">.</span><span class="n">getWidth</span><span class="p">()</span> <span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
                  <span class="p">(</span> <span class="p">(</span> <span class="kt">float</span> <span class="p">)</span> <span class="n">mTouchY</span> <span class="p">)</span> <span class="o">/</span> <span class="p">(</span> <span class="p">(</span> <span class="kt">float</span> <span class="p">)</span> <span class="n">mEgl</span><span class="p">.</span><span class="n">getHeight</span><span class="p">()</span> <span class="p">),</span> <span class="mi">1</span> <span class="p">);</span>
    <span class="c1">// ...and clear.</span>
    <span class="n">glClear</span><span class="p">(</span> <span class="n">GL_COLOR_BUFFER_BIT</span> <span class="o">|</span> <span class="n">GL_DEPTH_BUFFER_BIT</span> <span class="p">);</span>

    <span class="cm">/* Do some rendering here */</span>
    <span class="c1">// ...</span>

    <span class="c1">// Render the bitfont text overlaid here</span>
    <span class="n">NVBFTextRenderPrep</span><span class="p">();</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">uiText</span> <span class="o">=</span> <span class="n">mUiText</span><span class="p">[</span><span class="n">mActiveMode</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">];</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">uiText</span> <span class="p">)</span> <span class="p">{</span> <span class="n">NVBFTextRender</span><span class="p">(</span> <span class="n">uiText</span> <span class="p">);</span> <span class="p">}</span>

    <span class="c1">// Done rendering overlaid text.</span>
    <span class="n">NVBFTextRenderDone</span><span class="p">();</span>

    <span class="k">if</span><span class="p">(</span> <span class="n">mForceRender</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span> <span class="n">mForceRender</span><span class="o">--</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">// Swap the buffers, which indicates we&#39;re done with rendering this frame</span>
    <span class="n">mEgl</span><span class="p">.</span><span class="n">swap</span><span class="p">();</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The magic for rendering with OpenGL ES now happens inside <tt class="docutils literal"><span class="pre">NVBFTextRender()</span></tt> function.
If you browse to its declaration and definition as explained above, you can see that
it is here that the
maths for placing the text is calculated, the texture map containing the text characters
is bound, and so forth.  We will go deeper into all that in the next tutorial.</p>
<p>Let&#8217;s now look at the code for the method <tt class="docutils literal"><span class="pre">Engine::initUI()</span></tt>. It&#8217;s pretty simple, actually.
We just initialize the bitfonts and set the properties for the text that we need to overlay.
Note that EGL was initialized at the Engine construction, as the <tt class="docutils literal"><span class="pre">NvEGLUtil</span> <span class="pre">&amp;mEgl</span></tt> was
constructed.
It&#8217;s also here that <tt class="docutils literal"><span class="pre">NVBFInitialize()</span></tt> is called, it sets up the vertex and fragment
shaders that are used to render the text strings with GL.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="n">Engine</span><span class="o">::</span><span class="n">initUI</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// The UI might have been initialized already</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">mUiInitialized</span> <span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">// Initialize the NVIDIA bitfonts</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">NUM_FONTS</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">NvBool</span> <span class="n">fontsSplit</span><span class="p">[</span><span class="n">NUM_FONTS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="p">};</span> <span class="c1">// all are split</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fontFiles</span><span class="p">[</span><span class="n">NUM_FONTS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;courier+lucida_256.dds&quot;</span><span class="p">,</span> <span class="s">&quot;utahcond+bold_1024.dds&quot;</span> <span class="p">};</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">NVBFInitialize</span><span class="p">(</span> <span class="n">NUM_FONTS</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">**</span><span class="p">)</span> <span class="n">fontFiles</span><span class="p">,</span> <span class="n">fontsSplit</span><span class="p">,</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">LOGW</span><span class="p">(</span> <span class="s">&quot;Could not initialize NvBitFont&quot;</span> <span class="p">);</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Allocate the text for the paused mode and set its properties</span>
    <span class="n">mUiText</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">NVBFTextAlloc</span><span class="p">();</span>
    <span class="n">NVBFTextSetFont</span><span class="p">(</span> <span class="n">mUiText</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span> <span class="p">);</span> <span class="c1">// should look up by font file name</span>
    <span class="n">NVBFTextSetSize</span><span class="p">(</span> <span class="n">mUiText</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">32</span> <span class="p">);</span>
    <span class="n">NVBFTextSetColor</span><span class="p">(</span> <span class="n">mUiText</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">NV_PC_PREDEF_WHITE</span> <span class="p">);</span>
    <span class="n">NVBFTextSetString</span><span class="p">(</span> <span class="n">mUiText</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">NVBF_COLORSTR_RED</span> <span class="n">NVBF_STYLESTR_BOLD</span> <span class="s">&quot;Auto-pause:</span><span class="se">\n</span><span class="s">&quot;</span> <span class="n">NVBF_STYLESTR_NORMAL</span>
    <span class="n">NVBF_COLORSTR_BLUE</span> <span class="s">&quot;Press back to quit</span><span class="se">\n</span><span class="s">Tap window to resume&quot;</span> <span class="p">);</span>

    <span class="c1">// Allocate the text for the active mode and set its properties</span>
    <span class="n">mUiText</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">NVBFTextAlloc</span><span class="p">();</span>
    <span class="n">NVBFTextSetFont</span><span class="p">(</span> <span class="n">mUiText</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span> <span class="p">);</span> <span class="c1">// should look up by font file name</span>
    <span class="n">NVBFTextSetSize</span><span class="p">(</span> <span class="n">mUiText</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">32</span> <span class="p">);</span>
    <span class="n">NVBFTextSetColor</span><span class="p">(</span> <span class="n">mUiText</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">NV_PC_PREDEF_WHITE</span> <span class="p">);</span>
    <span class="n">NVBFTextSetString</span><span class="p">(</span> <span class="n">mUiText</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">NVBF_COLORSTR_GREEN</span> <span class="s">&quot;Active mode!&quot;</span> <span class="p">);</span>

    <span class="n">mUiInitialized</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">Engine::resizeIfNeeded()</span></tt> basically just sets the height and width of the
window and changes the text size accordingly:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="n">Engine</span><span class="o">::</span><span class="n">resizeIfNeeded</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Do we need to resize?</span>
    <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">mResizePending</span> <span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">// Get the target height and width</span>
    <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">mEgl</span><span class="p">.</span><span class="n">getWidth</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">mEgl</span><span class="p">.</span><span class="n">getHeight</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">textHeight</span> <span class="o">=</span> <span class="p">(</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="n">h</span> <span class="p">)</span> <span class="o">?</span> <span class="p">(</span> <span class="n">h</span> <span class="o">/</span> <span class="mi">16</span> <span class="p">)</span> <span class="o">:</span> <span class="p">(</span> <span class="n">w</span> <span class="o">/</span> <span class="mi">16</span> <span class="p">);</span>

    <span class="c1">// Change the resolution to the correct width and height</span>
    <span class="n">NVBFSetScreenRes</span><span class="p">(</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="p">);</span>

    <span class="c1">// Also update the size of the characters</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">mUiText</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">NVBFTextSetSize</span><span class="p">(</span> <span class="n">mUiText</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">textHeight</span> <span class="p">);</span>
        <span class="n">NVBFTextCursorAlign</span><span class="p">(</span> <span class="n">mUiText</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">NVBF_ALIGN_CENTER</span><span class="p">,</span> <span class="n">NVBF_ALIGN_BOTTOM</span> <span class="p">);</span>
        <span class="n">NVBFTextCursorPos</span><span class="p">(</span> <span class="n">mUiText</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">w</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">h</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">mUiText</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">NVBFTextSetSize</span><span class="p">(</span> <span class="n">mUiText</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">textHeight</span> <span class="p">);</span>
        <span class="n">NVBFTextCursorAlign</span><span class="p">(</span> <span class="n">mUiText</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">NVBF_ALIGN_CENTER</span><span class="p">,</span> <span class="n">NVBF_ALIGN_CENTER</span> <span class="p">);</span>
        <span class="n">NVBFTextCursorPos</span><span class="p">(</span> <span class="n">mUiText</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">w</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">h</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="n">mResizePending</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>And finally a couple of auxiliary functions:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">Engine</span><span class="o">::</span><span class="n">setActiveMode</span><span class="p">(</span> <span class="kt">bool</span> <span class="n">running</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">mActiveMode</span> <span class="o">!=</span> <span class="n">running</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">requestForceRender</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">mActiveMode</span> <span class="o">=</span> <span class="n">running</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">bool</span> <span class="n">Engine</span><span class="o">::</span><span class="n">checkWindowResized</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">mEgl</span><span class="p">.</span><span class="n">checkWindowResized</span><span class="p">()</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">mResizePending</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="n">requestForceRender</span><span class="p">();</span>
        <span class="n">LOGI</span><span class="p">(</span> <span class="s">&quot;Window size change %dx%d&quot;</span><span class="p">,</span> <span class="n">mEgl</span><span class="p">.</span><span class="n">getWidth</span><span class="p">(),</span> <span class="n">mEgl</span><span class="p">.</span><span class="n">getHeight</span><span class="p">()</span> <span class="p">);</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We are done with implementing the engine, we now only need to write the main function of our application.
Fill <tt class="docutils literal"><span class="pre">SimpleNativeGL_NV.cpp</span></tt> in the <tt class="docutils literal"><span class="pre">jni</span></tt> folder with this code:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// EGL and GL includes</span>
<span class="cp">#include &lt;EGL/egl.h&gt;</span>
<span class="cp">#include &lt;EGL/eglplatform.h&gt;</span>
<span class="cp">#include &lt;GLES2/gl2.h&gt;</span>

<span class="c1">// NVIDIA helper includes</span>
<span class="cp">#include &lt;nv_and_util/nv_native_app_glue.h&gt;</span>
<span class="cp">#include &lt;nv_egl_util/nv_egl_util.h&gt;</span>

<span class="cp">#include &lt;memory&gt;</span>

<span class="cp">#include &quot;Engine.h&quot;</span>

<span class="cm">/**</span>
<span class="cm"> * This is the main entry point of a native application that is using</span>
<span class="cm"> * android_native_app_glue.  It runs in its own thread, with its own</span>
<span class="cm"> * event loop for receiving input events and doing other things.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">android_main</span><span class="p">(</span> <span class="k">struct</span> <span class="n">android_app</span> <span class="o">*</span><span class="n">app</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Make sure glue isn&#39;t stripped.</span>
    <span class="n">app_dummy</span><span class="p">();</span>

    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">NvEGLUtil</span><span class="o">&gt;</span> <span class="n">egl</span><span class="p">(</span> <span class="n">NvEGLUtil</span><span class="o">::</span><span class="n">create</span><span class="p">()</span> <span class="p">);</span>
    <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">egl</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// If we have a basic EGL failure, we need to exit immediately; nothing else we can do</span>
        <span class="n">nv_app_force_quit_no_cleanup</span><span class="p">(</span> <span class="n">app</span> <span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Engine</span><span class="o">&gt;</span> <span class="n">engine</span><span class="p">(</span> <span class="k">new</span> <span class="n">Engine</span><span class="p">(</span> <span class="o">*</span><span class="n">egl</span><span class="p">,</span> <span class="n">app</span> <span class="p">)</span> <span class="p">);</span>

    <span class="c1">// Loop waiting for stuff to do.</span>
    <span class="k">while</span><span class="p">(</span> <span class="n">nv_app_status_running</span><span class="p">(</span> <span class="n">app</span> <span class="p">)</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Read all pending events.</span>
        <span class="kt">int</span> <span class="n">ident</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">events</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">android_poll_source</span> <span class="o">*</span><span class="n">source</span><span class="p">;</span>

        <span class="c1">// If not rendering, we will block forever waiting for events.</span>
        <span class="c1">// If animating, we loop until all events are read, then continue</span>
        <span class="c1">// to draw the next frame of animation.</span>
        <span class="k">while</span><span class="p">(</span> <span class="p">(</span> <span class="n">ident</span> <span class="o">=</span> <span class="n">ALooper_pollAll</span><span class="p">(</span> <span class="p">(</span> <span class="p">(</span> <span class="n">nv_app_status_focused</span><span class="p">(</span> <span class="n">app</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">engine</span><span class="o">-&gt;</span><span class="n">isActiveMode</span><span class="p">()</span> <span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">250</span> <span class="p">),</span>
                                          <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">events</span><span class="p">,</span> <span class="p">(</span> <span class="kt">void</span> <span class="o">**</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">source</span> <span class="p">)</span> <span class="p">)</span>
               <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// If we timed out, then there are no pending messages.</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">ident</span> <span class="o">==</span> <span class="n">ALOOPER_POLL_TIMEOUT</span> <span class="p">)</span> <span class="p">{</span> <span class="k">break</span><span class="p">;</span> <span class="p">}</span>

            <span class="c1">// Process this event.</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">source</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span>                <span class="p">{</span> <span class="n">source</span><span class="o">-&gt;</span><span class="n">process</span><span class="p">(</span> <span class="n">app</span><span class="p">,</span> <span class="n">source</span> <span class="p">);</span> <span class="p">}</span>

            <span class="c1">// Check if we are exiting.  If so, dump out.</span>
            <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">nv_app_status_running</span><span class="p">(</span> <span class="n">app</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span> <span class="k">break</span><span class="p">;</span> <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// Update the frame, which optionally updates time and animations</span>
        <span class="c1">// and renders.</span>
        <span class="n">engine</span><span class="o">-&gt;</span><span class="n">updateFrame</span><span class="p">(</span> <span class="n">nv_app_status_interactable</span><span class="p">(</span> <span class="n">app</span> <span class="p">)</span> <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Let&#8217;s try to compile the application: right-click on the project folder and select
<cite>Build project</cite>. Even if you followed this tutorial to the letter, you will get errors:</p>
<div class="highlight-python"><pre>../jni/SimpleNativeGL_NV.cpp:32: undefined reference to `Engine::Engine(NvEGLUtil&amp;, android_app*)'
../jni/SimpleNativeGL_NV.cpp:64: undefined reference to `Engine::updateFrame(bool)'
../obj/local/armeabi-v7a/objs/SimpleNativeGL_NV/SimpleNativeGL_NV.o: In function `std::default_delete&lt;Engine&gt;::operator()(Engine*) const':
../android-ndk-r8b/sources/cxx-stl/gnu-libstdc++/4.6/include/bits/unique_ptr.h:63: undefined reference to `Engine::~Engine()'</pre>
</div>
<p>But we did include all the necessary includes! And in fact if you <em>CTRL + click</em>
on the name of the class in the <tt class="docutils literal"><span class="pre">SimpleNativeGL_NV.cpp</span></tt> file, Eclipse will
take you to the <tt class="docutils literal"><span class="pre">Engine.h</span></tt> file...
The problem is that we didn&#8217;t include all the
source files in the <tt class="docutils literal"><span class="pre">Android.mk</span></tt> file, so the compiler does not know that <tt class="docutils literal"><span class="pre">Engine.cpp</span></tt>
is part of the project. However, since we don&#8217;t want to have to modify that file every
time we add a new class we will use wildcards instead. We will replace the line:</p>
<div class="highlight-make"><div class="highlight"><pre><span class="nv">LOCAL_SRC_FILES</span> <span class="o">:=</span> SimpleNativeGL_NV.cpp Engine.cpp
</pre></div>
</div>
<p>with:</p>
<div class="highlight-make"><div class="highlight"><pre><span class="nv">MY_PREFIX</span>           <span class="o">:=</span> <span class="k">$(</span>LOCAL_PATH<span class="k">)</span>
<span class="nv">MY_SOURCES</span>          <span class="o">:=</span> <span class="k">$(</span>wildcard <span class="k">$(</span>LOCAL_PATH<span class="k">)</span>/*.cpp<span class="k">)</span>
<span class="nv">MY_SOURCES</span>          <span class="o">+=</span> <span class="k">$(</span>wildcard <span class="k">$(</span>LOCAL_PATH<span class="k">)</span>/*.c<span class="k">)</span>
<span class="nv">LOCAL_SRC_FILES</span>     <span class="o">+=</span> <span class="k">$(</span>MY_SOURCES:<span class="k">$(</span>MY_PREFIX<span class="k">)</span>%<span class="o">=</span>%<span class="k">)</span>
</pre></div>
</div>
<p>Now let&#8217;s run the application. Right-click on the project folder and select <cite>Run as &gt; Android Application</cite>.
You should see the text &#8220;Active!&#8221; on the screen. Drag your finger around. Notice that if you click on the
back button, for instance, the text will change to reflect that the application has been paused.</p>
<p>This concludes our second GL tutorial.</p>
</div>
<div class="section" id="using-shaders-in-your-gl-project">
<h2>Using shaders in your GL project<a class="headerlink" href="#using-shaders-in-your-gl-project" title="Permalink to this headline">¶</a></h2>
<p>In this third and last GL tutorial we will expand the previous tutorial to explore the use of shaders.
We will create an application which will load an image as a texture; depending on which button
the user presses, we will show either the texture loaded or a filtered version of it. For simplicity
we will implement a <a class="reference external" href="http://en.wikipedia.org/wiki/Sobel_filter">Sobel filter</a> along the vertical
diretion of the image. In addition, we also display the time spent in active mode by the app;
this counter will stop when the application is paused. To get an idea, these are screenshots
for the two states:</p>
<blockquote>
<div><a class="reference internal image-reference" href="_images/GL_PlainShader.png"><img alt="_images/GL_PlainShader.png" src="_images/GL_PlainShader.png" style="width: 409.8px; height: 230.4px;" /></a>
<a class="reference internal image-reference" href="_images/GL_FilterShader.png"><img alt="_images/GL_FilterShader.png" src="_images/GL_FilterShader.png" style="width: 409.8px; height: 230.4px;" /></a>
</div></blockquote>
<p>We assume that you have the previous project in your workspace already, and we will build on it.
If you don&#8217;t have it, please import the <tt class="docutils literal"><span class="pre">SimpleNativeGL_NV</span></tt> project from the <tt class="docutils literal"><span class="pre">tutorials</span></tt> folder.</p>
<p>First we will create the background texture from a regular image. We will need to create a <tt class="docutils literal"><span class="pre">DDS</span></tt>
file.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><tt class="docutils literal"><span class="pre">DDS</span></tt>, (<a class="reference external" href="http://en.wikipedia.org/wiki/DirectDraw_Surface">DirectDraw Surface</a>)
is a compressed picture format whose main advantage over standard <tt class="docutils literal"><span class="pre">jpeg</span></tt> or <tt class="docutils literal"><span class="pre">png</span></tt> formats is
that it is not decompressed before it&#8217;s loaded in memory and is then decompressed in hardware
at access time. Standard image files are usually decompressed (in software) before they are
loaded into memory, and use more space.</p>
</div>
<p>To manipulate DDS files you can use the tools of your choice. GIMP plus the DDS plugin is one
option. NVIDIA also provides a <a class="reference external" href="https://developer.nvidia.com/legacy-texture-tools">set of basic tools</a>
for Windows, we will start there. You can download the DDS utilities, and convert
<a class="reference external" href="http://us.download.nvidia.com/downloads/cool_stuff/wallpapers/NVIDIA_Claw/Claw3_1280x800.jpg">this image</a>
typing in a shell:</p>
<div class="highlight-python"><pre>nvdx -name Claw3_1280x800.jpg -output nvidia_green.dds</pre>
</div>
<p>(Note that the input image does not necessarily need to be *.jpeg,
but there are some constraints as far as the width and height of the input image go).
On Ubuntu you can install the <tt class="docutils literal"><span class="pre">gimp-dds</span></tt> package, open <tt class="docutils literal"><span class="pre">Claw3_1280x800.jpg</span></tt> using GIMP
and save it as <tt class="docutils literal"><span class="pre">nvidia_green.dds</span></tt> selecting DXT5 compression.
Now copy <cite>nvidia_green.dds</cite> in your project&#8217;s <tt class="docutils literal"><span class="pre">assets</span></tt> folder.</p>
<p>Next we want to create the shaders, one to render the original texture and one to render the
Sobel image.
We need to create 4 different files in the <tt class="docutils literal"><span class="pre">assets</span></tt> folder (from the Project Explorer pane,
right-click on the <tt class="docutils literal"><span class="pre">assets</span></tt> folder, then <em>New &gt; File</em>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">plain</span><span class="o">.</span><span class="n">vert</span>
<span class="n">plain</span><span class="o">.</span><span class="n">frag</span>
<span class="nb">filter</span><span class="o">.</span><span class="n">vert</span>
<span class="nb">filter</span><span class="o">.</span><span class="n">frag</span>
</pre></div>
</div>
<p>We will draw a 2D rectangle with vertices (0,0), (1,0), (1,1) and (0,1) to
render the texture on screen. The texture coordinates for each vertex are
the same as their position, drawing the entire texture into the 2D rectangle.
The vertex shader will map each vertex of the rectangle to clip coordinates
in the range [-1,1] on each axis. The vertex shaders are going to be identical
for both the filtered and the original images. Open <cite>plain.vert</cite> and fill it
with this code (and do the same for <cite>filter.vert</cite>):</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">attribute</span> <span class="n">vec2</span> <span class="n">aPos</span><span class="p">;</span>      <span class="c1">// Position, in screen coordinates, passed as an attribute.</span>
<span class="n">attribute</span> <span class="n">vec2</span> <span class="n">aUV</span><span class="p">;</span>       <span class="c1">// Position, in texture coordinates, passed as an attribute.</span>
<span class="n">varying</span>   <span class="n">vec2</span> <span class="n">vTexCoord</span><span class="p">;</span> <span class="c1">// Texture coordinates to be passed as varying to</span>
                          <span class="c1">// the fragment shader.</span>
<span class="n">uniform</span>   <span class="n">vec2</span> <span class="n">uViewMin</span><span class="p">;</span>  <span class="c1">// Bottom left corner of the rectangle in clip coordinates</span>
<span class="n">uniform</span>   <span class="n">vec2</span> <span class="n">uViewDim</span><span class="p">;</span>  <span class="c1">// x,y dimensions of the rectangle in clip coordinates</span>

<span class="cm">/*</span>
<span class="cm"> * This vertex shader maps a 2D vertex to clip coordinates coordinates in the</span>
<span class="cm"> * range specified by uViewMin and uViewDim</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Convert to clip coordinates.</span>
    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span> <span class="n">uViewMin</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">aPos</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">uViewDim</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">uViewMin</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">aPos</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">uViewDim</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span> <span class="p">);</span>

    <span class="c1">// Pass the texture coordinates untouched.</span>
    <span class="n">vTexCoord</span> <span class="o">=</span> <span class="n">aUV</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Basically this vertex shader maps the 2D rectangle to a region of the clip
coordinate space.</p>
<p>The fragment shader to render the original image is very simple too,
as it only sets <tt class="docutils literal"><span class="pre">gl_FragColor</span></tt> to the value of the texture at the
corresponding position:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">precision</span> <span class="n">lowp</span> <span class="kt">float</span><span class="p">;</span>         <span class="c1">// Use low precision for floats.</span>

<span class="n">uniform</span> <span class="n">sampler2D</span>  <span class="n">uTex</span><span class="p">;</span>      <span class="c1">// The texture sampler.</span>
<span class="n">varying</span> <span class="n">vec2</span>       <span class="n">vTexCoord</span><span class="p">;</span> <span class="c1">// Texture coordinates.</span>

<span class="cm">/*</span>
<span class="cm"> * This shader just shows the texture on the screen, without performing any</span>
<span class="cm"> * processing to it. Therefore, just set the color of the fragment to the</span>
<span class="cm"> * same as in the texture.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Look up the texture and set the fragment color</span>
    <span class="c1">// to the same value of the texture at the same location.</span>
    <span class="n">gl_FragColor</span> <span class="o">=</span> <span class="n">texture2D</span><span class="p">(</span> <span class="n">uTex</span><span class="p">,</span> <span class="n">vTexCoord</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The next step is to implement the fragment shader that performs Sobel filtering. Open
the <tt class="docutils literal"><span class="pre">filt.frag</span></tt> fragment shader and paste in the following code:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">precision</span> <span class="n">mediump</span> <span class="kt">float</span><span class="p">;</span>      <span class="c1">// Use medium precision for floats.</span>

<span class="n">uniform</span> <span class="n">vec2</span>      <span class="n">uD</span><span class="p">;</span>         <span class="c1">// Step size corresponding to one pixel in the texture.</span>
<span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">uTex</span><span class="p">;</span>       <span class="c1">// The texture sampler.</span>
<span class="n">varying</span> <span class="n">vec2</span>      <span class="n">vTexCoord</span><span class="p">;</span>  <span class="c1">// Texture coordinates.</span>

<span class="cm">/*</span>
<span class="cm"> * This very simple fragment performs a y gradient (using Sobel filter)</span>
<span class="cm"> * to the green channel of the texture.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// The origin is in the bottom-left corner, with the y axis</span>
    <span class="c1">// pointing up, and the texture coordinates go from 0 to 1.</span>

    <span class="c1">// Let&#39;s accumulate fragment color using a vertical Sobel filter,</span>
    <span class="c1">// with the following weights:</span>
    <span class="c1">//</span>
    <span class="c1">//   -1   -2   -1</span>
    <span class="c1">//    0    0    0</span>
    <span class="c1">//    1    2    1</span>
    <span class="c1">//</span>
    <span class="c1">// We get the colors by doing lookups in the texture map with</span>
    <span class="c1">// correct offsets.</span>

    <span class="n">gl_FragColor</span>  <span class="o">=</span>       <span class="n">texture2D</span><span class="p">(</span> <span class="n">uTex</span><span class="p">,</span> <span class="n">vTexCoord</span> <span class="o">+</span> <span class="n">vec2</span><span class="p">(</span> <span class="o">-</span><span class="n">uD</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">uD</span><span class="p">.</span><span class="n">y</span> <span class="p">)</span> <span class="p">);</span>
    <span class="n">gl_FragColor</span> <span class="o">+=</span> <span class="mi">2</span>   <span class="o">*</span> <span class="n">texture2D</span><span class="p">(</span> <span class="n">uTex</span><span class="p">,</span> <span class="n">vTexCoord</span> <span class="o">+</span> <span class="n">vec2</span><span class="p">(</span>   <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="n">uD</span><span class="p">.</span><span class="n">y</span> <span class="p">)</span> <span class="p">);</span>
    <span class="n">gl_FragColor</span> <span class="o">+=</span>       <span class="n">texture2D</span><span class="p">(</span> <span class="n">uTex</span><span class="p">,</span> <span class="n">vTexCoord</span> <span class="o">+</span> <span class="n">vec2</span><span class="p">(</span>  <span class="n">uD</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">uD</span><span class="p">.</span><span class="n">y</span> <span class="p">)</span> <span class="p">);</span>
    <span class="n">gl_FragColor</span> <span class="o">-=</span>       <span class="n">texture2D</span><span class="p">(</span> <span class="n">uTex</span><span class="p">,</span> <span class="n">vTexCoord</span> <span class="o">+</span> <span class="n">vec2</span><span class="p">(</span> <span class="o">-</span><span class="n">uD</span><span class="p">.</span><span class="n">x</span><span class="p">,</span>  <span class="n">uD</span><span class="p">.</span><span class="n">y</span> <span class="p">)</span> <span class="p">);</span>
    <span class="n">gl_FragColor</span> <span class="o">-=</span> <span class="mi">2</span>   <span class="o">*</span> <span class="n">texture2D</span><span class="p">(</span> <span class="n">uTex</span><span class="p">,</span> <span class="n">vTexCoord</span> <span class="o">+</span> <span class="n">vec2</span><span class="p">(</span>   <span class="mf">0.0</span><span class="p">,</span>  <span class="n">uD</span><span class="p">.</span><span class="n">y</span> <span class="p">)</span> <span class="p">);</span>
    <span class="n">gl_FragColor</span> <span class="o">-=</span>       <span class="n">texture2D</span><span class="p">(</span> <span class="n">uTex</span><span class="p">,</span> <span class="n">vTexCoord</span> <span class="o">+</span> <span class="n">vec2</span><span class="p">(</span>  <span class="n">uD</span><span class="p">.</span><span class="n">x</span><span class="p">,</span>  <span class="n">uD</span><span class="p">.</span><span class="n">y</span> <span class="p">)</span> <span class="p">);</span>

    <span class="c1">// ... and compute the color of this fragment (we set alpha to 1).</span>
    <span class="n">gl_FragColor</span><span class="p">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">gl_FragColor</span><span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">gl_FragColor</span><span class="p">.</span><span class="n">g</span><span class="p">;</span>
    <span class="n">gl_FragColor</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We are done with the shaders implementation. Now we will add a couple of classes to our
project. Right-click on the <tt class="docutils literal"><span class="pre">jni</span></tt> folder under your project in the Project Explorer pane and
select <em>New &gt; Class</em>. Call it <tt class="docutils literal"><span class="pre">RectShader</span></tt> (unselect the <cite>Namespace</cite> checkbox
if necessary). We will use this class to load and compile the shaders. In fact
we will create one object of this class per shader. An instance of the <tt class="docutils literal"><span class="pre">RectShader</span></tt>
class will compute the uniforms for the vertex shader based on the current
screen size and the choice of stretching or preserving the image aspect ratio. When
stretching is selected the 2D rectangle is mapped to the entire clip coordinates
range. If we choose to keep the aspect ratio, the corresponding origin and size
of the rectangle in clip space coordinates is computed and assigned to the
<tt class="docutils literal"><span class="pre">uViewMin</span></tt> and <tt class="docutils literal"><span class="pre">uViewDim</span></tt> uniforms. The header file of our class
will be:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#ifndef RECT_SHADER_H_</span>
<span class="cp">#define RECT_SHADER_H_</span>

<span class="cp">#include &lt;GLES2/gl2.h&gt;</span>

<span class="k">class</span> <span class="nc">RectShader</span>
<span class="p">{</span>
<span class="nl">public:</span>

    <span class="k">enum</span> <span class="n">ImageRowStorage</span>
    <span class="p">{</span>
      <span class="c1">// First byte in memory is top row</span>
        <span class="n">STORAGE_TOP_FIRST</span>   <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

        <span class="c1">// First byte in memory is bottom row</span>
        <span class="n">STORAGE_BOTTOM_FIRST</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="p">};</span>

    <span class="k">enum</span> <span class="n">ImageAspectRatio</span>
    <span class="p">{</span>
        <span class="n">ASPECT_RATIO_KEEP</span>       <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">ASPECT_RATIO_STRETCH</span>    <span class="o">=</span> <span class="mi">2</span>
    <span class="p">};</span>

    <span class="cm">/*</span>
<span class="cm">     * Load, compile, and initialize the shader.</span>
<span class="cm">     */</span>
    <span class="n">RectShader</span><span class="p">(</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">shaderName</span> <span class="p">);</span>

    <span class="cm">/*</span>
<span class="cm">     * Destructor.</span>
<span class="cm">     */</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">RectShader</span><span class="p">();</span>


    <span class="cm">/*</span>
<span class="cm">     * Set the attributes of the shader.</span>
<span class="cm">     */</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">bind</span><span class="p">(</span> <span class="k">const</span> <span class="n">GLfloat</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="k">const</span> <span class="n">GLfloat</span> <span class="n">uvs</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="p">);</span>

    <span class="cm">/*</span>
<span class="cm">     * Set the viewport aspect ratio</span>
<span class="cm">     */</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">setViewportAspectRatio</span><span class="p">(</span> <span class="kt">float</span> <span class="n">width</span><span class="p">,</span> <span class="kt">float</span> <span class="n">height</span> <span class="p">);</span>

    <span class="cm">/*</span>
<span class="cm">     * To be called when the image size changes. Set image size, which</span>
<span class="cm">     * row is zero, and if we want to keep the aspect ratio or fit the image</span>
<span class="cm">     */</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">setImageSize</span><span class="p">(</span> <span class="kt">float</span> <span class="n">width</span><span class="p">,</span> <span class="kt">float</span> <span class="n">height</span><span class="p">,</span>
                               <span class="n">ImageRowStorage</span> <span class="n">zeroRow</span> <span class="o">=</span> <span class="n">STORAGE_TOP_FIRST</span><span class="p">,</span>
                               <span class="n">ImageAspectRatio</span> <span class="n">aspect</span> <span class="o">=</span> <span class="n">ASPECT_RATIO_STRETCH</span> <span class="p">);</span>

    <span class="cm">/*</span>
<span class="cm">     * Returns the origin of the rectangle in viewport coordinates</span>
<span class="cm">     */</span>
    <span class="kt">void</span> <span class="n">getOrigUniform</span><span class="p">(</span> <span class="n">GLfloat</span> <span class="n">origin</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="cm">/*</span>
<span class="cm">     * Returns the dimensions of the rectangle in viewport coordinates</span>
<span class="cm">     */</span>
    <span class="kt">void</span> <span class="n">getDimUniform</span><span class="p">(</span> <span class="n">GLfloat</span> <span class="n">dim</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>


<span class="nl">protected:</span>
    <span class="cm">/* Functions */</span>

    <span class="cm">/*</span>
<span class="cm">     * Computes the viewport region the current image will take.</span>
<span class="cm">     */</span>
    <span class="kt">void</span> <span class="nf">updateClipRegion</span><span class="p">();</span>

    <span class="cm">/* Variables */</span>
    <span class="n">GLint</span> <span class="n">mProgram</span><span class="p">;</span>   <span class="c1">// The shader</span>
    <span class="n">GLint</span> <span class="n">mPosAttrib</span><span class="p">;</span> <span class="c1">// Attribute for the surface corners in screen coordinates</span>
    <span class="n">GLint</span> <span class="n">mUvAttrib</span><span class="p">;</span>  <span class="c1">// Attribute for the surface corners in GL coordinates</span>

    <span class="n">GLint</span> <span class="n">mDUniform</span><span class="p">;</span>        <span class="c1">// uD uniform location</span>
    <span class="n">GLint</span> <span class="n">mViewOrigUniform</span><span class="p">;</span> <span class="c1">// uViewOrig uniform location</span>
    <span class="n">GLint</span> <span class="n">mViewDimUniform</span><span class="p">;</span>  <span class="c1">// uViewDim uniform location</span>

    <span class="n">GLfloat</span> <span class="n">mViewOrig</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>   <span class="c1">// Current clip coordinates rectangle origin</span>
    <span class="n">GLfloat</span> <span class="n">mViewDim</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>    <span class="c1">// Current clip coordinates rectangle dimension</span>
    <span class="n">GLfloat</span> <span class="n">mTexelDelta</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// Current texel delta value</span>

    <span class="kt">float</span> <span class="n">mRectAspectRatio</span><span class="p">;</span>     <span class="c1">// The rectangle aspect ratio w / h</span>
    <span class="kt">float</span> <span class="n">mViewportAspectRatio</span><span class="p">;</span> <span class="c1">// The viewport aspect ratio w / h</span>

    <span class="n">ImageRowStorage</span>     <span class="n">mZeroRowPos</span><span class="p">;</span>     <span class="c1">// Location of zero row (top or bottom)</span>
    <span class="n">ImageAspectRatio</span>    <span class="n">mAspectBehavior</span><span class="p">;</span> <span class="c1">// Keep or stretch aspect ratio.</span>
<span class="p">};</span>

<span class="cp">#endif </span><span class="cm">/* RECT_SHADER_H_ */</span><span class="cp"></span>
</pre></div>
</div>
<p>Now let&#8217;s move to <tt class="docutils literal"><span class="pre">RectShader.cpp</span></tt>. After adding the necessary includes:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;RectShader.h&quot;</span>
<span class="cp">#include &lt;GLES2/gl2ext.h&gt;</span>

<span class="c1">// NVIDIA helper include</span>
<span class="cp">#include &lt;nv_shader/nv_shader.h&gt;</span>
</pre></div>
</div>
<p>Let&#8217;s look at the constructor. Basically the constructor takes the shader&#8217;s file name;
it then loads and compiles the program and caches the location of its attributes and
uniforms. Finally, it initializes the rectangle and screen aspect ratio to default
values. The aspect ratios will be recomputed every time either the screen or the image
size change. We will have an object for each shader so that these initialization
operations are only performed once:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">RectShader</span><span class="o">::</span><span class="n">RectShader</span><span class="p">(</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">shaderName</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Load the fragment and vertex shaders.</span>
    <span class="n">mProgram</span> <span class="o">=</span> <span class="n">nv_load_program</span><span class="p">(</span> <span class="n">shaderName</span> <span class="p">);</span>

    <span class="c1">// Compile, link, and attach the shader to the program.</span>
    <span class="n">glUseProgram</span><span class="p">(</span> <span class="n">mProgram</span> <span class="p">);</span>

    <span class="c1">// Get pointers to the attributes in the program.</span>
    <span class="n">mPosAttrib</span> <span class="o">=</span> <span class="n">glGetAttribLocation</span><span class="p">(</span> <span class="n">mProgram</span><span class="p">,</span> <span class="s">&quot;aPos&quot;</span> <span class="p">);</span>
    <span class="n">mUvAttrib</span>  <span class="o">=</span> <span class="n">glGetAttribLocation</span><span class="p">(</span> <span class="n">mProgram</span><span class="p">,</span> <span class="s">&quot;aUV&quot;</span> <span class="p">);</span>

    <span class="c1">// Set up the texture sampler to texture unit 0</span>
    <span class="n">GLint</span> <span class="n">texUni</span> <span class="o">=</span> <span class="n">glGetUniformLocation</span><span class="p">(</span> <span class="n">mProgram</span><span class="p">,</span> <span class="s">&quot;uTex&quot;</span> <span class="p">);</span>
    <span class="n">glUniform1i</span><span class="p">(</span> <span class="n">texUni</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>

    <span class="c1">// Get the location of the uniforms we will be udpating</span>
    <span class="n">mViewOrigUniform</span> <span class="o">=</span> <span class="n">glGetUniformLocation</span><span class="p">(</span> <span class="n">mProgram</span><span class="p">,</span> <span class="s">&quot;uViewMin&quot;</span> <span class="p">);</span>
    <span class="n">mViewDimUniform</span>  <span class="o">=</span> <span class="n">glGetUniformLocation</span><span class="p">(</span> <span class="n">mProgram</span><span class="p">,</span> <span class="s">&quot;uViewDim&quot;</span> <span class="p">);</span>
    <span class="n">mDUniform</span>        <span class="o">=</span> <span class="n">glGetUniformLocation</span><span class="p">(</span> <span class="n">mProgram</span><span class="p">,</span> <span class="s">&quot;uD&quot;</span> <span class="p">);</span>

    <span class="c1">// Initialize some default values for aspect ratio and uniforms.</span>
    <span class="n">mViewportAspectRatio</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>
    <span class="n">mRectAspectRatio</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>
    <span class="n">mTexelDelta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">mTexelDelta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>
    <span class="n">mZeroRowPos</span> <span class="o">=</span> <span class="n">STORAGE_TOP_FIRST</span><span class="p">;</span>
    <span class="n">mAspectBehavior</span> <span class="o">=</span> <span class="n">ASPECT_RATIO_KEEP</span><span class="p">;</span>

    <span class="n">updateViewportRegion</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">RectShader::bind()</span></tt> actually activates the shader (via the call to <tt class="docutils literal"><span class="pre">glUseProgram()</span></tt>),
sets the attributes to the arguments passed to the function and the uniforms to the values
that have already been computed.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">RectShader</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span> <span class="k">const</span> <span class="n">GLfloat</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="k">const</span> <span class="n">GLfloat</span> <span class="n">uvs</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Install the program object as a part of the current rendering state.</span>
    <span class="n">glUseProgram</span><span class="p">(</span> <span class="n">mProgram</span> <span class="p">);</span>

    <span class="c1">// Disable VBO&#39;s (vertex buffer objects) for attributes.</span>
    <span class="n">glBindBuffer</span><span class="p">(</span> <span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="n">glBindBuffer</span><span class="p">(</span> <span class="n">GL_ELEMENT_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>

    <span class="c1">// Set the attribute mPosAttrib with the vertices in the screen coordinates...</span>
    <span class="n">glVertexAttribPointer</span><span class="p">(</span> <span class="n">mPosAttrib</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vertices</span> <span class="p">);</span>
    <span class="c1">// ... and enable it.</span>
    <span class="n">glEnableVertexAttribArray</span><span class="p">(</span> <span class="n">mPosAttrib</span> <span class="p">);</span>

    <span class="c1">// Set the attribute mUvAttrib with the vertices in the GL coordinates...</span>
    <span class="n">glVertexAttribPointer</span><span class="p">(</span> <span class="n">mUvAttrib</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">uvs</span> <span class="p">);</span>
    <span class="c1">// ... and enable it.</span>
    <span class="n">glEnableVertexAttribArray</span><span class="p">(</span> <span class="n">mUvAttrib</span> <span class="p">);</span>

    <span class="c1">// Update the uniforms</span>
    <span class="n">glUniform2f</span><span class="p">(</span> <span class="n">mViewOrigUniform</span><span class="p">,</span> <span class="n">mViewOrig</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mViewOrig</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">);</span>
    <span class="n">glUniform2f</span><span class="p">(</span> <span class="n">mViewDimUniform</span><span class="p">,</span>  <span class="n">mViewDim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">,</span> <span class="n">mViewDim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">);</span>
    <span class="n">glUniform2f</span><span class="p">(</span> <span class="n">mDUniform</span><span class="p">,</span> <span class="n">mTexelDelta</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mTexelDelta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The vertex buffer objects (VBO) are a caching mechanism which allows to keep the vertex
data in the high-peformance graphics memory and render directly from there, removing
the need to resend the data every time a primitive is drawn. In this example,
we are disabling VBOs since the number of vertices small.</p>
<p>We now add functions to be called when the screen size or the image
size change. These functions update the aspect ratios and call
<tt class="docutils literal"><span class="pre">updateClipRegion()</span></tt> to compute the new values for the uniforms.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">RectShader</span><span class="o">::</span><span class="n">setViewportAspectRatio</span><span class="p">(</span> <span class="kt">float</span> <span class="n">width</span><span class="p">,</span> <span class="kt">float</span> <span class="n">height</span><span class="p">)</span>
<span class="p">{</span>
   <span class="c1">// Update the viewport aspect ration</span>
   <span class="n">mViewportAspectRatio</span> <span class="o">=</span> <span class="n">width</span> <span class="o">/</span> <span class="n">height</span><span class="p">;</span>

   <span class="c1">// Update the viewport region the image will cover.</span>
   <span class="n">updateCliptRegion</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">RectShader</span><span class="o">::</span><span class="n">setImageSize</span><span class="p">(</span> <span class="kt">float</span> <span class="n">width</span><span class="p">,</span> <span class="kt">float</span> <span class="n">height</span><span class="p">,</span> <span class="n">ImageRowStorage</span> <span class="n">zeroRowPos</span><span class="p">,</span> <span class="n">ImageAspectRatio</span> <span class="n">aspect</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="c1">// Update the rectangle aspect ratio</span>
   <span class="n">mRectAspectRatio</span> <span class="o">=</span> <span class="n">width</span> <span class="o">/</span> <span class="n">height</span><span class="p">;</span>
   <span class="n">mZeroRowPos</span> <span class="o">=</span> <span class="n">zeroRowPos</span><span class="p">;</span>
   <span class="n">mAspectBehavior</span> <span class="o">=</span> <span class="n">aspect</span><span class="p">;</span>

   <span class="c1">// Update the texel delta.</span>
   <span class="n">mTexelDelta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0f</span> <span class="o">/</span> <span class="n">width</span><span class="p">;</span>
   <span class="n">mTexelDelta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0f</span> <span class="o">/</span> <span class="n">height</span><span class="p">;</span>

   <span class="c1">// Update the viewport region the image will cover.</span>
   <span class="n">updateClipRegion</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">updateClipRegion</span></tt> function computes the new clip coordinates area
that the rectangle will take based on the choice to keep the aspect ratio
of the image or stretch it to fill the entire screen. In addition, if
the top row is stored first in memory (as it is usually for images),
we flip the vertical axis. This is because OpenGL assumes the first
byte in the image is the bottom row. See the
<a class="reference external" href="http://www.khronos.org/opengles/sdk/docs/man/xhtml/glTexImage2D.xml">glTexImage2D reference</a>
for more details.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">RectShader</span><span class="o">::</span><span class="n">updateClipRegion</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mAspectBehavior</span> <span class="o">==</span> <span class="n">ASPECT_RATIO_KEEP</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">mViewportAspectRatio</span> <span class="o">&gt;</span> <span class="n">mRectAspectRatio</span> <span class="p">)</span>
      <span class="p">{</span>
         <span class="c1">// Viewport is wider than rectangle</span>
         <span class="c1">// Use entire viewport height and clip width</span>
         <span class="n">mViewOrig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0f</span> <span class="o">+</span> <span class="p">(</span><span class="n">mViewportAspectRatio</span> <span class="o">-</span> <span class="n">mRectAspectRatio</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0f</span><span class="p">;</span>
         <span class="n">mViewOrig</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0f</span><span class="p">;</span>
         <span class="n">mViewDim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span>  <span class="mf">2.0f</span> <span class="o">-</span> <span class="p">(</span><span class="n">mViewportAspectRatio</span> <span class="o">-</span> <span class="n">mRectAspectRatio</span><span class="p">);</span>
         <span class="n">mViewDim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>  <span class="mf">2.0f</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span>
      <span class="p">{</span>
         <span class="c1">// Viewport is taller than rectangle</span>
         <span class="c1">// Use entire viewport width and clip height</span>
         <span class="n">mViewOrig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0f</span><span class="p">;</span>
         <span class="n">mViewOrig</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0f</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0f</span> <span class="o">/</span> <span class="n">mViewportAspectRatio</span> <span class="o">-</span> <span class="mf">1.0f</span> <span class="o">/</span> <span class="n">mRectAspectRatio</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0f</span><span class="p">;</span>
         <span class="n">mViewDim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span>  <span class="mf">2.0f</span><span class="p">;</span>
         <span class="n">mViewDim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>  <span class="mf">2.0f</span> <span class="o">-</span> <span class="p">(</span><span class="mf">1.0f</span> <span class="o">/</span> <span class="n">mViewportAspectRatio</span> <span class="o">-</span> <span class="mf">1.0f</span> <span class="o">/</span> <span class="n">mRectAspectRatio</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
      <span class="n">mViewOrig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">mViewOrig</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0f</span><span class="p">;</span>
      <span class="n">mViewDim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">mViewDim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0f</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// If zero row is at the top, we need to flip the vertical signs</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">mZeroRowPos</span> <span class="o">==</span> <span class="n">STORAGE_TOP_FIRST</span> <span class="p">)</span>
    <span class="p">{</span>
      <span class="n">mViewOrig</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">mViewOrig</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
      <span class="n">mViewDim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">mViewDim</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Finally, we add to functions to return the values of the computed
uniforms. We will pass these values to other shaders when we
draw features on top of the image in the next section.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">RectShader</span><span class="o">::</span><span class="n">getOrigUniform</span><span class="p">(</span><span class="n">GLfloat</span> <span class="n">origin</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="k">const</span>
<span class="p">{</span>
   <span class="n">origin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">mViewOrig</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
   <span class="n">origin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">mViewOrig</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">RectShader</span><span class="o">::</span><span class="n">getDimUniform</span><span class="p">(</span><span class="n">GLfloat</span> <span class="n">dim</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="k">const</span>
<span class="p">{</span>
   <span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">mViewDim</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
   <span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">mViewDim</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the destructor we only need to delete the program and we&#8217;re done:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">RectShader</span><span class="o">::~</span><span class="n">RectShader</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Delete the program object</span>
    <span class="n">glDeleteProgram</span><span class="p">(</span> <span class="n">mProgram</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now we need one more class. Create a class called <tt class="docutils literal"><span class="pre">DrawRect</span></tt>, which will select the
correct shader to use and will perform the actual rendering. The header file is really
simple and it should only contain the following code:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#ifndef DRAW_RECT_H</span>
<span class="cp">#define DRAW_RECT_H</span>

<span class="cp">#include &lt;GLES2/gl2.h&gt;</span>

<span class="k">class</span> <span class="nc">RectShader</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">DrawRect</span>
<span class="p">{</span>
<span class="nl">public:</span>

    <span class="n">DrawRect</span><span class="p">();</span>

    <span class="cm">/*</span>
<span class="cm">     * Set what shader should be used to render the texture.</span>
<span class="cm">     */</span>
    <span class="kt">void</span> <span class="nf">setShader</span><span class="p">(</span> <span class="n">RectShader</span> <span class="o">*</span><span class="n">shader</span> <span class="p">);</span>

    <span class="cm">/*</span>
<span class="cm">     * Render the texture.</span>
<span class="cm">     */</span>
    <span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span> <span class="n">GLint</span> <span class="n">tex</span> <span class="p">);</span>

<span class="nl">private:</span>

    <span class="n">RectShader</span> <span class="o">*</span><span class="n">mShader</span><span class="p">;</span>      <span class="c1">// Pointer to the current shader</span>
<span class="p">};</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p>The cpp file is very straight-forward too:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;DrawRect.h&quot;</span>
<span class="cp">#include &quot;RectShader.h&quot;</span>

<span class="k">static</span> <span class="n">GLushort</span> <span class="n">indices</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">};</span>

<span class="k">static</span> <span class="n">GLfloat</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>
                               <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>
                               <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span>
                               <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span> <span class="p">};</span>

<span class="k">static</span> <span class="n">GLfloat</span> <span class="n">uvs</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span>      <span class="p">{</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>
                               <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>
                               <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span>
                               <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span> <span class="p">};</span>

<span class="n">DrawRect</span><span class="o">::</span><span class="n">DrawRect</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">mShader</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">DrawRect</span><span class="o">::</span><span class="n">setShader</span><span class="p">(</span> <span class="n">RectShader</span> <span class="o">*</span><span class="n">shader</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">mShader</span> <span class="o">=</span> <span class="n">shader</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">DrawRect</span><span class="o">::</span><span class="n">draw</span><span class="p">(</span> <span class="n">GLint</span> <span class="n">tex</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Initialize the shader.</span>
    <span class="n">mShader</span><span class="o">-&gt;</span><span class="n">bind</span><span class="p">(</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">uvs</span> <span class="p">);</span>

    <span class="c1">// Select the active texture unit.</span>
    <span class="n">glActiveTexture</span><span class="p">(</span> <span class="n">GL_TEXTURE0</span> <span class="p">);</span>

    <span class="c1">// Bind our texture to the texturing target.</span>
    <span class="n">glBindTexture</span><span class="p">(</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">tex</span> <span class="p">);</span>

    <span class="c1">// Perform the actual drawing.</span>
    <span class="n">glDrawElements</span><span class="p">(</span> <span class="n">GL_TRIANGLE_STRIP</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">GL_UNSIGNED_SHORT</span><span class="p">,</span> <span class="n">indices</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now we need to modify the Engine class. First, in the header file, we need to add a couple
of includes:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &lt;nv_ui/nv_ui_rect.h&gt;</span>

<span class="cp">#include &lt;memory&gt;</span>
<span class="cp">#include &lt;vector&gt;</span>

<span class="cp">#include &quot;DrawRect.h&quot;</span>
<span class="cp">#include &quot;RectShader.h&quot;</span>
</pre></div>
</div>
<p>Then we need to change <tt class="docutils literal"><span class="pre">updateFrame</span></tt> to take a time step argument,
and add a method that advances time:</p>
<div class="highlight-c++"><div class="highlight"><pre> <span class="kt">void</span> <span class="nf">updateFrame</span><span class="p">(</span> <span class="kt">bool</span> <span class="n">interactible</span><span class="p">,</span> <span class="kt">long</span> <span class="n">deltaTime</span> <span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Advance the time counter by the amount of time elapsed.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">advanceTime</span><span class="p">(</span> <span class="kt">long</span> <span class="n">deltaTime</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">mTimeVal</span> <span class="o">+=</span> <span class="n">deltaTime</span> <span class="o">*</span> <span class="mf">0.001</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Finally we need a few member variables:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Texture and shaders</span>
<span class="n">GLuint</span>                      <span class="n">mImgTexture</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">DrawRect</span><span class="o">&gt;</span>   <span class="n">mDrawRect</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">RectShader</span><span class="o">&gt;</span> <span class="n">mRectShader</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

<span class="c1">// Variables for the UI</span>
<span class="n">NvUIRect</span> <span class="n">mUiButtonZone</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="kt">void</span>    <span class="o">*</span><span class="n">mClockText</span><span class="p">;</span>
<span class="kt">void</span>    <span class="o">*</span><span class="n">mUiPauseText</span><span class="p">;</span>
<span class="kt">void</span>    <span class="o">*</span><span class="n">mUiButton</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="kt">int</span>      <span class="n">mHitButton</span><span class="p">;</span>
<span class="kt">double</span>   <span class="n">mTimeVal</span><span class="p">;</span>
</pre></div>
</div>
<p>But we are not going to use a couple of the old variables so you can remove the following:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="o">*</span><span class="n">mUiText</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="kt">int</span>   <span class="n">mTouchX</span><span class="p">,</span> <span class="n">mTouchY</span><span class="p">;</span>
</pre></div>
</div>
<p>Now we need to change the implementation of a few functions in the cpp file, but first we need to
add an include and define a couple of colors for the UI:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &lt;nv_glesutil/nv_images.h&gt;</span>

<span class="c1">// Define packed colors</span>
<span class="n">NvPackedColor</span> <span class="n">activeColor</span>   <span class="o">=</span> <span class="n">NV_PACKED_COLOR</span><span class="p">(</span> <span class="mi">250</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">255</span> <span class="p">);</span>
<span class="n">NvPackedColor</span> <span class="n">deactiveColor</span> <span class="o">=</span> <span class="n">NV_PACKED_COLOR</span><span class="p">(</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span> <span class="p">);</span>
</pre></div>
</div>
<p>The constructor and destructor aren&#8217;t changed much, we just need to initialize a bunch of
different UI components and free them:</p>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="n">Engine</span><span class="o">::</span><span class="n">Engine</span><span class="p">(</span> <span class="n">NvEGLUtil</span> <span class="o">&amp;</span> <span class="n">egl</span><span class="p">,</span> <span class="k">struct</span> <span class="n">android_app</span> <span class="o">*</span><span class="n">app</span> <span class="p">)</span>
      <span class="o">:</span> <span class="n">mEgl</span><span class="p">(</span> <span class="n">egl</span> <span class="p">),</span> <span class="n">mApp</span><span class="p">(</span> <span class="n">app</span> <span class="p">),</span> <span class="n">mResizePending</span><span class="p">(</span> <span class="nb">false</span> <span class="p">),</span> <span class="n">mActiveMode</span><span class="p">(</span> <span class="nb">true</span> <span class="p">),</span>
        <span class="n">mForceRender</span><span class="p">(</span> <span class="n">FRAMES_TO_RENDER</span> <span class="p">),</span> <span class="n">mUiInitialized</span><span class="p">(</span> <span class="nb">false</span> <span class="p">)</span>
  <span class="p">{</span>
      <span class="c1">// Save a pointer to the engine in the Android app</span>
      <span class="n">app</span><span class="o">-&gt;</span><span class="n">userData</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>

      <span class="c1">// Save pointers to the implementation of the callback functions in the</span>
      <span class="c1">// Android app</span>
      <span class="n">app</span><span class="o">-&gt;</span><span class="n">onAppCmd</span>     <span class="o">=</span> <span class="o">&amp;</span><span class="n">Engine</span><span class="o">::</span><span class="n">handleCmdThunk</span><span class="p">;</span>
      <span class="n">app</span><span class="o">-&gt;</span><span class="n">onInputEvent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Engine</span><span class="o">::</span><span class="n">handleInputThunk</span><span class="p">;</span>

      <span class="c1">// Initialize the nv_shader library</span>
      <span class="n">nv_shader_init</span><span class="p">(</span> <span class="n">app</span><span class="o">-&gt;</span><span class="n">activity</span><span class="o">-&gt;</span><span class="n">assetManager</span> <span class="p">);</span>

<span class="hll">      <span class="c1">// Initialize all the UI components</span>
</span><span class="hll">      <span class="n">mClockText</span>   <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="hll">      <span class="n">mUiPauseText</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="hll">      <span class="n">mUiButton</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="hll">      <span class="n">mUiButton</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="hll">      <span class="n">mHitButton</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="hll">
</span><span class="hll">      <span class="c1">// Initialize the mDrawRect and mRectShader objects</span>
</span><span class="hll">      <span class="n">mDrawRect</span>      <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="hll">      <span class="n">mRectShader</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="hll">      <span class="n">mRectShader</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="hll">
</span><span class="hll">      <span class="c1">// Initialize the texture</span>
</span><span class="hll">      <span class="n">mImgTexture</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="hll">      <span class="c1">// Initialize the time counter</span>
</span><span class="hll">      <span class="n">mTimeVal</span>       <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span>  <span class="p">}</span>

  <span class="n">Engine</span><span class="o">::~</span><span class="n">Engine</span><span class="p">()</span>
  <span class="p">{</span>
      <span class="c1">// Free the allocated BitFonts</span>
<span class="hll">      <span class="n">NVBFTextFree</span><span class="p">(</span> <span class="n">mUiButton</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">);</span>
</span><span class="hll">      <span class="n">NVBFTextFree</span><span class="p">(</span> <span class="n">mUiButton</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">);</span>
</span><span class="hll">      <span class="n">NVBFTextFree</span><span class="p">(</span> <span class="n">mUiPauseText</span> <span class="p">);</span>
</span><span class="hll">      <span class="n">NVBFTextFree</span><span class="p">(</span> <span class="n">mClockText</span> <span class="p">);</span>
</span>      <span class="n">NVBFCleanup</span><span class="p">();</span>

<span class="hll">      <span class="c1">// Delete the texture</span>
</span><span class="hll">      <span class="n">glDeleteTextures</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mImgTexture</span> <span class="p">);</span>
</span>  <span class="p">}</span>
</pre></div>
</div>
<p>The method <tt class="docutils literal"><span class="pre">Engine::handleInput()</span></tt> needs to be changed to account for the fact that, instead of
tracking the touch positions, we now need to detect and save which button has been pressed by
the user:</p>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="kt">int</span> <span class="n">Engine</span><span class="o">::</span><span class="n">handleInput</span><span class="p">(</span> <span class="n">AInputEvent</span> <span class="o">*</span><span class="n">event</span> <span class="p">)</span>
  <span class="p">{</span>
      <span class="c1">//We only handle motion events (touchscreen) and key (button/key) events</span>
      <span class="kt">int32_t</span> <span class="n">eventType</span> <span class="o">=</span> <span class="n">AInputEvent_getType</span><span class="p">(</span> <span class="n">event</span> <span class="p">);</span>

      <span class="k">if</span><span class="p">(</span> <span class="n">eventType</span> <span class="o">==</span> <span class="n">AINPUT_EVENT_TYPE_MOTION</span> <span class="p">)</span>
      <span class="p">{</span>
          <span class="kt">int32_t</span> <span class="n">action</span> <span class="o">=</span> <span class="n">AMOTION_EVENT_ACTION_MASK</span> <span class="o">&amp;</span> <span class="n">AMotionEvent_getAction</span><span class="p">(</span> <span class="p">(</span> <span class="k">const</span> <span class="n">AInputEvent</span> <span class="o">*</span> <span class="p">)</span><span class="n">event</span> <span class="p">);</span>

<span class="hll">          <span class="kt">int32_t</span> <span class="n">mx</span> <span class="o">=</span> <span class="n">AMotionEvent_getX</span><span class="p">(</span> <span class="n">event</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
</span><span class="hll">          <span class="kt">int32_t</span> <span class="n">my</span> <span class="o">=</span> <span class="n">AMotionEvent_getY</span><span class="p">(</span> <span class="n">event</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
</span><span class="hll">
</span><span class="hll">          <span class="k">if</span><span class="p">(</span> <span class="n">isActiveMode</span><span class="p">()</span> <span class="p">)</span>
</span><span class="hll">          <span class="p">{</span>
</span><span class="hll">              <span class="c1">// Check if the touch was inside of the first button...</span>
</span><span class="hll">              <span class="k">if</span><span class="p">(</span> <span class="n">mUiButtonZone</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">inside</span><span class="p">(</span> <span class="n">mx</span><span class="p">,</span> <span class="n">my</span> <span class="p">)</span> <span class="p">)</span>      <span class="p">{</span> <span class="n">mHitButton</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
</span><span class="hll">              <span class="c1">// ... or the second</span>
</span><span class="hll">              <span class="k">else</span> <span class="k">if</span><span class="p">(</span> <span class="n">mUiButtonZone</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">inside</span><span class="p">(</span> <span class="n">mx</span><span class="p">,</span> <span class="n">my</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span> <span class="n">mHitButton</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
</span><span class="hll">          <span class="p">}</span>
</span><span class="hll">          <span class="k">else</span>
</span><span class="hll">          <span class="p">{</span>
</span><span class="hll">              <span class="c1">// A tap on the screen takes us out of autopause into active mode if</span>
</span><span class="hll">              <span class="c1">// we were paused.  No other touch processing is done.</span>
</span><span class="hll">              <span class="k">if</span><span class="p">(</span> <span class="n">action</span> <span class="o">==</span> <span class="n">AMOTION_EVENT_ACTION_DOWN</span> <span class="p">)</span>
</span><span class="hll">              <span class="p">{</span>
</span><span class="hll">                  <span class="n">setActiveMode</span><span class="p">(</span> <span class="nb">true</span> <span class="p">);</span>
</span><span class="hll">                  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="hll">              <span class="p">}</span>
</span><span class="hll">          <span class="p">}</span>
</span><span class="hll">          <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span>      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span><span class="p">(</span> <span class="n">eventType</span> <span class="o">==</span> <span class="n">AINPUT_EVENT_TYPE_KEY</span> <span class="p">)</span>
      <span class="p">{</span>
          <span class="kt">int32_t</span> <span class="n">code</span> <span class="o">=</span> <span class="n">AKeyEvent_getKeyCode</span><span class="p">(</span> <span class="p">(</span> <span class="k">const</span> <span class="n">AInputEvent</span> <span class="o">*</span> <span class="p">)</span> <span class="n">event</span> <span class="p">);</span>

          <span class="c1">// if we are in active mode, we eat the back button and move into</span>
          <span class="c1">// pause mode.  If we are already in pause mode, we allow the back</span>
          <span class="c1">// button to be handled by the OS, which means we&#39;ll be shut down</span>
          <span class="k">if</span><span class="p">(</span> <span class="p">(</span> <span class="n">code</span> <span class="o">==</span> <span class="n">AKEYCODE_BACK</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">mActiveMode</span> <span class="p">)</span>
          <span class="p">{</span>
              <span class="n">setActiveMode</span><span class="p">(</span> <span class="nb">false</span> <span class="p">);</span>
              <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div>
</div>
<p>In <tt class="docutils literal"><span class="pre">Engine::updateFrame()</span></tt> we only need to add a couple of lines of code to advance
the clock:</p>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="kt">void</span> <span class="n">Engine</span><span class="o">::</span><span class="n">updateFrame</span><span class="p">(</span> <span class="kt">bool</span> <span class="n">interactible</span><span class="p">,</span> <span class="kt">long</span> <span class="n">deltaTime</span> <span class="p">)</span>
  <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span> <span class="n">interactible</span> <span class="p">)</span>
      <span class="p">{</span>
          <span class="c1">// Each frame, we check to see if the window has resized.  While the</span>
          <span class="c1">// various events we get _should_ cover this, in practice, it appears</span>
          <span class="c1">// that the safest move across all platforms and OSes is to check at</span>
          <span class="c1">// the top of each frame</span>
          <span class="n">checkWindowResized</span><span class="p">();</span>

          <span class="c1">// Time stands still when we&#39;re auto-paused, and we don&#39;t</span>
          <span class="c1">// automatically render</span>
          <span class="k">if</span><span class="p">(</span> <span class="n">mActiveMode</span> <span class="p">)</span>
          <span class="p">{</span>
<span class="hll">              <span class="c1">// The time needs to advance in active mode.</span>
</span><span class="hll">              <span class="n">advanceTime</span><span class="p">(</span> <span class="n">deltaTime</span> <span class="p">);</span>
</span>
              <span class="c1">// This will try to set up EGL if it isn&#39;t set up</span>
              <span class="c1">// When we first set up EGL completely, we also load our GLES resources</span>
              <span class="c1">// If these are already set up or we succeed at setting them all up now, then</span>
              <span class="c1">// we go ahead and render.</span>
              <span class="n">renderFrame</span><span class="p">(</span> <span class="nb">true</span> <span class="p">);</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span><span class="p">(</span> <span class="n">isForcedRenderPending</span><span class="p">()</span> <span class="p">)</span>  <span class="c1">// forced rendering when needed for UI, etc.</span>
          <span class="p">{</span>
              <span class="c1">// This forces to render.</span>
              <span class="n">renderFrame</span><span class="p">(</span> <span class="nb">true</span> <span class="p">);</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">else</span>
      <span class="p">{</span>
          <span class="c1">// Even if we are not interactible, we may be visible, so we</span>
          <span class="c1">// HAVE to do any forced renderings if we can.  We must also</span>
          <span class="c1">// check for resize, since that may have been the point of the</span>
          <span class="c1">// forced render request in the first place!</span>
          <span class="k">if</span><span class="p">(</span> <span class="n">isForcedRenderPending</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">mEgl</span><span class="p">.</span><span class="n">isReadyToRender</span><span class="p">(</span> <span class="nb">false</span> <span class="p">)</span> <span class="p">)</span>
          <span class="p">{</span>
              <span class="n">checkWindowResized</span><span class="p">();</span>
              <span class="n">renderFrame</span><span class="p">(</span> <span class="nb">false</span> <span class="p">);</span>
          <span class="p">}</span>
      <span class="p">}</span>
  <span class="p">}</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">Engine::renderFrame()</span></tt> is very similar to the previous example as well,
but we need to select the shader based on the button that was pressed, and render the
button (change colors depeding on selection) and the clock:</p>
<div class="highlight-c++"><div class="highlight"><pre> <span class="kt">bool</span> <span class="n">Engine</span><span class="o">::</span><span class="n">renderFrame</span><span class="p">(</span> <span class="kt">bool</span> <span class="n">allocateIfNeeded</span> <span class="p">)</span>
 <span class="p">{</span>
     <span class="c1">// Check that EGL is ready to render. If allocateIfNeeded</span>
     <span class="c1">// try to also allocate the rendering surface and bind it</span>
     <span class="c1">// to the context.</span>
     <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">mEgl</span><span class="p">.</span><span class="n">isReadyToRender</span><span class="p">(</span> <span class="n">allocateIfNeeded</span> <span class="p">)</span> <span class="p">)</span>
     <span class="p">{</span>
         <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
     <span class="p">}</span>

     <span class="c1">// Make sure that the UI is initialized</span>
     <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">initUI</span><span class="p">()</span> <span class="p">)</span>
     <span class="p">{</span>
         <span class="n">LOGW</span><span class="p">(</span> <span class="s">&quot;Could not initialize UI - assets may be missing!&quot;</span> <span class="p">);</span>
         <span class="n">ANativeActivity_finish</span><span class="p">(</span> <span class="n">mApp</span><span class="o">-&gt;</span><span class="n">activity</span> <span class="p">);</span>
         <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
     <span class="p">}</span>
     <span class="n">resizeIfNeeded</span><span class="p">();</span>

     <span class="c1">// Set up viewport</span>
     <span class="n">glViewport</span><span class="p">(</span> <span class="p">(</span> <span class="n">GLint</span> <span class="p">)</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span> <span class="n">GLint</span> <span class="p">)</span><span class="mi">0</span><span class="p">,</span>
                 <span class="p">(</span> <span class="n">GLsizei</span> <span class="p">)(</span> <span class="n">mEgl</span><span class="p">.</span><span class="n">getWidth</span><span class="p">()</span> <span class="p">),</span> <span class="p">(</span> <span class="n">GLsizei</span> <span class="p">)(</span> <span class="n">mEgl</span><span class="p">.</span><span class="n">getHeight</span><span class="p">()</span> <span class="p">)</span> <span class="p">);</span>

<span class="hll">     <span class="c1">// Clear buffers as necessary</span>
</span><span class="hll">     <span class="n">glClear</span><span class="p">(</span> <span class="n">GL_COLOR_BUFFER_BIT</span> <span class="o">|</span> <span class="n">GL_DEPTH_BUFFER_BIT</span> <span class="p">);</span>
</span><span class="hll">
</span><span class="hll">     <span class="cm">/* Do some rendering here */</span>
</span><span class="hll">
</span><span class="hll">     <span class="c1">// Based on the button that is selected choose the shader that should be used...</span>
</span><span class="hll">     <span class="n">mDrawRect</span><span class="o">-&gt;</span><span class="n">setShader</span><span class="p">(</span> <span class="n">mRectShader</span><span class="p">[</span><span class="n">mHitButton</span><span class="p">].</span><span class="n">get</span><span class="p">()</span> <span class="p">);</span>
</span><span class="hll">     <span class="c1">// ... and pass the texture to the shader.</span>
</span><span class="hll">     <span class="n">mDrawRect</span><span class="o">-&gt;</span><span class="n">draw</span><span class="p">(</span> <span class="n">mImgTexture</span> <span class="p">);</span>
</span><span class="hll">
</span><span class="hll">     <span class="c1">// Render the rendering bitfont text overlaid here.</span>
</span><span class="hll">     <span class="n">NVBFTextRenderPrep</span><span class="p">();</span>
</span><span class="hll">
</span><span class="hll">     <span class="c1">// Update the clock.</span>
</span><span class="hll">     <span class="k">if</span><span class="p">(</span> <span class="n">mClockText</span> <span class="p">)</span>
</span><span class="hll">     <span class="p">{</span>
</span><span class="hll">         <span class="c1">// Set the correct color depending on the mActiveMode</span>
</span><span class="hll">         <span class="n">NVBFTextSetMultiplyColor</span><span class="p">(</span> <span class="n">mClockText</span><span class="p">,</span>
</span><span class="hll">                                   <span class="n">mActiveMode</span> <span class="o">?</span> <span class="n">activeColor</span> <span class="o">:</span> <span class="n">deactiveColor</span> <span class="p">);</span>
</span><span class="hll">         <span class="n">NVBFTextRender</span><span class="p">(</span> <span class="n">mClockText</span> <span class="p">);</span>
</span><span class="hll">
</span><span class="hll">         <span class="c1">// We update the clock text &gt;after&lt; rendering, so it will change on pause.</span>
</span><span class="hll">         <span class="kt">int</span> <span class="n">mins</span> <span class="o">=</span> <span class="n">mTimeVal</span> <span class="o">/</span> <span class="mi">60</span><span class="p">;</span>
</span><span class="hll">         <span class="kt">float</span> <span class="n">secs</span> <span class="o">=</span> <span class="p">(</span> <span class="kt">float</span> <span class="p">)</span><span class="n">mTimeVal</span> <span class="o">-</span> <span class="n">mins</span> <span class="o">*</span> <span class="mi">60</span><span class="p">;</span>
</span><span class="hll">         <span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
</span><span class="hll">         <span class="n">sprintf</span><span class="p">(</span> <span class="n">str</span><span class="p">,</span> <span class="s">&quot;%03d:%05.2f&quot;</span><span class="p">,</span> <span class="n">mins</span><span class="p">,</span> <span class="n">secs</span> <span class="p">);</span>
</span><span class="hll">         <span class="n">NVBFTextSetString</span><span class="p">(</span> <span class="n">mClockText</span><span class="p">,</span> <span class="n">str</span> <span class="p">);</span>
</span><span class="hll">     <span class="p">}</span>
</span><span class="hll">
</span><span class="hll">     <span class="c1">// Render the buttons.</span>
</span><span class="hll">     <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">mActiveMode</span> <span class="p">)</span>
</span><span class="hll">     <span class="p">{</span>
</span><span class="hll">         <span class="n">NVBFTextRender</span><span class="p">(</span> <span class="n">mUiPauseText</span> <span class="p">);</span>
</span><span class="hll">     <span class="p">}</span>
</span><span class="hll">     <span class="k">else</span>
</span><span class="hll">     <span class="p">{</span>
</span><span class="hll">         <span class="n">NVBFTextSetMultiplyColor</span><span class="p">(</span> <span class="n">mUiButton</span><span class="p">[</span><span class="n">mHitButton</span><span class="p">],</span> <span class="n">activeColor</span> <span class="p">);</span>
</span><span class="hll">         <span class="n">NVBFTextSetMultiplyColor</span><span class="p">(</span> <span class="n">mUiButton</span><span class="p">[(</span> <span class="n">mHitButton</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">],</span> <span class="n">deactiveColor</span> <span class="p">);</span>
</span><span class="hll">         <span class="n">NVBFTextRender</span><span class="p">(</span> <span class="n">mUiButton</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">);</span>
</span><span class="hll">         <span class="n">NVBFTextRender</span><span class="p">(</span> <span class="n">mUiButton</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">);</span>
</span><span class="hll">     <span class="p">}</span>
</span>
     <span class="c1">// Done rendering overlaid text.</span>
     <span class="n">NVBFTextRenderDone</span><span class="p">();</span>

     <span class="k">if</span><span class="p">(</span> <span class="n">mForceRender</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span> <span class="n">mForceRender</span><span class="o">--</span><span class="p">;</span> <span class="p">}</span>

     <span class="c1">// Swap the buffers, which indicates we&#39;re done with rendering this frame</span>
     <span class="n">mEgl</span><span class="p">.</span><span class="n">swap</span><span class="p">();</span>

     <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
 <span class="p">}</span>
</pre></div>
</div>
<p>In the methods <tt class="docutils literal"><span class="pre">Engine::initUI()</span></tt> and <tt class="docutils literal"><span class="pre">Engine::resizeIfNeeded()</span></tt> we just need to allocate or
update different UI components or objects:</p>
<div class="highlight-c++"><div class="highlight"><pre> <span class="kt">bool</span> <span class="n">Engine</span><span class="o">::</span><span class="n">initUI</span><span class="p">()</span>
 <span class="p">{</span>
     <span class="c1">// The UI might have been initialized already</span>
     <span class="k">if</span><span class="p">(</span> <span class="n">mUiInitialized</span> <span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>

     <span class="n">LOGD</span><span class="p">(</span> <span class="s">&quot;Initializing UI&quot;</span> <span class="p">);</span>

     <span class="c1">// Initialize the NVIDIA bitfonts</span>
     <span class="k">const</span> <span class="kt">int</span> <span class="n">NUM_FONTS</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
     <span class="k">static</span> <span class="n">NvBool</span> <span class="n">fontsSplit</span><span class="p">[</span><span class="n">NUM_FONTS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span> <span class="c1">// all are split</span>
     <span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">fontFiles</span><span class="p">[</span><span class="n">NUM_FONTS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;courier+lucida_256.dds&quot;</span><span class="p">,</span> <span class="s">&quot;utahcond+bold_1024.dds&quot;</span> <span class="p">};</span>
     <span class="k">if</span><span class="p">(</span> <span class="n">NVBFInitialize</span><span class="p">(</span> <span class="n">NUM_FONTS</span><span class="p">,</span> <span class="p">(</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span> <span class="p">)</span><span class="n">fontFiles</span><span class="p">,</span> <span class="n">fontsSplit</span><span class="p">,</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">)</span>
     <span class="p">{</span>
         <span class="n">LOGW</span><span class="p">(</span> <span class="s">&quot;Could not initialize NvBitFont&quot;</span> <span class="p">);</span>
         <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
     <span class="p">}</span>

     <span class="c1">// Allocate the text for the clock and set its properties</span>
     <span class="n">mClockText</span> <span class="o">=</span> <span class="n">NVBFTextAlloc</span><span class="p">();</span>
<span class="hll">     <span class="n">NVBFTextSetFont</span><span class="p">(</span> <span class="n">mClockText</span><span class="p">,</span> <span class="mi">1</span> <span class="p">);</span> <span class="c1">// should look up by font file name.</span>
</span><span class="hll">     <span class="n">NVBFTextSetSize</span><span class="p">(</span> <span class="n">mClockText</span><span class="p">,</span> <span class="mi">32</span> <span class="p">);</span>
</span><span class="hll">     <span class="n">NVBFTextSetColor</span><span class="p">(</span> <span class="n">mClockText</span><span class="p">,</span> <span class="n">NV_PC_PREDEF_WHITE</span> <span class="p">);</span>
</span><span class="hll">     <span class="n">NVBFTextSetString</span><span class="p">(</span> <span class="n">mClockText</span><span class="p">,</span> <span class="s">&quot;000:00.00&quot;</span> <span class="p">);</span>
</span><span class="hll">
</span><span class="hll">     <span class="c1">// Allocate the text for the text of the autopause mode and set its properties</span>
</span><span class="hll">     <span class="n">mUiPauseText</span> <span class="o">=</span> <span class="n">NVBFTextAlloc</span><span class="p">();</span>
</span><span class="hll">     <span class="n">NVBFTextSetFont</span><span class="p">(</span> <span class="n">mUiPauseText</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span> <span class="c1">// should look up by font file name.</span>
</span><span class="hll">     <span class="n">NVBFTextSetSize</span><span class="p">(</span> <span class="n">mUiPauseText</span><span class="p">,</span> <span class="mi">32</span> <span class="p">);</span>
</span><span class="hll">     <span class="n">NVBFTextSetColor</span><span class="p">(</span> <span class="n">mUiPauseText</span><span class="p">,</span> <span class="n">NV_PC_PREDEF_WHITE</span> <span class="p">);</span>
</span><span class="hll">     <span class="n">NVBFTextSetString</span><span class="p">(</span> <span class="n">mUiPauseText</span><span class="p">,</span>
</span><span class="hll">                        <span class="n">NVBF_COLORSTR_RED</span> <span class="n">NVBF_STYLESTR_BOLD</span> <span class="s">&quot;Auto-pause:</span><span class="se">\n</span><span class="s">&quot;</span> <span class="n">NVBF_STYLESTR_NORMAL</span>
</span><span class="hll">                        <span class="n">NVBF_COLORSTR_BLUE</span> <span class="s">&quot;Press back to quit</span><span class="se">\n</span><span class="s">Tap window to resume&quot;</span> <span class="p">);</span>
</span><span class="hll">
</span><span class="hll">     <span class="c1">// UI Buttons</span>
</span><span class="hll">     <span class="n">mUiButton</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">NVBFTextAlloc</span><span class="p">();</span>
</span><span class="hll">     <span class="n">NVBFTextSetFont</span><span class="p">(</span> <span class="n">mUiButton</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span> <span class="p">);</span> <span class="c1">// should look up by font file name.</span>
</span><span class="hll">     <span class="n">NVBFTextSetSize</span><span class="p">(</span> <span class="n">mUiButton</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">48</span> <span class="p">);</span>
</span><span class="hll">     <span class="n">NVBFTextSetColor</span><span class="p">(</span> <span class="n">mUiButton</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">NV_PC_PREDEF_WHITE</span> <span class="p">);</span>
</span><span class="hll">     <span class="n">NVBFTextSetShadow</span><span class="p">(</span> <span class="n">mUiButton</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">5</span><span class="p">,</span> <span class="n">NV_PC_PREDEF_BLACK</span> <span class="p">);</span>
</span><span class="hll">     <span class="n">NVBFTextSetString</span><span class="p">(</span> <span class="n">mUiButton</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">NVBF_STYLESTR_BOLD</span> <span class="s">&quot;ON&quot;</span> <span class="p">);</span>
</span><span class="hll">
</span><span class="hll">     <span class="n">mUiButton</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">NVBFTextAlloc</span><span class="p">();</span>
</span><span class="hll">     <span class="n">NVBFTextSetFont</span><span class="p">(</span> <span class="n">mUiButton</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span> <span class="p">);</span> <span class="c1">// should look up by font file name.</span>
</span><span class="hll">     <span class="n">NVBFTextSetSize</span><span class="p">(</span> <span class="n">mUiButton</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">48</span> <span class="p">);</span>
</span><span class="hll">     <span class="n">NVBFTextSetColor</span><span class="p">(</span> <span class="n">mUiButton</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">NV_PC_PREDEF_WHITE</span> <span class="p">);</span>
</span><span class="hll">     <span class="n">NVBFTextSetShadow</span><span class="p">(</span> <span class="n">mUiButton</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">5</span><span class="p">,</span> <span class="n">NV_PC_PREDEF_BLACK</span> <span class="p">);</span>
</span><span class="hll">     <span class="n">NVBFTextSetString</span><span class="p">(</span> <span class="n">mUiButton</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">NVBF_STYLESTR_BOLD</span> <span class="s">&quot;OFF&quot;</span> <span class="p">);</span>
</span><span class="hll">
</span><span class="hll">     <span class="c1">// Set the correct button as active.</span>
</span><span class="hll">     <span class="n">mHitButton</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="hll">     <span class="n">NVBFTextSetMultiplyColor</span><span class="p">(</span> <span class="n">mUiButton</span><span class="p">[</span><span class="n">mHitButton</span><span class="p">],</span> <span class="n">activeColor</span> <span class="p">);</span>
</span><span class="hll">
</span><span class="hll">     <span class="c1">// Load the texture image</span>
</span><span class="hll">     <span class="n">mImgTexture</span> <span class="o">=</span> <span class="n">NvCreateTextureFromDDSEx</span><span class="p">(</span> <span class="s">&quot;nvidia_green.dds&quot;</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">);</span>
</span><span class="hll">
</span><span class="hll">     <span class="c1">// Allocate the objects</span>
</span><span class="hll">     <span class="n">mDrawRect</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span> <span class="k">new</span> <span class="n">DrawRect</span> <span class="p">);</span>
</span><span class="hll">     <span class="n">mRectShader</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">reset</span><span class="p">(</span> <span class="k">new</span> <span class="n">RectShader</span><span class="p">(</span> <span class="s">&quot;filter&quot;</span> <span class="p">)</span> <span class="p">);</span>
</span><span class="hll">     <span class="n">mRectShader</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">setImageSize</span><span class="p">(</span> <span class="mf">1366.0</span><span class="p">,</span> <span class="mf">720.0</span><span class="p">,</span>
</span><span class="hll">                      <span class="n">RectShader</span><span class="o">::</span><span class="n">STORAGE_TOP_FIRST</span><span class="p">,</span> <span class="n">RectShader</span><span class="o">::</span><span class="n">ASPECT_RATIO_STRETCH</span> <span class="p">);</span>
</span><span class="hll">     <span class="n">mRectShader</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">reset</span><span class="p">(</span> <span class="k">new</span> <span class="n">RectShader</span><span class="p">(</span> <span class="s">&quot;plain&quot;</span> <span class="p">)</span> <span class="p">);</span>
</span><span class="hll">     <span class="n">mRectShader</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">setImageSize</span><span class="p">(</span> <span class="mf">1366.0</span><span class="p">,</span> <span class="mf">720.0</span><span class="p">,</span>
</span><span class="hll">                      <span class="n">RectShader</span><span class="o">::</span><span class="n">STORAGE_TOP_FIRST</span><span class="p">,</span> <span class="n">RectShader</span><span class="o">::</span><span class="n">ASPECT_RATIO_STRETCH</span> <span class="p">);</span>
</span>
     <span class="n">mUiInitialized</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

     <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
 <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="n">Engine</span><span class="o">::</span><span class="n">resizeIfNeeded</span><span class="p">()</span>
<span class="p">{</span>
   <span class="c1">// Do we need to resize?</span>
   <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">mResizePending</span> <span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>

   <span class="c1">// Get the target height and width</span>
   <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">mEgl</span><span class="p">.</span><span class="n">getWidth</span><span class="p">();</span>
   <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">mEgl</span><span class="p">.</span><span class="n">getHeight</span><span class="p">();</span>
   <span class="kt">int</span> <span class="n">textHeight</span> <span class="o">=</span> <span class="p">(</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="n">h</span> <span class="p">)</span> <span class="o">?</span> <span class="p">(</span> <span class="n">h</span> <span class="o">/</span> <span class="mi">16</span> <span class="p">)</span> <span class="o">:</span> <span class="p">(</span> <span class="n">w</span> <span class="o">/</span> <span class="mi">16</span> <span class="p">);</span>

   <span class="c1">// Change the resolution to the correct width and height</span>
   <span class="n">NVBFSetScreenRes</span><span class="p">(</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="p">);</span>

   <span class="c1">// Also update the size of the characters and their location</span>
<span class="hll">   <span class="k">if</span><span class="p">(</span> <span class="n">mClockText</span> <span class="p">)</span>
</span><span class="hll">   <span class="p">{</span>
</span><span class="hll">      <span class="n">NVBFTextSetSize</span><span class="p">(</span> <span class="n">mClockText</span><span class="p">,</span> <span class="n">textHeight</span> <span class="p">);</span>
</span><span class="hll">      <span class="n">NVBFTextCursorAlign</span><span class="p">(</span> <span class="n">mClockText</span><span class="p">,</span> <span class="n">NVBF_ALIGN_LEFT</span><span class="p">,</span> <span class="n">NVBF_ALIGN_TOP</span> <span class="p">);</span>
</span><span class="hll">      <span class="n">NVBFTextCursorPos</span><span class="p">(</span> <span class="n">mClockText</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span> <span class="p">);</span>
</span><span class="hll">   <span class="p">}</span>
</span><span class="hll">   <span class="k">if</span><span class="p">(</span> <span class="n">mUiPauseText</span> <span class="p">)</span>
</span><span class="hll">   <span class="p">{</span>
</span><span class="hll">      <span class="n">NVBFTextSetSize</span><span class="p">(</span> <span class="n">mUiPauseText</span><span class="p">,</span> <span class="n">textHeight</span> <span class="p">);</span>
</span><span class="hll">      <span class="n">NVBFTextCursorAlign</span><span class="p">(</span> <span class="n">mUiPauseText</span><span class="p">,</span> <span class="n">NVBF_ALIGN_CENTER</span><span class="p">,</span> <span class="n">NVBF_ALIGN_BOTTOM</span> <span class="p">);</span>
</span><span class="hll">      <span class="n">NVBFTextCursorPos</span><span class="p">(</span> <span class="n">mUiPauseText</span><span class="p">,</span> <span class="n">w</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">h</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">);</span>
</span><span class="hll">   <span class="p">}</span>
</span><span class="hll">   <span class="k">if</span><span class="p">(</span> <span class="n">mUiButton</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>
</span><span class="hll">   <span class="p">{</span>
</span><span class="hll">      <span class="n">NVBFTextSetSize</span><span class="p">(</span> <span class="n">mUiButton</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">textHeight</span> <span class="p">);</span>
</span><span class="hll">      <span class="n">NVBFTextCursorAlign</span><span class="p">(</span> <span class="n">mUiButton</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">NVBF_ALIGN_RIGHT</span><span class="p">,</span> <span class="n">NVBF_ALIGN_BOTTOM</span> <span class="p">);</span>
</span><span class="hll">      <span class="n">NVBFTextCursorPos</span><span class="p">(</span> <span class="n">mUiButton</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">w</span> <span class="o">-</span> <span class="n">textHeight</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">h</span> <span class="o">-</span> <span class="mi">10</span> <span class="p">);</span>
</span><span class="hll">      <span class="n">mUiButtonZone</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">set</span><span class="p">(</span> <span class="n">w</span> <span class="o">-</span> <span class="n">textHeight</span> <span class="o">*</span> <span class="mi">6</span><span class="p">,</span> <span class="n">h</span> <span class="o">-</span> <span class="mi">10</span> <span class="o">-</span> <span class="n">textHeight</span><span class="p">,</span> <span class="n">textHeight</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">textHeight</span> <span class="p">);</span>
</span><span class="hll">
</span><span class="hll">   <span class="p">}</span>
</span><span class="hll">   <span class="k">if</span><span class="p">(</span> <span class="n">mUiButton</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span>
</span><span class="hll">   <span class="p">{</span>
</span><span class="hll">      <span class="n">NVBFTextSetSize</span><span class="p">(</span> <span class="n">mUiButton</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">textHeight</span> <span class="p">);</span>
</span><span class="hll">      <span class="n">NVBFTextCursorAlign</span><span class="p">(</span> <span class="n">mUiButton</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">NVBF_ALIGN_RIGHT</span><span class="p">,</span> <span class="n">NVBF_ALIGN_BOTTOM</span> <span class="p">);</span>
</span><span class="hll">      <span class="n">NVBFTextCursorPos</span><span class="p">(</span> <span class="n">mUiButton</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">w</span> <span class="o">-</span> <span class="n">textHeight</span><span class="p">,</span> <span class="n">h</span> <span class="o">-</span> <span class="mi">10</span> <span class="p">);</span>
</span><span class="hll">      <span class="n">mUiButtonZone</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">set</span><span class="p">(</span> <span class="n">w</span> <span class="o">-</span> <span class="n">textHeight</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="n">h</span> <span class="o">-</span> <span class="mi">10</span> <span class="o">-</span> <span class="n">textHeight</span><span class="p">,</span> <span class="n">textHeight</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">textHeight</span> <span class="p">);</span>
</span><span class="hll">   <span class="p">}</span>
</span><span class="hll">
</span><span class="hll">   <span class="k">if</span><span class="p">(</span> <span class="n">mRectShader</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">get</span><span class="p">()</span> <span class="o">!=</span> <span class="n">nullptr</span> <span class="p">)</span>
</span><span class="hll">   <span class="p">{</span>
</span><span class="hll">     <span class="n">mRectShader</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">setViewportAspectRatio</span><span class="p">(</span> <span class="p">(</span> <span class="kt">float</span> <span class="p">)</span> <span class="n">w</span><span class="p">,</span> <span class="kt">float</span><span class="p">(</span> <span class="n">h</span> <span class="p">)</span> <span class="p">);</span>
</span><span class="hll">   <span class="p">}</span>
</span><span class="hll">   <span class="k">if</span><span class="p">(</span> <span class="n">mRectShader</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">get</span><span class="p">()</span> <span class="o">!=</span> <span class="n">nullptr</span> <span class="p">)</span>
</span><span class="hll">   <span class="p">{</span>
</span><span class="hll">     <span class="n">mRectShader</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">setViewportAspectRatio</span><span class="p">(</span> <span class="p">(</span> <span class="kt">float</span> <span class="p">)</span> <span class="n">w</span><span class="p">,</span> <span class="kt">float</span><span class="p">(</span> <span class="n">h</span> <span class="p">)</span> <span class="p">);</span>
</span><span class="hll">   <span class="p">}</span>
</span>
   <span class="n">mResizePending</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

   <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We need also to update our call to <tt class="docutils literal"><span class="pre">updateFrame</span></tt> in <tt class="docutils literal"><span class="pre">SimpleNativeGL_NV.cpp</span></tt> to pass the
time delta since the last call to <tt class="docutils literal"><span class="pre">updateFrame</span></tt>. Open <tt class="docutils literal"><span class="pre">SimpleNativeGL_NV.cpp</span></tt> and add the
following lines:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Engine</span><span class="o">&gt;</span> <span class="n">engine</span><span class="p">(</span> <span class="k">new</span> <span class="n">Engine</span><span class="p">(</span> <span class="o">*</span><span class="n">egl</span><span class="p">,</span> <span class="n">app</span> <span class="p">)</span> <span class="p">);</span>

<span class="hll"><span class="kt">long</span> <span class="n">lastTime</span> <span class="o">=</span> <span class="n">egl</span><span class="o">-&gt;</span><span class="n">getSystemTime</span><span class="p">();</span>
</span>
<span class="c1">// loop waiting for stuff to do.</span>

<span class="k">while</span><span class="p">(</span> <span class="n">nv_app_status_running</span><span class="p">(</span> <span class="n">app</span> <span class="p">)</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Read all pending events.</span>
  <span class="kt">int</span> <span class="n">ident</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">events</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">android_poll_source</span> <span class="o">*</span><span class="n">source</span><span class="p">;</span>

  <span class="c1">// If not rendering, we will block forever waiting for events.</span>
  <span class="c1">// If animating, we loop until all events are read, then continue</span>
  <span class="c1">// to draw the next frame of animation.</span>
  <span class="k">while</span><span class="p">(</span> <span class="p">(</span> <span class="n">ident</span> <span class="o">=</span> <span class="n">ALooper_pollAll</span><span class="p">(</span> <span class="p">(</span> <span class="p">(</span> <span class="n">nv_app_status_focused</span><span class="p">(</span> <span class="n">app</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">engine</span><span class="o">-&gt;</span><span class="n">isActiveMode</span><span class="p">()</span> <span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">250</span> <span class="p">),</span>
                                    <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">events</span><span class="p">,</span> <span class="p">(</span> <span class="kt">void</span> <span class="o">**</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">source</span> <span class="p">)</span> <span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">)</span>
  <span class="p">{</span>
      <span class="c1">// If we timed out, then there are no pending messages.</span>
      <span class="k">if</span><span class="p">(</span> <span class="n">ident</span> <span class="o">==</span> <span class="n">ALOOPER_POLL_TIMEOUT</span> <span class="p">)</span> <span class="p">{</span> <span class="k">break</span><span class="p">;</span> <span class="p">}</span>

      <span class="c1">// Process this event.</span>
      <span class="k">if</span><span class="p">(</span> <span class="n">source</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span>                <span class="p">{</span> <span class="n">source</span><span class="o">-&gt;</span><span class="n">process</span><span class="p">(</span> <span class="n">app</span><span class="p">,</span> <span class="n">source</span> <span class="p">);</span> <span class="p">}</span>

      <span class="c1">// Check if we are exiting.  If so, dump out.</span>
      <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">nv_app_status_running</span><span class="p">(</span> <span class="n">app</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span> <span class="k">break</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">}</span>

<span class="hll">  <span class="kt">long</span> <span class="n">currentTime</span> <span class="o">=</span> <span class="n">egl</span><span class="o">-&gt;</span><span class="n">getSystemTime</span><span class="p">();</span>
</span><span class="hll">
</span><span class="hll">  <span class="c1">// Clamp time - it must not go backwards, and we don&#39;t</span>
</span><span class="hll">  <span class="c1">// want it to be more than a half second to avoid huge</span>
</span><span class="hll">  <span class="c1">// delays causing issues.  Note that we do not clamp to above</span>
</span><span class="hll">  <span class="c1">// zero because some tools will give us zero delta.</span>
</span><span class="hll">  <span class="kt">long</span> <span class="n">deltaTime</span> <span class="o">=</span> <span class="n">currentTime</span> <span class="o">-</span> <span class="n">lastTime</span><span class="p">;</span>
</span><span class="hll">  <span class="k">if</span>     <span class="p">(</span> <span class="n">deltaTime</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span>    <span class="p">{</span> <span class="n">deltaTime</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
</span><span class="hll">  <span class="k">else</span> <span class="k">if</span><span class="p">(</span> <span class="n">deltaTime</span> <span class="o">&gt;</span> <span class="mi">500</span> <span class="p">)</span>  <span class="p">{</span> <span class="n">deltaTime</span> <span class="o">=</span> <span class="mi">500</span><span class="p">;</span> <span class="p">}</span>
</span><span class="hll">  <span class="n">lastTime</span> <span class="o">=</span> <span class="n">currentTime</span><span class="p">;</span>
</span><span class="hll">
</span><span class="hll">  <span class="c1">// Update the frame, which optionally updates time and animations,</span>
</span><span class="hll">  <span class="c1">// and renders.</span>
</span><span class="hll">  <span class="n">engine</span><span class="o">-&gt;</span><span class="n">updateFrame</span><span class="p">(</span> <span class="n">nv_app_status_interactable</span><span class="p">(</span> <span class="n">app</span> <span class="p">),</span> <span class="n">deltaTime</span> <span class="p">);</span>
</span><span class="p">}</span>
</pre></div>
</div>
<p>And now you&#8217;re finally ready to test your application! Right-click on the project folder,
<em>Run as &gt; Android Application</em>.</p>
<p>If you followed the instructions in this tutorial you the application should start on your device
and you should see the NVIDIA wallpaper. However, when you press the <strong>ON</strong> button you will just
see a black screen on your device, instead of the gradient image.</p>
<p>Let&#8217;s try to find out why. Open the Logcat (<em>Window &gt; Show View &gt; Other &gt; Android &gt; LogCat</em>); if
you filter the messages by with the tag <cite>nv_shader</cite> you should see something like this:</p>
<a class="reference internal image-reference" href="_images/GL_shaderError.png"><img alt="_images/GL_shaderError.png" src="_images/GL_shaderError.png" style="width: 956.25px; height: 648.0px;" /></a>
<p>If you look at the line above the selected one, you will notice that <tt class="docutils literal"><span class="pre">filter.vert</span></tt> was correctly
compiled while <tt class="docutils literal"><span class="pre">filter.frag</span></tt> generated an error. We also know the lines of the errors, the numbers
in parenthesis. Line 59 of the shader is (your line numbering might be different):</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">gl_FragColor</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">texture2D</span><span class="p">(</span> <span class="n">uTex</span><span class="p">,</span> <span class="n">vTexCoord</span> <span class="o">+</span> <span class="n">vec2</span><span class="p">(</span>   <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="n">uD</span><span class="p">.</span><span class="n">y</span> <span class="p">)</span> <span class="p">);</span>
<span class="p">...</span>
<span class="n">gl_FragColor</span> <span class="o">-=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">texture2D</span><span class="p">(</span> <span class="n">uTex</span><span class="p">,</span> <span class="n">vTexCoord</span> <span class="o">+</span> <span class="n">vec2</span><span class="p">(</span>   <span class="mf">0.0</span><span class="p">,</span>  <span class="n">uD</span><span class="p">.</span><span class="n">y</span> <span class="p">)</span> <span class="p">);</span>
</pre></div>
</div>
<p>and the error says:</p>
<div class="highlight-python"><pre>error C7011 Implicit cast from "int" to "mediump float"</pre>
</div>
<p>basically the problem is that we cannot do implicit casting in GL and everything is assumed to be
float; we can fix the problem by replacing the above lines with:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">gl_FragColor</span> <span class="o">+=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">texture2D</span><span class="p">(</span> <span class="n">uTex</span><span class="p">,</span> <span class="n">vTexCoord</span> <span class="o">+</span> <span class="n">vec2</span><span class="p">(</span>   <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="n">uD</span><span class="p">.</span><span class="n">y</span> <span class="p">)</span> <span class="p">);</span>
<span class="p">...</span>
<span class="n">gl_FragColor</span> <span class="o">-=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">texture2D</span><span class="p">(</span> <span class="n">uTex</span><span class="p">,</span> <span class="n">vTexCoord</span> <span class="o">+</span> <span class="n">vec2</span><span class="p">(</span>   <span class="mf">0.0</span><span class="p">,</span>  <span class="n">uD</span><span class="p">.</span><span class="n">y</span> <span class="p">)</span> <span class="p">);</span>
</pre></div>
</div>
<p>In general when you get a black screen instead of what you were expecting, the first thing you should
do is go look at the LogCat and check for errors. Much like in the implicit cast example shown above,
if you are using the utility functions from NVIDIA, errors shoud be caught and logged in the LogCat.</p>
<p>This concludes our GL tutorial.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="opencv.html" title="OpenCV on Tegra"
             >next</a> |</li>
        <li class="right" >
          <a href="devprocess.html" title="Introduction to Android development"
             >previous</a> |</li>
        <li><a href="index.html">home</a>|&nbsp;</li>
        <li><a href="search.html">search</a>|&nbsp;</li>
 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, NVIDIA Research - Mobile Visual Computing.
      Last updated on Jun 13, 2013.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>